// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_wallets

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func WalletsResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"lago_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Unique identifier assigned to the wallet within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the wallet's record within the Lago system.",
				MarkdownDescription: "Unique identifier assigned to the wallet within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the wallet's record within the Lago system.",
			},
			"page": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Page number.",
				MarkdownDescription: "Page number.",
			},
			"per_page": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of records per page.",
				MarkdownDescription: "Number of records per page.",
			},
			"status": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The status of the wallet transaction. Possible values are `pending` or `settled`.",
				MarkdownDescription: "The status of the wallet transaction. Possible values are `pending` or `settled`.",
			},
			"transaction_status": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The transaction status of the wallet transaction. Possible values are `purchased` (with pending or settled status), `granted` (without invoice_id), `voided` or `invoiced`.",
				MarkdownDescription: "The transaction status of the wallet transaction. Possible values are `purchased` (with pending or settled status), `granted` (without invoice_id), `voided` or `invoiced`.",
			},
			"transaction_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The transaction type of the wallet transaction. Possible values are `inbound` (increasing the wallet balance) or `outbound` (decreasing the wallet balance).",
				MarkdownDescription: "The transaction type of the wallet transaction. Possible values are `inbound` (increasing the wallet balance) or `outbound` (decreasing the wallet balance).",
			},
			"wallet": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"balance_cents": schema.Int64Attribute{
						Computed:            true,
						Description:         "The current wallet balance expressed in cents. This reflects the available balance after all transactions are settled.",
						MarkdownDescription: "The current wallet balance expressed in cents. This reflects the available balance after all transactions are settled.",
					},
					"consumed_credits": schema.StringAttribute{
						Computed:            true,
						Description:         "The number of consumed credits.",
						MarkdownDescription: "The number of consumed credits.",
					},
					"created_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date of the wallet creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC).",
						MarkdownDescription: "The date of the wallet creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC).",
					},
					"credits_balance": schema.StringAttribute{
						Computed:            true,
						Description:         "The current wallet balance expressed in credits. This reflects the available balance after all transactions are settled.",
						MarkdownDescription: "The current wallet balance expressed in credits. This reflects the available balance after all transactions are settled.",
					},
					"credits_ongoing_balance": schema.StringAttribute{
						Computed:            true,
						Description:         "The ongoing wallet balance expressed in credits. This represents the `credits_balance` minus the `credits_ongoing_usage_balance`, showing the real time balance after accounting for current usage including taxes.",
						MarkdownDescription: "The ongoing wallet balance expressed in credits. This represents the `credits_balance` minus the `credits_ongoing_usage_balance`, showing the real time balance after accounting for current usage including taxes.",
					},
					"credits_ongoing_usage_balance": schema.StringAttribute{
						Computed:            true,
						Description:         "The ongoing usage balance of the wallet, expressed in credits. This reflects all current usage and draft invoices including taxes.",
						MarkdownDescription: "The ongoing usage balance of the wallet, expressed in credits. This reflects all current usage and draft invoices including taxes.",
					},
					"currency": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AED",
								"AFN",
								"ALL",
								"AMD",
								"ANG",
								"AOA",
								"ARS",
								"AUD",
								"AWG",
								"AZN",
								"BAM",
								"BBD",
								"BDT",
								"BGN",
								"BIF",
								"BMD",
								"BND",
								"BOB",
								"BRL",
								"BSD",
								"BWP",
								"BYN",
								"BZD",
								"CAD",
								"CDF",
								"CHF",
								"CLF",
								"CLP",
								"CNY",
								"COP",
								"CRC",
								"CVE",
								"CZK",
								"DJF",
								"DKK",
								"DOP",
								"DZD",
								"EGP",
								"ETB",
								"EUR",
								"FJD",
								"FKP",
								"GBP",
								"GEL",
								"GIP",
								"GMD",
								"GNF",
								"GTQ",
								"GYD",
								"HKD",
								"HNL",
								"HRK",
								"HTG",
								"HUF",
								"IDR",
								"ILS",
								"INR",
								"ISK",
								"JMD",
								"JPY",
								"KES",
								"KGS",
								"KHR",
								"KMF",
								"KRW",
								"KYD",
								"KZT",
								"LAK",
								"LBP",
								"LKR",
								"LRD",
								"LSL",
								"MAD",
								"MDL",
								"MGA",
								"MKD",
								"MMK",
								"MNT",
								"MOP",
								"MRO",
								"MUR",
								"MVR",
								"MWK",
								"MXN",
								"MYR",
								"MZN",
								"NAD",
								"NGN",
								"NIO",
								"NOK",
								"NPR",
								"NZD",
								"PAB",
								"PEN",
								"PGK",
								"PHP",
								"PKR",
								"PLN",
								"PYG",
								"QAR",
								"RON",
								"RSD",
								"RUB",
								"RWF",
								"SAR",
								"SBD",
								"SCR",
								"SEK",
								"SGD",
								"SHP",
								"SLL",
								"SOS",
								"SRD",
								"STD",
								"SZL",
								"THB",
								"TJS",
								"TOP",
								"TRY",
								"TTD",
								"TWD",
								"TZS",
								"UAH",
								"UGX",
								"USD",
								"UYU",
								"UZS",
								"VND",
								"VUV",
								"WST",
								"XAF",
								"XCD",
								"XOF",
								"XPF",
								"YER",
								"ZAR",
								"ZMW",
							),
						},
					},
					"expiration_at": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The date and time that determines when the wallet will expire. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).",
						MarkdownDescription: "The date and time that determines when the wallet will expire. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).",
					},
					"external_customer_id": schema.StringAttribute{
						Required:            true,
						Description:         "The customer external unique identifier (provided by your own application)",
						MarkdownDescription: "The customer external unique identifier (provided by your own application)",
					},
					"granted_credits": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The number of free granted credits. Required only if there is no paid credits.",
						MarkdownDescription: "The number of free granted credits. Required only if there is no paid credits.",
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
						},
					},
					"invoice_requires_successful_payment": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "A boolean setting that, when set to true, delays issuing an invoice for a wallet top-up until a successful payment is made; if false, the invoice is issued immediately upon wallet top-up, regardless of the payment status. Default value of false.",
						MarkdownDescription: "A boolean setting that, when set to true, delays issuing an invoice for a wallet top-up until a successful payment is made; if false, the invoice is issued immediately upon wallet top-up, regardless of the payment status. Default value of false.",
					},
					"lago_customer_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the customer within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the customer's record within the Lago system.",
						MarkdownDescription: "Unique identifier assigned to the customer within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the customer's record within the Lago system.",
					},
					"lago_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the wallet within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the wallet's record within the Lago system.",
						MarkdownDescription: "Unique identifier assigned to the wallet within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the wallet's record within the Lago system.",
					},
					"last_balance_sync_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date and time of the last balance top-up. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).",
						MarkdownDescription: "The date and time of the last balance top-up. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).",
					},
					"last_consumed_credit_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date and time of the last credits consumption. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).",
						MarkdownDescription: "The date and time of the last credits consumption. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).",
					},
					"name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The name of the wallet.",
						MarkdownDescription: "The name of the wallet.",
					},
					"ongoing_balance_cents": schema.Int64Attribute{
						Computed:            true,
						Description:         "The ongoing wallet balance expressed in cents. This represents the `balance_cents` minus the `ongoing_usage_balance_cents`, showing the real time balance after accounting for current usage including taxes.",
						MarkdownDescription: "The ongoing wallet balance expressed in cents. This represents the `balance_cents` minus the `ongoing_usage_balance_cents`, showing the real time balance after accounting for current usage including taxes.",
					},
					"ongoing_usage_balance_cents": schema.Int64Attribute{
						Computed:            true,
						Description:         "The ongoing usage balance of the wallet, expressed in cents. This reflects all current usage and draft invoices including taxes.",
						MarkdownDescription: "The ongoing usage balance of the wallet, expressed in cents. This reflects all current usage and draft invoices including taxes.",
					},
					"paid_credits": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The number of paid credits. Required only if there is no granted credits.",
						MarkdownDescription: "The number of paid credits. Required only if there is no granted credits.",
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
						},
					},
					"rate_amount": schema.StringAttribute{
						Required:            true,
						Description:         "The rate of conversion between credits and the amount in the specified currency. It indicates the ratio or factor used to convert credits into the corresponding monetary value in the currency of the transaction.",
						MarkdownDescription: "The rate of conversion between credits and the amount in the specified currency. It indicates the ratio or factor used to convert credits into the corresponding monetary value in the currency of the transaction.",
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
						},
					},
					"recurring_transaction_rules": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The date of the metadata object creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the metadata object was created",
									MarkdownDescription: "The date of the metadata object creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the metadata object was created",
								},
								"granted_credits": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The number of free granted credits used for recurring top-up.",
									MarkdownDescription: "The number of free granted credits used for recurring top-up.",
									Validators: []validator.String{
										stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
									},
								},
								"interval": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The interval used for recurring top-up. It represents the frequency at which automatic top-up occurs. The interval can be one of the following values: `weekly`, `monthly`, `quarterly` or `yearly`. Required only when trigger is `interval`.",
									MarkdownDescription: "The interval used for recurring top-up. It represents the frequency at which automatic top-up occurs. The interval can be one of the following values: `weekly`, `monthly`, `quarterly` or `yearly`. Required only when trigger is `interval`.",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"weekly",
											"monthly",
											"quarterly",
											"yearly",
										),
									},
								},
								"invoice_requires_successful_payment": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "A boolean setting that, when set to true, delays issuing an invoice for a wallet top-up until a successful payment is made; if false, the invoice is issued immediately upon wallet top-up, regardless of the payment status. Default value of false.",
									MarkdownDescription: "A boolean setting that, when set to true, delays issuing an invoice for a wallet top-up until a successful payment is made; if false, the invoice is issued immediately upon wallet top-up, regardless of the payment status. Default value of false.",
								},
								"lago_id": schema.StringAttribute{
									Computed:            true,
									Description:         "A unique identifier for the recurring transaction rule in the Lago application. Can be used to update a recurring transaction rule.",
									MarkdownDescription: "A unique identifier for the recurring transaction rule in the Lago application. Can be used to update a recurring transaction rule.",
								},
								"method": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The method used for recurring top-up. Possible values are `fixed` or `target`.",
									MarkdownDescription: "The method used for recurring top-up. Possible values are `fixed` or `target`.",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"fixed",
											"target",
										),
									},
								},
								"paid_credits": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The number of paid credits used for recurring top-up.",
									MarkdownDescription: "The number of paid credits used for recurring top-up.",
									Validators: []validator.String{
										stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
									},
								},
								"started_at": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The effective start date for recurring top-ups. This date should be provided in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC).",
									MarkdownDescription: "The effective start date for recurring top-ups. This date should be provided in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC).",
								},
								"target_ongoing_balance": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The target ongoing balance is the value set for the ongoing balance to be reached by the automatic top-up. Required only when trigger is set to `target`.",
									MarkdownDescription: "The target ongoing balance is the value set for the ongoing balance to be reached by the automatic top-up. Required only when trigger is set to `target`.",
									Validators: []validator.String{
										stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
									},
								},
								"threshold_credits": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The threshold for recurring top-ups is the value at which an automatic top-up is triggered. For example, if this threshold is set at 10 credits, an automatic top-up will occur whenever the wallet balance falls to or below 10 credits. Required only when trigger is set to `threshold`.",
									MarkdownDescription: "The threshold for recurring top-ups is the value at which an automatic top-up is triggered. For example, if this threshold is set at 10 credits, an automatic top-up will occur whenever the wallet balance falls to or below 10 credits. Required only when trigger is set to `threshold`.",
									Validators: []validator.String{
										stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
									},
								},
								"transaction_metadata": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"key": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "The unique identifier for the attribute.",
												MarkdownDescription: "The unique identifier for the attribute.",
											},
											"value": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "The value associated with the key.",
												MarkdownDescription: "The value associated with the key.",
											},
										},
										CustomType: TransactionMetadataType{
											ObjectType: types.ObjectType{
												AttrTypes: TransactionMetadataValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "This optional field allows you to store a list of key-value pairs containing additional information or custom attributes. These key-value pairs will populate the metadata of the wallet transactions triggered by this rule.",
									MarkdownDescription: "This optional field allows you to store a list of key-value pairs containing additional information or custom attributes. These key-value pairs will populate the metadata of the wallet transactions triggered by this rule.",
								},
								"trigger": schema.StringAttribute{
									Required:            true,
									Description:         "The trigger. Possible values are `interval` or `threshold`.",
									MarkdownDescription: "The trigger. Possible values are `interval` or `threshold`.",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"interval",
											"threshold",
										),
									},
								},
							},
							CustomType: RecurringTransactionRulesType{
								ObjectType: types.ObjectType{
									AttrTypes: RecurringTransactionRulesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "List of recurring transaction rules. Currently, we only allow one recurring rule per wallet.",
						MarkdownDescription: "List of recurring transaction rules. Currently, we only allow one recurring rule per wallet.",
					},
					"status": schema.StringAttribute{
						Computed:            true,
						Description:         "The status of the wallet. Possible values are `active` or `terminated`.",
						MarkdownDescription: "The status of the wallet. Possible values are `active` or `terminated`.",
					},
					"terminated_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date of terminaison of the wallet. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).",
						MarkdownDescription: "The date of terminaison of the wallet. It follows the ISO 8601 datetime format and is expressed in Coordinated Universal Time (UTC).",
					},
					"transaction_metadata": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The unique identifier for the attribute.",
									MarkdownDescription: "The unique identifier for the attribute.",
								},
								"value": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The corresponding value for the key.",
									MarkdownDescription: "The corresponding value for the key.",
								},
							},
							CustomType: TransactionMetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: TransactionMetadataValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "This optional field allows you to store a list of key-value pairs that provide additional information or custom attributes. These key-value pairs will be included in the metadata of wallet transactions generated during the wallet creation process.",
						MarkdownDescription: "This optional field allows you to store a list of key-value pairs that provide additional information or custom attributes. These key-value pairs will be included in the metadata of wallet transactions generated during the wallet creation process.",
					},
				},
				CustomType: WalletType{
					ObjectType: types.ObjectType{
						AttrTypes: WalletValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
				Computed: true,
			},
		},
	}
}

type WalletsModel struct {
	LagoId            types.String `tfsdk:"lago_id"`
	Page              types.Int64  `tfsdk:"page"`
	PerPage           types.Int64  `tfsdk:"per_page"`
	Status            types.String `tfsdk:"status"`
	TransactionStatus types.String `tfsdk:"transaction_status"`
	TransactionType   types.String `tfsdk:"transaction_type"`
	Wallet            WalletValue  `tfsdk:"wallet"`
}

var _ basetypes.ObjectTypable = WalletType{}

type WalletType struct {
	basetypes.ObjectType
}

func (t WalletType) Equal(o attr.Type) bool {
	other, ok := o.(WalletType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WalletType) String() string {
	return "WalletType"
}

func (t WalletType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	balanceCentsAttribute, ok := attributes["balance_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`balance_cents is missing from object`)

		return nil, diags
	}

	balanceCentsVal, ok := balanceCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`balance_cents expected to be basetypes.Int64Value, was: %T`, balanceCentsAttribute))
	}

	consumedCreditsAttribute, ok := attributes["consumed_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`consumed_credits is missing from object`)

		return nil, diags
	}

	consumedCreditsVal, ok := consumedCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`consumed_credits expected to be basetypes.StringValue, was: %T`, consumedCreditsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	creditsBalanceAttribute, ok := attributes["credits_balance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credits_balance is missing from object`)

		return nil, diags
	}

	creditsBalanceVal, ok := creditsBalanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credits_balance expected to be basetypes.StringValue, was: %T`, creditsBalanceAttribute))
	}

	creditsOngoingBalanceAttribute, ok := attributes["credits_ongoing_balance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credits_ongoing_balance is missing from object`)

		return nil, diags
	}

	creditsOngoingBalanceVal, ok := creditsOngoingBalanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credits_ongoing_balance expected to be basetypes.StringValue, was: %T`, creditsOngoingBalanceAttribute))
	}

	creditsOngoingUsageBalanceAttribute, ok := attributes["credits_ongoing_usage_balance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credits_ongoing_usage_balance is missing from object`)

		return nil, diags
	}

	creditsOngoingUsageBalanceVal, ok := creditsOngoingUsageBalanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credits_ongoing_usage_balance expected to be basetypes.StringValue, was: %T`, creditsOngoingUsageBalanceAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return nil, diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	expirationAtAttribute, ok := attributes["expiration_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expiration_at is missing from object`)

		return nil, diags
	}

	expirationAtVal, ok := expirationAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expiration_at expected to be basetypes.StringValue, was: %T`, expirationAtAttribute))
	}

	externalCustomerIdAttribute, ok := attributes["external_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_customer_id is missing from object`)

		return nil, diags
	}

	externalCustomerIdVal, ok := externalCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_customer_id expected to be basetypes.StringValue, was: %T`, externalCustomerIdAttribute))
	}

	grantedCreditsAttribute, ok := attributes["granted_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`granted_credits is missing from object`)

		return nil, diags
	}

	grantedCreditsVal, ok := grantedCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`granted_credits expected to be basetypes.StringValue, was: %T`, grantedCreditsAttribute))
	}

	invoiceRequiresSuccessfulPaymentAttribute, ok := attributes["invoice_requires_successful_payment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_requires_successful_payment is missing from object`)

		return nil, diags
	}

	invoiceRequiresSuccessfulPaymentVal, ok := invoiceRequiresSuccessfulPaymentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_requires_successful_payment expected to be basetypes.BoolValue, was: %T`, invoiceRequiresSuccessfulPaymentAttribute))
	}

	lagoCustomerIdAttribute, ok := attributes["lago_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_customer_id is missing from object`)

		return nil, diags
	}

	lagoCustomerIdVal, ok := lagoCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_customer_id expected to be basetypes.StringValue, was: %T`, lagoCustomerIdAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lastBalanceSyncAtAttribute, ok := attributes["last_balance_sync_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_balance_sync_at is missing from object`)

		return nil, diags
	}

	lastBalanceSyncAtVal, ok := lastBalanceSyncAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_balance_sync_at expected to be basetypes.StringValue, was: %T`, lastBalanceSyncAtAttribute))
	}

	lastConsumedCreditAtAttribute, ok := attributes["last_consumed_credit_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_consumed_credit_at is missing from object`)

		return nil, diags
	}

	lastConsumedCreditAtVal, ok := lastConsumedCreditAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_consumed_credit_at expected to be basetypes.StringValue, was: %T`, lastConsumedCreditAtAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	ongoingBalanceCentsAttribute, ok := attributes["ongoing_balance_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ongoing_balance_cents is missing from object`)

		return nil, diags
	}

	ongoingBalanceCentsVal, ok := ongoingBalanceCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ongoing_balance_cents expected to be basetypes.Int64Value, was: %T`, ongoingBalanceCentsAttribute))
	}

	ongoingUsageBalanceCentsAttribute, ok := attributes["ongoing_usage_balance_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ongoing_usage_balance_cents is missing from object`)

		return nil, diags
	}

	ongoingUsageBalanceCentsVal, ok := ongoingUsageBalanceCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ongoing_usage_balance_cents expected to be basetypes.Int64Value, was: %T`, ongoingUsageBalanceCentsAttribute))
	}

	paidCreditsAttribute, ok := attributes["paid_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paid_credits is missing from object`)

		return nil, diags
	}

	paidCreditsVal, ok := paidCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paid_credits expected to be basetypes.StringValue, was: %T`, paidCreditsAttribute))
	}

	rateAmountAttribute, ok := attributes["rate_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate_amount is missing from object`)

		return nil, diags
	}

	rateAmountVal, ok := rateAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate_amount expected to be basetypes.StringValue, was: %T`, rateAmountAttribute))
	}

	recurringTransactionRulesAttribute, ok := attributes["recurring_transaction_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recurring_transaction_rules is missing from object`)

		return nil, diags
	}

	recurringTransactionRulesVal, ok := recurringTransactionRulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recurring_transaction_rules expected to be basetypes.ListValue, was: %T`, recurringTransactionRulesAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	terminatedAtAttribute, ok := attributes["terminated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`terminated_at is missing from object`)

		return nil, diags
	}

	terminatedAtVal, ok := terminatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`terminated_at expected to be basetypes.StringValue, was: %T`, terminatedAtAttribute))
	}

	transactionMetadataAttribute, ok := attributes["transaction_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transaction_metadata is missing from object`)

		return nil, diags
	}

	transactionMetadataVal, ok := transactionMetadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transaction_metadata expected to be basetypes.ListValue, was: %T`, transactionMetadataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WalletValue{
		BalanceCents:                     balanceCentsVal,
		ConsumedCredits:                  consumedCreditsVal,
		CreatedAt:                        createdAtVal,
		CreditsBalance:                   creditsBalanceVal,
		CreditsOngoingBalance:            creditsOngoingBalanceVal,
		CreditsOngoingUsageBalance:       creditsOngoingUsageBalanceVal,
		Currency:                         currencyVal,
		ExpirationAt:                     expirationAtVal,
		ExternalCustomerId:               externalCustomerIdVal,
		GrantedCredits:                   grantedCreditsVal,
		InvoiceRequiresSuccessfulPayment: invoiceRequiresSuccessfulPaymentVal,
		LagoCustomerId:                   lagoCustomerIdVal,
		LagoId:                           lagoIdVal,
		LastBalanceSyncAt:                lastBalanceSyncAtVal,
		LastConsumedCreditAt:             lastConsumedCreditAtVal,
		Name:                             nameVal,
		OngoingBalanceCents:              ongoingBalanceCentsVal,
		OngoingUsageBalanceCents:         ongoingUsageBalanceCentsVal,
		PaidCredits:                      paidCreditsVal,
		RateAmount:                       rateAmountVal,
		RecurringTransactionRules:        recurringTransactionRulesVal,
		Status:                           statusVal,
		TerminatedAt:                     terminatedAtVal,
		TransactionMetadata:              transactionMetadataVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewWalletValueNull() WalletValue {
	return WalletValue{
		state: attr.ValueStateNull,
	}
}

func NewWalletValueUnknown() WalletValue {
	return WalletValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWalletValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WalletValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WalletValue Attribute Value",
				"While creating a WalletValue value, a missing attribute value was detected. "+
					"A WalletValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WalletValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WalletValue Attribute Type",
				"While creating a WalletValue value, an invalid attribute value was detected. "+
					"A WalletValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WalletValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WalletValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WalletValue Attribute Value",
				"While creating a WalletValue value, an extra attribute value was detected. "+
					"A WalletValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WalletValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWalletValueUnknown(), diags
	}

	balanceCentsAttribute, ok := attributes["balance_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`balance_cents is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	balanceCentsVal, ok := balanceCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`balance_cents expected to be basetypes.Int64Value, was: %T`, balanceCentsAttribute))
	}

	consumedCreditsAttribute, ok := attributes["consumed_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`consumed_credits is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	consumedCreditsVal, ok := consumedCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`consumed_credits expected to be basetypes.StringValue, was: %T`, consumedCreditsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	creditsBalanceAttribute, ok := attributes["credits_balance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credits_balance is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	creditsBalanceVal, ok := creditsBalanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credits_balance expected to be basetypes.StringValue, was: %T`, creditsBalanceAttribute))
	}

	creditsOngoingBalanceAttribute, ok := attributes["credits_ongoing_balance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credits_ongoing_balance is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	creditsOngoingBalanceVal, ok := creditsOngoingBalanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credits_ongoing_balance expected to be basetypes.StringValue, was: %T`, creditsOngoingBalanceAttribute))
	}

	creditsOngoingUsageBalanceAttribute, ok := attributes["credits_ongoing_usage_balance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credits_ongoing_usage_balance is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	creditsOngoingUsageBalanceVal, ok := creditsOngoingUsageBalanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credits_ongoing_usage_balance expected to be basetypes.StringValue, was: %T`, creditsOngoingUsageBalanceAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	expirationAtAttribute, ok := attributes["expiration_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expiration_at is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	expirationAtVal, ok := expirationAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expiration_at expected to be basetypes.StringValue, was: %T`, expirationAtAttribute))
	}

	externalCustomerIdAttribute, ok := attributes["external_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_customer_id is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	externalCustomerIdVal, ok := externalCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_customer_id expected to be basetypes.StringValue, was: %T`, externalCustomerIdAttribute))
	}

	grantedCreditsAttribute, ok := attributes["granted_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`granted_credits is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	grantedCreditsVal, ok := grantedCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`granted_credits expected to be basetypes.StringValue, was: %T`, grantedCreditsAttribute))
	}

	invoiceRequiresSuccessfulPaymentAttribute, ok := attributes["invoice_requires_successful_payment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_requires_successful_payment is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	invoiceRequiresSuccessfulPaymentVal, ok := invoiceRequiresSuccessfulPaymentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_requires_successful_payment expected to be basetypes.BoolValue, was: %T`, invoiceRequiresSuccessfulPaymentAttribute))
	}

	lagoCustomerIdAttribute, ok := attributes["lago_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_customer_id is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	lagoCustomerIdVal, ok := lagoCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_customer_id expected to be basetypes.StringValue, was: %T`, lagoCustomerIdAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lastBalanceSyncAtAttribute, ok := attributes["last_balance_sync_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_balance_sync_at is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	lastBalanceSyncAtVal, ok := lastBalanceSyncAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_balance_sync_at expected to be basetypes.StringValue, was: %T`, lastBalanceSyncAtAttribute))
	}

	lastConsumedCreditAtAttribute, ok := attributes["last_consumed_credit_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_consumed_credit_at is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	lastConsumedCreditAtVal, ok := lastConsumedCreditAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_consumed_credit_at expected to be basetypes.StringValue, was: %T`, lastConsumedCreditAtAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	ongoingBalanceCentsAttribute, ok := attributes["ongoing_balance_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ongoing_balance_cents is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	ongoingBalanceCentsVal, ok := ongoingBalanceCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ongoing_balance_cents expected to be basetypes.Int64Value, was: %T`, ongoingBalanceCentsAttribute))
	}

	ongoingUsageBalanceCentsAttribute, ok := attributes["ongoing_usage_balance_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ongoing_usage_balance_cents is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	ongoingUsageBalanceCentsVal, ok := ongoingUsageBalanceCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ongoing_usage_balance_cents expected to be basetypes.Int64Value, was: %T`, ongoingUsageBalanceCentsAttribute))
	}

	paidCreditsAttribute, ok := attributes["paid_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paid_credits is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	paidCreditsVal, ok := paidCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paid_credits expected to be basetypes.StringValue, was: %T`, paidCreditsAttribute))
	}

	rateAmountAttribute, ok := attributes["rate_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate_amount is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	rateAmountVal, ok := rateAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate_amount expected to be basetypes.StringValue, was: %T`, rateAmountAttribute))
	}

	recurringTransactionRulesAttribute, ok := attributes["recurring_transaction_rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recurring_transaction_rules is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	recurringTransactionRulesVal, ok := recurringTransactionRulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recurring_transaction_rules expected to be basetypes.ListValue, was: %T`, recurringTransactionRulesAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	terminatedAtAttribute, ok := attributes["terminated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`terminated_at is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	terminatedAtVal, ok := terminatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`terminated_at expected to be basetypes.StringValue, was: %T`, terminatedAtAttribute))
	}

	transactionMetadataAttribute, ok := attributes["transaction_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transaction_metadata is missing from object`)

		return NewWalletValueUnknown(), diags
	}

	transactionMetadataVal, ok := transactionMetadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transaction_metadata expected to be basetypes.ListValue, was: %T`, transactionMetadataAttribute))
	}

	if diags.HasError() {
		return NewWalletValueUnknown(), diags
	}

	return WalletValue{
		BalanceCents:                     balanceCentsVal,
		ConsumedCredits:                  consumedCreditsVal,
		CreatedAt:                        createdAtVal,
		CreditsBalance:                   creditsBalanceVal,
		CreditsOngoingBalance:            creditsOngoingBalanceVal,
		CreditsOngoingUsageBalance:       creditsOngoingUsageBalanceVal,
		Currency:                         currencyVal,
		ExpirationAt:                     expirationAtVal,
		ExternalCustomerId:               externalCustomerIdVal,
		GrantedCredits:                   grantedCreditsVal,
		InvoiceRequiresSuccessfulPayment: invoiceRequiresSuccessfulPaymentVal,
		LagoCustomerId:                   lagoCustomerIdVal,
		LagoId:                           lagoIdVal,
		LastBalanceSyncAt:                lastBalanceSyncAtVal,
		LastConsumedCreditAt:             lastConsumedCreditAtVal,
		Name:                             nameVal,
		OngoingBalanceCents:              ongoingBalanceCentsVal,
		OngoingUsageBalanceCents:         ongoingUsageBalanceCentsVal,
		PaidCredits:                      paidCreditsVal,
		RateAmount:                       rateAmountVal,
		RecurringTransactionRules:        recurringTransactionRulesVal,
		Status:                           statusVal,
		TerminatedAt:                     terminatedAtVal,
		TransactionMetadata:              transactionMetadataVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewWalletValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WalletValue {
	object, diags := NewWalletValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWalletValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WalletType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWalletValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWalletValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWalletValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWalletValueMust(WalletValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WalletType) ValueType(ctx context.Context) attr.Value {
	return WalletValue{}
}

var _ basetypes.ObjectValuable = WalletValue{}

type WalletValue struct {
	BalanceCents                     basetypes.Int64Value  `tfsdk:"balance_cents"`
	ConsumedCredits                  basetypes.StringValue `tfsdk:"consumed_credits"`
	CreatedAt                        basetypes.StringValue `tfsdk:"created_at"`
	CreditsBalance                   basetypes.StringValue `tfsdk:"credits_balance"`
	CreditsOngoingBalance            basetypes.StringValue `tfsdk:"credits_ongoing_balance"`
	CreditsOngoingUsageBalance       basetypes.StringValue `tfsdk:"credits_ongoing_usage_balance"`
	Currency                         basetypes.StringValue `tfsdk:"currency"`
	ExpirationAt                     basetypes.StringValue `tfsdk:"expiration_at"`
	ExternalCustomerId               basetypes.StringValue `tfsdk:"external_customer_id"`
	GrantedCredits                   basetypes.StringValue `tfsdk:"granted_credits"`
	InvoiceRequiresSuccessfulPayment basetypes.BoolValue   `tfsdk:"invoice_requires_successful_payment"`
	LagoCustomerId                   basetypes.StringValue `tfsdk:"lago_customer_id"`
	LagoId                           basetypes.StringValue `tfsdk:"lago_id"`
	LastBalanceSyncAt                basetypes.StringValue `tfsdk:"last_balance_sync_at"`
	LastConsumedCreditAt             basetypes.StringValue `tfsdk:"last_consumed_credit_at"`
	Name                             basetypes.StringValue `tfsdk:"name"`
	OngoingBalanceCents              basetypes.Int64Value  `tfsdk:"ongoing_balance_cents"`
	OngoingUsageBalanceCents         basetypes.Int64Value  `tfsdk:"ongoing_usage_balance_cents"`
	PaidCredits                      basetypes.StringValue `tfsdk:"paid_credits"`
	RateAmount                       basetypes.StringValue `tfsdk:"rate_amount"`
	RecurringTransactionRules        basetypes.ListValue   `tfsdk:"recurring_transaction_rules"`
	Status                           basetypes.StringValue `tfsdk:"status"`
	TerminatedAt                     basetypes.StringValue `tfsdk:"terminated_at"`
	TransactionMetadata              basetypes.ListValue   `tfsdk:"transaction_metadata"`
	state                            attr.ValueState
}

func (v WalletValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 24)

	var val tftypes.Value
	var err error

	attrTypes["balance_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["consumed_credits"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["credits_balance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["credits_ongoing_balance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["credits_ongoing_usage_balance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["expiration_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_customer_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["granted_credits"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_requires_successful_payment"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["lago_customer_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_balance_sync_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_consumed_credit_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ongoing_balance_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ongoing_usage_balance_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["paid_credits"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recurring_transaction_rules"] = basetypes.ListType{
		ElemType: RecurringTransactionRulesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["terminated_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["transaction_metadata"] = basetypes.ListType{
		ElemType: TransactionMetadataValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 24)

		val, err = v.BalanceCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["balance_cents"] = val

		val, err = v.ConsumedCredits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["consumed_credits"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.CreditsBalance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["credits_balance"] = val

		val, err = v.CreditsOngoingBalance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["credits_ongoing_balance"] = val

		val, err = v.CreditsOngoingUsageBalance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["credits_ongoing_usage_balance"] = val

		val, err = v.Currency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["currency"] = val

		val, err = v.ExpirationAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expiration_at"] = val

		val, err = v.ExternalCustomerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_customer_id"] = val

		val, err = v.GrantedCredits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["granted_credits"] = val

		val, err = v.InvoiceRequiresSuccessfulPayment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_requires_successful_payment"] = val

		val, err = v.LagoCustomerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_customer_id"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.LastBalanceSyncAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_balance_sync_at"] = val

		val, err = v.LastConsumedCreditAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_consumed_credit_at"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OngoingBalanceCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ongoing_balance_cents"] = val

		val, err = v.OngoingUsageBalanceCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ongoing_usage_balance_cents"] = val

		val, err = v.PaidCredits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["paid_credits"] = val

		val, err = v.RateAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate_amount"] = val

		val, err = v.RecurringTransactionRules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recurring_transaction_rules"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.TerminatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["terminated_at"] = val

		val, err = v.TransactionMetadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transaction_metadata"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WalletValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WalletValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WalletValue) String() string {
	return "WalletValue"
}

func (v WalletValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	recurringTransactionRules := types.ListValueMust(
		RecurringTransactionRulesType{
			basetypes.ObjectType{
				AttrTypes: RecurringTransactionRulesValue{}.AttributeTypes(ctx),
			},
		},
		v.RecurringTransactionRules.Elements(),
	)

	if v.RecurringTransactionRules.IsNull() {
		recurringTransactionRules = types.ListNull(
			RecurringTransactionRulesType{
				basetypes.ObjectType{
					AttrTypes: RecurringTransactionRulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.RecurringTransactionRules.IsUnknown() {
		recurringTransactionRules = types.ListUnknown(
			RecurringTransactionRulesType{
				basetypes.ObjectType{
					AttrTypes: RecurringTransactionRulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	transactionMetadata := types.ListValueMust(
		TransactionMetadataType{
			basetypes.ObjectType{
				AttrTypes: TransactionMetadataValue{}.AttributeTypes(ctx),
			},
		},
		v.TransactionMetadata.Elements(),
	)

	if v.TransactionMetadata.IsNull() {
		transactionMetadata = types.ListNull(
			TransactionMetadataType{
				basetypes.ObjectType{
					AttrTypes: TransactionMetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TransactionMetadata.IsUnknown() {
		transactionMetadata = types.ListUnknown(
			TransactionMetadataType{
				basetypes.ObjectType{
					AttrTypes: TransactionMetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"balance_cents":                       basetypes.Int64Type{},
		"consumed_credits":                    basetypes.StringType{},
		"created_at":                          basetypes.StringType{},
		"credits_balance":                     basetypes.StringType{},
		"credits_ongoing_balance":             basetypes.StringType{},
		"credits_ongoing_usage_balance":       basetypes.StringType{},
		"currency":                            basetypes.StringType{},
		"expiration_at":                       basetypes.StringType{},
		"external_customer_id":                basetypes.StringType{},
		"granted_credits":                     basetypes.StringType{},
		"invoice_requires_successful_payment": basetypes.BoolType{},
		"lago_customer_id":                    basetypes.StringType{},
		"lago_id":                             basetypes.StringType{},
		"last_balance_sync_at":                basetypes.StringType{},
		"last_consumed_credit_at":             basetypes.StringType{},
		"name":                                basetypes.StringType{},
		"ongoing_balance_cents":               basetypes.Int64Type{},
		"ongoing_usage_balance_cents":         basetypes.Int64Type{},
		"paid_credits":                        basetypes.StringType{},
		"rate_amount":                         basetypes.StringType{},
		"recurring_transaction_rules": basetypes.ListType{
			ElemType: RecurringTransactionRulesValue{}.Type(ctx),
		},
		"status":        basetypes.StringType{},
		"terminated_at": basetypes.StringType{},
		"transaction_metadata": basetypes.ListType{
			ElemType: TransactionMetadataValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"balance_cents":                       v.BalanceCents,
			"consumed_credits":                    v.ConsumedCredits,
			"created_at":                          v.CreatedAt,
			"credits_balance":                     v.CreditsBalance,
			"credits_ongoing_balance":             v.CreditsOngoingBalance,
			"credits_ongoing_usage_balance":       v.CreditsOngoingUsageBalance,
			"currency":                            v.Currency,
			"expiration_at":                       v.ExpirationAt,
			"external_customer_id":                v.ExternalCustomerId,
			"granted_credits":                     v.GrantedCredits,
			"invoice_requires_successful_payment": v.InvoiceRequiresSuccessfulPayment,
			"lago_customer_id":                    v.LagoCustomerId,
			"lago_id":                             v.LagoId,
			"last_balance_sync_at":                v.LastBalanceSyncAt,
			"last_consumed_credit_at":             v.LastConsumedCreditAt,
			"name":                                v.Name,
			"ongoing_balance_cents":               v.OngoingBalanceCents,
			"ongoing_usage_balance_cents":         v.OngoingUsageBalanceCents,
			"paid_credits":                        v.PaidCredits,
			"rate_amount":                         v.RateAmount,
			"recurring_transaction_rules":         recurringTransactionRules,
			"status":                              v.Status,
			"terminated_at":                       v.TerminatedAt,
			"transaction_metadata":                transactionMetadata,
		})

	return objVal, diags
}

func (v WalletValue) Equal(o attr.Value) bool {
	other, ok := o.(WalletValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BalanceCents.Equal(other.BalanceCents) {
		return false
	}

	if !v.ConsumedCredits.Equal(other.ConsumedCredits) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.CreditsBalance.Equal(other.CreditsBalance) {
		return false
	}

	if !v.CreditsOngoingBalance.Equal(other.CreditsOngoingBalance) {
		return false
	}

	if !v.CreditsOngoingUsageBalance.Equal(other.CreditsOngoingUsageBalance) {
		return false
	}

	if !v.Currency.Equal(other.Currency) {
		return false
	}

	if !v.ExpirationAt.Equal(other.ExpirationAt) {
		return false
	}

	if !v.ExternalCustomerId.Equal(other.ExternalCustomerId) {
		return false
	}

	if !v.GrantedCredits.Equal(other.GrantedCredits) {
		return false
	}

	if !v.InvoiceRequiresSuccessfulPayment.Equal(other.InvoiceRequiresSuccessfulPayment) {
		return false
	}

	if !v.LagoCustomerId.Equal(other.LagoCustomerId) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.LastBalanceSyncAt.Equal(other.LastBalanceSyncAt) {
		return false
	}

	if !v.LastConsumedCreditAt.Equal(other.LastConsumedCreditAt) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OngoingBalanceCents.Equal(other.OngoingBalanceCents) {
		return false
	}

	if !v.OngoingUsageBalanceCents.Equal(other.OngoingUsageBalanceCents) {
		return false
	}

	if !v.PaidCredits.Equal(other.PaidCredits) {
		return false
	}

	if !v.RateAmount.Equal(other.RateAmount) {
		return false
	}

	if !v.RecurringTransactionRules.Equal(other.RecurringTransactionRules) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.TerminatedAt.Equal(other.TerminatedAt) {
		return false
	}

	if !v.TransactionMetadata.Equal(other.TransactionMetadata) {
		return false
	}

	return true
}

func (v WalletValue) Type(ctx context.Context) attr.Type {
	return WalletType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WalletValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"balance_cents":                       basetypes.Int64Type{},
		"consumed_credits":                    basetypes.StringType{},
		"created_at":                          basetypes.StringType{},
		"credits_balance":                     basetypes.StringType{},
		"credits_ongoing_balance":             basetypes.StringType{},
		"credits_ongoing_usage_balance":       basetypes.StringType{},
		"currency":                            basetypes.StringType{},
		"expiration_at":                       basetypes.StringType{},
		"external_customer_id":                basetypes.StringType{},
		"granted_credits":                     basetypes.StringType{},
		"invoice_requires_successful_payment": basetypes.BoolType{},
		"lago_customer_id":                    basetypes.StringType{},
		"lago_id":                             basetypes.StringType{},
		"last_balance_sync_at":                basetypes.StringType{},
		"last_consumed_credit_at":             basetypes.StringType{},
		"name":                                basetypes.StringType{},
		"ongoing_balance_cents":               basetypes.Int64Type{},
		"ongoing_usage_balance_cents":         basetypes.Int64Type{},
		"paid_credits":                        basetypes.StringType{},
		"rate_amount":                         basetypes.StringType{},
		"recurring_transaction_rules": basetypes.ListType{
			ElemType: RecurringTransactionRulesValue{}.Type(ctx),
		},
		"status":        basetypes.StringType{},
		"terminated_at": basetypes.StringType{},
		"transaction_metadata": basetypes.ListType{
			ElemType: TransactionMetadataValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = RecurringTransactionRulesType{}

type RecurringTransactionRulesType struct {
	basetypes.ObjectType
}

func (t RecurringTransactionRulesType) Equal(o attr.Type) bool {
	other, ok := o.(RecurringTransactionRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RecurringTransactionRulesType) String() string {
	return "RecurringTransactionRulesType"
}

func (t RecurringTransactionRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	grantedCreditsAttribute, ok := attributes["granted_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`granted_credits is missing from object`)

		return nil, diags
	}

	grantedCreditsVal, ok := grantedCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`granted_credits expected to be basetypes.StringValue, was: %T`, grantedCreditsAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return nil, diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	invoiceRequiresSuccessfulPaymentAttribute, ok := attributes["invoice_requires_successful_payment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_requires_successful_payment is missing from object`)

		return nil, diags
	}

	invoiceRequiresSuccessfulPaymentVal, ok := invoiceRequiresSuccessfulPaymentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_requires_successful_payment expected to be basetypes.BoolValue, was: %T`, invoiceRequiresSuccessfulPaymentAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	methodAttribute, ok := attributes["method"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`method is missing from object`)

		return nil, diags
	}

	methodVal, ok := methodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`method expected to be basetypes.StringValue, was: %T`, methodAttribute))
	}

	paidCreditsAttribute, ok := attributes["paid_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paid_credits is missing from object`)

		return nil, diags
	}

	paidCreditsVal, ok := paidCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paid_credits expected to be basetypes.StringValue, was: %T`, paidCreditsAttribute))
	}

	startedAtAttribute, ok := attributes["started_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`started_at is missing from object`)

		return nil, diags
	}

	startedAtVal, ok := startedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`started_at expected to be basetypes.StringValue, was: %T`, startedAtAttribute))
	}

	targetOngoingBalanceAttribute, ok := attributes["target_ongoing_balance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_ongoing_balance is missing from object`)

		return nil, diags
	}

	targetOngoingBalanceVal, ok := targetOngoingBalanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_ongoing_balance expected to be basetypes.StringValue, was: %T`, targetOngoingBalanceAttribute))
	}

	thresholdCreditsAttribute, ok := attributes["threshold_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold_credits is missing from object`)

		return nil, diags
	}

	thresholdCreditsVal, ok := thresholdCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold_credits expected to be basetypes.StringValue, was: %T`, thresholdCreditsAttribute))
	}

	transactionMetadataAttribute, ok := attributes["transaction_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transaction_metadata is missing from object`)

		return nil, diags
	}

	transactionMetadataVal, ok := transactionMetadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transaction_metadata expected to be basetypes.ListValue, was: %T`, transactionMetadataAttribute))
	}

	triggerAttribute, ok := attributes["trigger"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trigger is missing from object`)

		return nil, diags
	}

	triggerVal, ok := triggerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trigger expected to be basetypes.StringValue, was: %T`, triggerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RecurringTransactionRulesValue{
		CreatedAt:                        createdAtVal,
		GrantedCredits:                   grantedCreditsVal,
		Interval:                         intervalVal,
		InvoiceRequiresSuccessfulPayment: invoiceRequiresSuccessfulPaymentVal,
		LagoId:                           lagoIdVal,
		Method:                           methodVal,
		PaidCredits:                      paidCreditsVal,
		StartedAt:                        startedAtVal,
		TargetOngoingBalance:             targetOngoingBalanceVal,
		ThresholdCredits:                 thresholdCreditsVal,
		TransactionMetadata:              transactionMetadataVal,
		Trigger:                          triggerVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewRecurringTransactionRulesValueNull() RecurringTransactionRulesValue {
	return RecurringTransactionRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewRecurringTransactionRulesValueUnknown() RecurringTransactionRulesValue {
	return RecurringTransactionRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRecurringTransactionRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RecurringTransactionRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RecurringTransactionRulesValue Attribute Value",
				"While creating a RecurringTransactionRulesValue value, a missing attribute value was detected. "+
					"A RecurringTransactionRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RecurringTransactionRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RecurringTransactionRulesValue Attribute Type",
				"While creating a RecurringTransactionRulesValue value, an invalid attribute value was detected. "+
					"A RecurringTransactionRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RecurringTransactionRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RecurringTransactionRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RecurringTransactionRulesValue Attribute Value",
				"While creating a RecurringTransactionRulesValue value, an extra attribute value was detected. "+
					"A RecurringTransactionRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RecurringTransactionRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	grantedCreditsAttribute, ok := attributes["granted_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`granted_credits is missing from object`)

		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	grantedCreditsVal, ok := grantedCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`granted_credits expected to be basetypes.StringValue, was: %T`, grantedCreditsAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	invoiceRequiresSuccessfulPaymentAttribute, ok := attributes["invoice_requires_successful_payment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_requires_successful_payment is missing from object`)

		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	invoiceRequiresSuccessfulPaymentVal, ok := invoiceRequiresSuccessfulPaymentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_requires_successful_payment expected to be basetypes.BoolValue, was: %T`, invoiceRequiresSuccessfulPaymentAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	methodAttribute, ok := attributes["method"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`method is missing from object`)

		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	methodVal, ok := methodAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`method expected to be basetypes.StringValue, was: %T`, methodAttribute))
	}

	paidCreditsAttribute, ok := attributes["paid_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paid_credits is missing from object`)

		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	paidCreditsVal, ok := paidCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paid_credits expected to be basetypes.StringValue, was: %T`, paidCreditsAttribute))
	}

	startedAtAttribute, ok := attributes["started_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`started_at is missing from object`)

		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	startedAtVal, ok := startedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`started_at expected to be basetypes.StringValue, was: %T`, startedAtAttribute))
	}

	targetOngoingBalanceAttribute, ok := attributes["target_ongoing_balance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_ongoing_balance is missing from object`)

		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	targetOngoingBalanceVal, ok := targetOngoingBalanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_ongoing_balance expected to be basetypes.StringValue, was: %T`, targetOngoingBalanceAttribute))
	}

	thresholdCreditsAttribute, ok := attributes["threshold_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold_credits is missing from object`)

		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	thresholdCreditsVal, ok := thresholdCreditsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold_credits expected to be basetypes.StringValue, was: %T`, thresholdCreditsAttribute))
	}

	transactionMetadataAttribute, ok := attributes["transaction_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transaction_metadata is missing from object`)

		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	transactionMetadataVal, ok := transactionMetadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transaction_metadata expected to be basetypes.ListValue, was: %T`, transactionMetadataAttribute))
	}

	triggerAttribute, ok := attributes["trigger"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trigger is missing from object`)

		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	triggerVal, ok := triggerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trigger expected to be basetypes.StringValue, was: %T`, triggerAttribute))
	}

	if diags.HasError() {
		return NewRecurringTransactionRulesValueUnknown(), diags
	}

	return RecurringTransactionRulesValue{
		CreatedAt:                        createdAtVal,
		GrantedCredits:                   grantedCreditsVal,
		Interval:                         intervalVal,
		InvoiceRequiresSuccessfulPayment: invoiceRequiresSuccessfulPaymentVal,
		LagoId:                           lagoIdVal,
		Method:                           methodVal,
		PaidCredits:                      paidCreditsVal,
		StartedAt:                        startedAtVal,
		TargetOngoingBalance:             targetOngoingBalanceVal,
		ThresholdCredits:                 thresholdCreditsVal,
		TransactionMetadata:              transactionMetadataVal,
		Trigger:                          triggerVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewRecurringTransactionRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RecurringTransactionRulesValue {
	object, diags := NewRecurringTransactionRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRecurringTransactionRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RecurringTransactionRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRecurringTransactionRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRecurringTransactionRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRecurringTransactionRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRecurringTransactionRulesValueMust(RecurringTransactionRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RecurringTransactionRulesType) ValueType(ctx context.Context) attr.Value {
	return RecurringTransactionRulesValue{}
}

var _ basetypes.ObjectValuable = RecurringTransactionRulesValue{}

type RecurringTransactionRulesValue struct {
	CreatedAt                        basetypes.StringValue `tfsdk:"created_at"`
	GrantedCredits                   basetypes.StringValue `tfsdk:"granted_credits"`
	Interval                         basetypes.StringValue `tfsdk:"interval"`
	InvoiceRequiresSuccessfulPayment basetypes.BoolValue   `tfsdk:"invoice_requires_successful_payment"`
	LagoId                           basetypes.StringValue `tfsdk:"lago_id"`
	Method                           basetypes.StringValue `tfsdk:"method"`
	PaidCredits                      basetypes.StringValue `tfsdk:"paid_credits"`
	StartedAt                        basetypes.StringValue `tfsdk:"started_at"`
	TargetOngoingBalance             basetypes.StringValue `tfsdk:"target_ongoing_balance"`
	ThresholdCredits                 basetypes.StringValue `tfsdk:"threshold_credits"`
	TransactionMetadata              basetypes.ListValue   `tfsdk:"transaction_metadata"`
	Trigger                          basetypes.StringValue `tfsdk:"trigger"`
	state                            attr.ValueState
}

func (v RecurringTransactionRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["granted_credits"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interval"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_requires_successful_payment"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["method"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["paid_credits"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["started_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["target_ongoing_balance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["threshold_credits"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["transaction_metadata"] = basetypes.ListType{
		ElemType: TransactionMetadataValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["trigger"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.GrantedCredits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["granted_credits"] = val

		val, err = v.Interval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interval"] = val

		val, err = v.InvoiceRequiresSuccessfulPayment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_requires_successful_payment"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Method.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["method"] = val

		val, err = v.PaidCredits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["paid_credits"] = val

		val, err = v.StartedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["started_at"] = val

		val, err = v.TargetOngoingBalance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_ongoing_balance"] = val

		val, err = v.ThresholdCredits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["threshold_credits"] = val

		val, err = v.TransactionMetadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transaction_metadata"] = val

		val, err = v.Trigger.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trigger"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RecurringTransactionRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RecurringTransactionRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RecurringTransactionRulesValue) String() string {
	return "RecurringTransactionRulesValue"
}

func (v RecurringTransactionRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	transactionMetadata := types.ListValueMust(
		TransactionMetadataType{
			basetypes.ObjectType{
				AttrTypes: TransactionMetadataValue{}.AttributeTypes(ctx),
			},
		},
		v.TransactionMetadata.Elements(),
	)

	if v.TransactionMetadata.IsNull() {
		transactionMetadata = types.ListNull(
			TransactionMetadataType{
				basetypes.ObjectType{
					AttrTypes: TransactionMetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TransactionMetadata.IsUnknown() {
		transactionMetadata = types.ListUnknown(
			TransactionMetadataType{
				basetypes.ObjectType{
					AttrTypes: TransactionMetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"created_at":                          basetypes.StringType{},
		"granted_credits":                     basetypes.StringType{},
		"interval":                            basetypes.StringType{},
		"invoice_requires_successful_payment": basetypes.BoolType{},
		"lago_id":                             basetypes.StringType{},
		"method":                              basetypes.StringType{},
		"paid_credits":                        basetypes.StringType{},
		"started_at":                          basetypes.StringType{},
		"target_ongoing_balance":              basetypes.StringType{},
		"threshold_credits":                   basetypes.StringType{},
		"transaction_metadata": basetypes.ListType{
			ElemType: TransactionMetadataValue{}.Type(ctx),
		},
		"trigger": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at":                          v.CreatedAt,
			"granted_credits":                     v.GrantedCredits,
			"interval":                            v.Interval,
			"invoice_requires_successful_payment": v.InvoiceRequiresSuccessfulPayment,
			"lago_id":                             v.LagoId,
			"method":                              v.Method,
			"paid_credits":                        v.PaidCredits,
			"started_at":                          v.StartedAt,
			"target_ongoing_balance":              v.TargetOngoingBalance,
			"threshold_credits":                   v.ThresholdCredits,
			"transaction_metadata":                transactionMetadata,
			"trigger":                             v.Trigger,
		})

	return objVal, diags
}

func (v RecurringTransactionRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(RecurringTransactionRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.GrantedCredits.Equal(other.GrantedCredits) {
		return false
	}

	if !v.Interval.Equal(other.Interval) {
		return false
	}

	if !v.InvoiceRequiresSuccessfulPayment.Equal(other.InvoiceRequiresSuccessfulPayment) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Method.Equal(other.Method) {
		return false
	}

	if !v.PaidCredits.Equal(other.PaidCredits) {
		return false
	}

	if !v.StartedAt.Equal(other.StartedAt) {
		return false
	}

	if !v.TargetOngoingBalance.Equal(other.TargetOngoingBalance) {
		return false
	}

	if !v.ThresholdCredits.Equal(other.ThresholdCredits) {
		return false
	}

	if !v.TransactionMetadata.Equal(other.TransactionMetadata) {
		return false
	}

	if !v.Trigger.Equal(other.Trigger) {
		return false
	}

	return true
}

func (v RecurringTransactionRulesValue) Type(ctx context.Context) attr.Type {
	return RecurringTransactionRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RecurringTransactionRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at":                          basetypes.StringType{},
		"granted_credits":                     basetypes.StringType{},
		"interval":                            basetypes.StringType{},
		"invoice_requires_successful_payment": basetypes.BoolType{},
		"lago_id":                             basetypes.StringType{},
		"method":                              basetypes.StringType{},
		"paid_credits":                        basetypes.StringType{},
		"started_at":                          basetypes.StringType{},
		"target_ongoing_balance":              basetypes.StringType{},
		"threshold_credits":                   basetypes.StringType{},
		"transaction_metadata": basetypes.ListType{
			ElemType: TransactionMetadataValue{}.Type(ctx),
		},
		"trigger": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TransactionMetadataType{}

type TransactionMetadataType struct {
	basetypes.ObjectType
}

func (t TransactionMetadataType) Equal(o attr.Type) bool {
	other, ok := o.(TransactionMetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TransactionMetadataType) String() string {
	return "TransactionMetadataType"
}

func (t TransactionMetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TransactionMetadataValue{
		Key:   keyVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTransactionMetadataValueNull() TransactionMetadataValue {
	return TransactionMetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewTransactionMetadataValueUnknown() TransactionMetadataValue {
	return TransactionMetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTransactionMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TransactionMetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TransactionMetadataValue Attribute Value",
				"While creating a TransactionMetadataValue value, a missing attribute value was detected. "+
					"A TransactionMetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TransactionMetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TransactionMetadataValue Attribute Type",
				"While creating a TransactionMetadataValue value, an invalid attribute value was detected. "+
					"A TransactionMetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TransactionMetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TransactionMetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TransactionMetadataValue Attribute Value",
				"While creating a TransactionMetadataValue value, an extra attribute value was detected. "+
					"A TransactionMetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TransactionMetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTransactionMetadataValueUnknown(), diags
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTransactionMetadataValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTransactionMetadataValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTransactionMetadataValueUnknown(), diags
	}

	return TransactionMetadataValue{
		Key:   keyVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTransactionMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TransactionMetadataValue {
	object, diags := NewTransactionMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTransactionMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TransactionMetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTransactionMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTransactionMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTransactionMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTransactionMetadataValueMust(TransactionMetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TransactionMetadataType) ValueType(ctx context.Context) attr.Value {
	return TransactionMetadataValue{}
}

var _ basetypes.ObjectValuable = TransactionMetadataValue{}

type TransactionMetadataValue struct {
	Key   basetypes.StringValue `tfsdk:"key"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v TransactionMetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TransactionMetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TransactionMetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TransactionMetadataValue) String() string {
	return "TransactionMetadataValue"
}

func (v TransactionMetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"key":   basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"key":   v.Key,
			"value": v.Value,
		})

	return objVal, diags
}

func (v TransactionMetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(TransactionMetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TransactionMetadataValue) Type(ctx context.Context) attr.Type {
	return TransactionMetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TransactionMetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"key":   basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TransactionMetadataType{}

type TransactionMetadataType struct {
	basetypes.ObjectType
}

func (t TransactionMetadataType) Equal(o attr.Type) bool {
	other, ok := o.(TransactionMetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TransactionMetadataType) String() string {
	return "TransactionMetadataType"
}

func (t TransactionMetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TransactionMetadataValue{
		Key:   keyVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTransactionMetadataValueNull() TransactionMetadataValue {
	return TransactionMetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewTransactionMetadataValueUnknown() TransactionMetadataValue {
	return TransactionMetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTransactionMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TransactionMetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TransactionMetadataValue Attribute Value",
				"While creating a TransactionMetadataValue value, a missing attribute value was detected. "+
					"A TransactionMetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TransactionMetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TransactionMetadataValue Attribute Type",
				"While creating a TransactionMetadataValue value, an invalid attribute value was detected. "+
					"A TransactionMetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TransactionMetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TransactionMetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TransactionMetadataValue Attribute Value",
				"While creating a TransactionMetadataValue value, an extra attribute value was detected. "+
					"A TransactionMetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TransactionMetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTransactionMetadataValueUnknown(), diags
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewTransactionMetadataValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTransactionMetadataValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTransactionMetadataValueUnknown(), diags
	}

	return TransactionMetadataValue{
		Key:   keyVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTransactionMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TransactionMetadataValue {
	object, diags := NewTransactionMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTransactionMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TransactionMetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTransactionMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTransactionMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTransactionMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTransactionMetadataValueMust(TransactionMetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TransactionMetadataType) ValueType(ctx context.Context) attr.Value {
	return TransactionMetadataValue{}
}

var _ basetypes.ObjectValuable = TransactionMetadataValue{}

type TransactionMetadataValue struct {
	Key   basetypes.StringValue `tfsdk:"key"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v TransactionMetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TransactionMetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TransactionMetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TransactionMetadataValue) String() string {
	return "TransactionMetadataValue"
}

func (v TransactionMetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"key":   basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"key":   v.Key,
			"value": v.Value,
		})

	return objVal, diags
}

func (v TransactionMetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(TransactionMetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TransactionMetadataValue) Type(ctx context.Context) attr.Type {
	return TransactionMetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TransactionMetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"key":   basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}
