// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_payments

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func PaymentsResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"external_customer_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Unique identifier assigned to the customer in your application.",
				MarkdownDescription: "Unique identifier assigned to the customer in your application.",
			},
			"lago_invoice_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Unique identifier assigned to the invoice within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the invoice's record within the Lago system.",
				MarkdownDescription: "Unique identifier assigned to the invoice within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the invoice's record within the Lago system.",
			},
			"meta": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"current_page": schema.Int64Attribute{
						Computed:            true,
						Description:         "Current page.",
						MarkdownDescription: "Current page.",
					},
					"next_page": schema.Int64Attribute{
						Computed:            true,
						Description:         "Next page.",
						MarkdownDescription: "Next page.",
					},
					"prev_page": schema.Int64Attribute{
						Computed:            true,
						Description:         "Previous page.",
						MarkdownDescription: "Previous page.",
					},
					"total_count": schema.Int64Attribute{
						Computed:            true,
						Description:         "Total number of records.",
						MarkdownDescription: "Total number of records.",
					},
					"total_pages": schema.Int64Attribute{
						Computed:            true,
						Description:         "Total number of pages.",
						MarkdownDescription: "Total number of pages.",
					},
				},
				CustomType: MetaType{
					ObjectType: types.ObjectType{
						AttrTypes: MetaValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"page": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Page number.",
				MarkdownDescription: "Page number.",
			},
			"payment": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"amount_cents": schema.Int64Attribute{
						Required:            true,
						Description:         "The payment amount in cents",
						MarkdownDescription: "The payment amount in cents",
					},
					"amount_currency": schema.StringAttribute{
						Computed:            true,
						Description:         "The currency of the payment amount.",
						MarkdownDescription: "The currency of the payment amount.",
					},
					"created_at": schema.StringAttribute{
						Computed:            true,
						Description:         "Timestamp when the payment was created.",
						MarkdownDescription: "Timestamp when the payment was created.",
					},
					"external_payment_id": schema.StringAttribute{
						Computed:            true,
						Description:         "External identifier for the payment (if applicable).",
						MarkdownDescription: "External identifier for the payment (if applicable).",
					},
					"invoice_id": schema.StringAttribute{
						Required:            true,
						Description:         "Unique identifier assigned to the invoice",
						MarkdownDescription: "Unique identifier assigned to the invoice",
					},
					"invoice_ids": schema.ListAttribute{
						ElementType:         types.StringType,
						Computed:            true,
						Description:         "List of invoice IDs associated with the payment.",
						MarkdownDescription: "List of invoice IDs associated with the payment.",
					},
					"lago_id": schema.StringAttribute{
						Computed:            true,
						Description:         "The unique identifier of the payment, created by Lago.",
						MarkdownDescription: "The unique identifier of the payment, created by Lago.",
					},
					"paid_at": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The date the payment was made",
						MarkdownDescription: "The date the payment was made",
					},
					"payment_status": schema.StringAttribute{
						Computed:            true,
						Description:         "The current status of the payment.",
						MarkdownDescription: "The current status of the payment.",
					},
					"reference": schema.StringAttribute{
						Required:            true,
						Description:         "Reference for the payment",
						MarkdownDescription: "Reference for the payment",
					},
					"type": schema.StringAttribute{
						Computed:            true,
						Description:         "The type of payment.",
						MarkdownDescription: "The type of payment.",
					},
				},
				CustomType: PaymentType{
					ObjectType: types.ObjectType{
						AttrTypes: PaymentValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"payments": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"amount_cents": schema.Int64Attribute{
							Computed:            true,
							Description:         "The amount of the payment in cents.",
							MarkdownDescription: "The amount of the payment in cents.",
						},
						"amount_currency": schema.StringAttribute{
							Computed:            true,
							Description:         "The currency of the payment amount.",
							MarkdownDescription: "The currency of the payment amount.",
						},
						"created_at": schema.StringAttribute{
							Computed:            true,
							Description:         "Timestamp when the payment was created.",
							MarkdownDescription: "Timestamp when the payment was created.",
						},
						"external_payment_id": schema.StringAttribute{
							Computed:            true,
							Description:         "External identifier for the payment (if applicable).",
							MarkdownDescription: "External identifier for the payment (if applicable).",
						},
						"invoice_ids": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "List of invoice IDs associated with the payment.",
							MarkdownDescription: "List of invoice IDs associated with the payment.",
						},
						"lago_id": schema.StringAttribute{
							Computed:            true,
							Description:         "The unique identifier of the payment, created by Lago.",
							MarkdownDescription: "The unique identifier of the payment, created by Lago.",
						},
						"payment_status": schema.StringAttribute{
							Computed:            true,
							Description:         "The current status of the payment.",
							MarkdownDescription: "The current status of the payment.",
						},
						"reference": schema.StringAttribute{
							Computed:            true,
							Description:         "Reference for the payment.",
							MarkdownDescription: "Reference for the payment.",
						},
						"type": schema.StringAttribute{
							Computed:            true,
							Description:         "The type of payment.",
							MarkdownDescription: "The type of payment.",
						},
					},
					CustomType: PaymentsType{
						ObjectType: types.ObjectType{
							AttrTypes: PaymentsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"per_page": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of records per page.",
				MarkdownDescription: "Number of records per page.",
			},
		},
	}
}

type PaymentsModel struct {
	ExternalCustomerId types.String `tfsdk:"external_customer_id"`
	LagoInvoiceId      types.String `tfsdk:"lago_invoice_id"`
	Meta               MetaValue    `tfsdk:"meta"`
	Page               types.Int64  `tfsdk:"page"`
	Payment            PaymentValue `tfsdk:"payment"`
	Payments           types.List   `tfsdk:"payments"`
	PerPage            types.Int64  `tfsdk:"per_page"`
}

var _ basetypes.ObjectTypable = MetaType{}

type MetaType struct {
	basetypes.ObjectType
}

func (t MetaType) Equal(o attr.Type) bool {
	other, ok := o.(MetaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetaType) String() string {
	return "MetaType"
}

func (t MetaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	currentPageAttribute, ok := attributes["current_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_page is missing from object`)

		return nil, diags
	}

	currentPageVal, ok := currentPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_page expected to be basetypes.Int64Value, was: %T`, currentPageAttribute))
	}

	nextPageAttribute, ok := attributes["next_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_page is missing from object`)

		return nil, diags
	}

	nextPageVal, ok := nextPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_page expected to be basetypes.Int64Value, was: %T`, nextPageAttribute))
	}

	prevPageAttribute, ok := attributes["prev_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prev_page is missing from object`)

		return nil, diags
	}

	prevPageVal, ok := prevPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prev_page expected to be basetypes.Int64Value, was: %T`, prevPageAttribute))
	}

	totalCountAttribute, ok := attributes["total_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_count is missing from object`)

		return nil, diags
	}

	totalCountVal, ok := totalCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_count expected to be basetypes.Int64Value, was: %T`, totalCountAttribute))
	}

	totalPagesAttribute, ok := attributes["total_pages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_pages is missing from object`)

		return nil, diags
	}

	totalPagesVal, ok := totalPagesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_pages expected to be basetypes.Int64Value, was: %T`, totalPagesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetaValue{
		CurrentPage: currentPageVal,
		NextPage:    nextPageVal,
		PrevPage:    prevPageVal,
		TotalCount:  totalCountVal,
		TotalPages:  totalPagesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetaValueNull() MetaValue {
	return MetaValue{
		state: attr.ValueStateNull,
	}
}

func NewMetaValueUnknown() MetaValue {
	return MetaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetaValue Attribute Value",
				"While creating a MetaValue value, a missing attribute value was detected. "+
					"A MetaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetaValue Attribute Type",
				"While creating a MetaValue value, an invalid attribute value was detected. "+
					"A MetaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetaValue Attribute Value",
				"While creating a MetaValue value, an extra attribute value was detected. "+
					"A MetaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	currentPageAttribute, ok := attributes["current_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_page is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	currentPageVal, ok := currentPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_page expected to be basetypes.Int64Value, was: %T`, currentPageAttribute))
	}

	nextPageAttribute, ok := attributes["next_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_page is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	nextPageVal, ok := nextPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_page expected to be basetypes.Int64Value, was: %T`, nextPageAttribute))
	}

	prevPageAttribute, ok := attributes["prev_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prev_page is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	prevPageVal, ok := prevPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prev_page expected to be basetypes.Int64Value, was: %T`, prevPageAttribute))
	}

	totalCountAttribute, ok := attributes["total_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_count is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	totalCountVal, ok := totalCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_count expected to be basetypes.Int64Value, was: %T`, totalCountAttribute))
	}

	totalPagesAttribute, ok := attributes["total_pages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_pages is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	totalPagesVal, ok := totalPagesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_pages expected to be basetypes.Int64Value, was: %T`, totalPagesAttribute))
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	return MetaValue{
		CurrentPage: currentPageVal,
		NextPage:    nextPageVal,
		PrevPage:    prevPageVal,
		TotalCount:  totalCountVal,
		TotalPages:  totalPagesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetaValue {
	object, diags := NewMetaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetaValueMust(MetaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetaType) ValueType(ctx context.Context) attr.Value {
	return MetaValue{}
}

var _ basetypes.ObjectValuable = MetaValue{}

type MetaValue struct {
	CurrentPage basetypes.Int64Value `tfsdk:"current_page"`
	NextPage    basetypes.Int64Value `tfsdk:"next_page"`
	PrevPage    basetypes.Int64Value `tfsdk:"prev_page"`
	TotalCount  basetypes.Int64Value `tfsdk:"total_count"`
	TotalPages  basetypes.Int64Value `tfsdk:"total_pages"`
	state       attr.ValueState
}

func (v MetaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["current_page"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["next_page"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prev_page"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_pages"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CurrentPage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_page"] = val

		val, err = v.NextPage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_page"] = val

		val, err = v.PrevPage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prev_page"] = val

		val, err = v.TotalCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_count"] = val

		val, err = v.TotalPages.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_pages"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetaValue) String() string {
	return "MetaValue"
}

func (v MetaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"current_page": basetypes.Int64Type{},
		"next_page":    basetypes.Int64Type{},
		"prev_page":    basetypes.Int64Type{},
		"total_count":  basetypes.Int64Type{},
		"total_pages":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"current_page": v.CurrentPage,
			"next_page":    v.NextPage,
			"prev_page":    v.PrevPage,
			"total_count":  v.TotalCount,
			"total_pages":  v.TotalPages,
		})

	return objVal, diags
}

func (v MetaValue) Equal(o attr.Value) bool {
	other, ok := o.(MetaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CurrentPage.Equal(other.CurrentPage) {
		return false
	}

	if !v.NextPage.Equal(other.NextPage) {
		return false
	}

	if !v.PrevPage.Equal(other.PrevPage) {
		return false
	}

	if !v.TotalCount.Equal(other.TotalCount) {
		return false
	}

	if !v.TotalPages.Equal(other.TotalPages) {
		return false
	}

	return true
}

func (v MetaValue) Type(ctx context.Context) attr.Type {
	return MetaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"current_page": basetypes.Int64Type{},
		"next_page":    basetypes.Int64Type{},
		"prev_page":    basetypes.Int64Type{},
		"total_count":  basetypes.Int64Type{},
		"total_pages":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PaymentType{}

type PaymentType struct {
	basetypes.ObjectType
}

func (t PaymentType) Equal(o attr.Type) bool {
	other, ok := o.(PaymentType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PaymentType) String() string {
	return "PaymentType"
}

func (t PaymentType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return nil, diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	externalPaymentIdAttribute, ok := attributes["external_payment_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_payment_id is missing from object`)

		return nil, diags
	}

	externalPaymentIdVal, ok := externalPaymentIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_payment_id expected to be basetypes.StringValue, was: %T`, externalPaymentIdAttribute))
	}

	invoiceIdAttribute, ok := attributes["invoice_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_id is missing from object`)

		return nil, diags
	}

	invoiceIdVal, ok := invoiceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_id expected to be basetypes.StringValue, was: %T`, invoiceIdAttribute))
	}

	invoiceIdsAttribute, ok := attributes["invoice_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_ids is missing from object`)

		return nil, diags
	}

	invoiceIdsVal, ok := invoiceIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_ids expected to be basetypes.ListValue, was: %T`, invoiceIdsAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	paidAtAttribute, ok := attributes["paid_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paid_at is missing from object`)

		return nil, diags
	}

	paidAtVal, ok := paidAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paid_at expected to be basetypes.StringValue, was: %T`, paidAtAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return nil, diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	referenceAttribute, ok := attributes["reference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reference is missing from object`)

		return nil, diags
	}

	referenceVal, ok := referenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reference expected to be basetypes.StringValue, was: %T`, referenceAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PaymentValue{
		AmountCents:       amountCentsVal,
		AmountCurrency:    amountCurrencyVal,
		CreatedAt:         createdAtVal,
		ExternalPaymentId: externalPaymentIdVal,
		InvoiceId:         invoiceIdVal,
		InvoiceIds:        invoiceIdsVal,
		LagoId:            lagoIdVal,
		PaidAt:            paidAtVal,
		PaymentStatus:     paymentStatusVal,
		Reference:         referenceVal,
		PaymentType:       typeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPaymentValueNull() PaymentValue {
	return PaymentValue{
		state: attr.ValueStateNull,
	}
}

func NewPaymentValueUnknown() PaymentValue {
	return PaymentValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPaymentValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PaymentValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PaymentValue Attribute Value",
				"While creating a PaymentValue value, a missing attribute value was detected. "+
					"A PaymentValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PaymentValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PaymentValue Attribute Type",
				"While creating a PaymentValue value, an invalid attribute value was detected. "+
					"A PaymentValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PaymentValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PaymentValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PaymentValue Attribute Value",
				"While creating a PaymentValue value, an extra attribute value was detected. "+
					"A PaymentValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PaymentValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPaymentValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewPaymentValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return NewPaymentValueUnknown(), diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewPaymentValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	externalPaymentIdAttribute, ok := attributes["external_payment_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_payment_id is missing from object`)

		return NewPaymentValueUnknown(), diags
	}

	externalPaymentIdVal, ok := externalPaymentIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_payment_id expected to be basetypes.StringValue, was: %T`, externalPaymentIdAttribute))
	}

	invoiceIdAttribute, ok := attributes["invoice_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_id is missing from object`)

		return NewPaymentValueUnknown(), diags
	}

	invoiceIdVal, ok := invoiceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_id expected to be basetypes.StringValue, was: %T`, invoiceIdAttribute))
	}

	invoiceIdsAttribute, ok := attributes["invoice_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_ids is missing from object`)

		return NewPaymentValueUnknown(), diags
	}

	invoiceIdsVal, ok := invoiceIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_ids expected to be basetypes.ListValue, was: %T`, invoiceIdsAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewPaymentValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	paidAtAttribute, ok := attributes["paid_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paid_at is missing from object`)

		return NewPaymentValueUnknown(), diags
	}

	paidAtVal, ok := paidAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paid_at expected to be basetypes.StringValue, was: %T`, paidAtAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return NewPaymentValueUnknown(), diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	referenceAttribute, ok := attributes["reference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reference is missing from object`)

		return NewPaymentValueUnknown(), diags
	}

	referenceVal, ok := referenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reference expected to be basetypes.StringValue, was: %T`, referenceAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewPaymentValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewPaymentValueUnknown(), diags
	}

	return PaymentValue{
		AmountCents:       amountCentsVal,
		AmountCurrency:    amountCurrencyVal,
		CreatedAt:         createdAtVal,
		ExternalPaymentId: externalPaymentIdVal,
		InvoiceId:         invoiceIdVal,
		InvoiceIds:        invoiceIdsVal,
		LagoId:            lagoIdVal,
		PaidAt:            paidAtVal,
		PaymentStatus:     paymentStatusVal,
		Reference:         referenceVal,
		PaymentType:       typeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPaymentValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PaymentValue {
	object, diags := NewPaymentValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPaymentValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PaymentType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPaymentValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPaymentValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPaymentValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPaymentValueMust(PaymentValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PaymentType) ValueType(ctx context.Context) attr.Value {
	return PaymentValue{}
}

var _ basetypes.ObjectValuable = PaymentValue{}

type PaymentValue struct {
	AmountCents       basetypes.Int64Value  `tfsdk:"amount_cents"`
	AmountCurrency    basetypes.StringValue `tfsdk:"amount_currency"`
	CreatedAt         basetypes.StringValue `tfsdk:"created_at"`
	ExternalPaymentId basetypes.StringValue `tfsdk:"external_payment_id"`
	InvoiceId         basetypes.StringValue `tfsdk:"invoice_id"`
	InvoiceIds        basetypes.ListValue   `tfsdk:"invoice_ids"`
	LagoId            basetypes.StringValue `tfsdk:"lago_id"`
	PaidAt            basetypes.StringValue `tfsdk:"paid_at"`
	PaymentStatus     basetypes.StringValue `tfsdk:"payment_status"`
	Reference         basetypes.StringValue `tfsdk:"reference"`
	PaymentType       basetypes.StringValue `tfsdk:"type"`
	state             attr.ValueState
}

func (v PaymentValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["amount_currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_payment_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["paid_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["payment_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reference"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.AmountCurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_currency"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.ExternalPaymentId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_payment_id"] = val

		val, err = v.InvoiceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_id"] = val

		val, err = v.InvoiceIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_ids"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.PaidAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["paid_at"] = val

		val, err = v.PaymentStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_status"] = val

		val, err = v.Reference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reference"] = val

		val, err = v.PaymentType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PaymentValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PaymentValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PaymentValue) String() string {
	return "PaymentValue"
}

func (v PaymentValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var invoiceIdsVal basetypes.ListValue
	switch {
	case v.InvoiceIds.IsUnknown():
		invoiceIdsVal = types.ListUnknown(types.StringType)
	case v.InvoiceIds.IsNull():
		invoiceIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		invoiceIdsVal, d = types.ListValue(types.StringType, v.InvoiceIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount_cents":        basetypes.Int64Type{},
			"amount_currency":     basetypes.StringType{},
			"created_at":          basetypes.StringType{},
			"external_payment_id": basetypes.StringType{},
			"invoice_id":          basetypes.StringType{},
			"invoice_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"lago_id":        basetypes.StringType{},
			"paid_at":        basetypes.StringType{},
			"payment_status": basetypes.StringType{},
			"reference":      basetypes.StringType{},
			"type":           basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":        basetypes.Int64Type{},
		"amount_currency":     basetypes.StringType{},
		"created_at":          basetypes.StringType{},
		"external_payment_id": basetypes.StringType{},
		"invoice_id":          basetypes.StringType{},
		"invoice_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"lago_id":        basetypes.StringType{},
		"paid_at":        basetypes.StringType{},
		"payment_status": basetypes.StringType{},
		"reference":      basetypes.StringType{},
		"type":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":        v.AmountCents,
			"amount_currency":     v.AmountCurrency,
			"created_at":          v.CreatedAt,
			"external_payment_id": v.ExternalPaymentId,
			"invoice_id":          v.InvoiceId,
			"invoice_ids":         invoiceIdsVal,
			"lago_id":             v.LagoId,
			"paid_at":             v.PaidAt,
			"payment_status":      v.PaymentStatus,
			"reference":           v.Reference,
			"type":                v.PaymentType,
		})

	return objVal, diags
}

func (v PaymentValue) Equal(o attr.Value) bool {
	other, ok := o.(PaymentValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.AmountCurrency.Equal(other.AmountCurrency) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.ExternalPaymentId.Equal(other.ExternalPaymentId) {
		return false
	}

	if !v.InvoiceId.Equal(other.InvoiceId) {
		return false
	}

	if !v.InvoiceIds.Equal(other.InvoiceIds) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.PaidAt.Equal(other.PaidAt) {
		return false
	}

	if !v.PaymentStatus.Equal(other.PaymentStatus) {
		return false
	}

	if !v.Reference.Equal(other.Reference) {
		return false
	}

	if !v.PaymentType.Equal(other.PaymentType) {
		return false
	}

	return true
}

func (v PaymentValue) Type(ctx context.Context) attr.Type {
	return PaymentType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PaymentValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":        basetypes.Int64Type{},
		"amount_currency":     basetypes.StringType{},
		"created_at":          basetypes.StringType{},
		"external_payment_id": basetypes.StringType{},
		"invoice_id":          basetypes.StringType{},
		"invoice_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"lago_id":        basetypes.StringType{},
		"paid_at":        basetypes.StringType{},
		"payment_status": basetypes.StringType{},
		"reference":      basetypes.StringType{},
		"type":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PaymentsType{}

type PaymentsType struct {
	basetypes.ObjectType
}

func (t PaymentsType) Equal(o attr.Type) bool {
	other, ok := o.(PaymentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PaymentsType) String() string {
	return "PaymentsType"
}

func (t PaymentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return nil, diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	externalPaymentIdAttribute, ok := attributes["external_payment_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_payment_id is missing from object`)

		return nil, diags
	}

	externalPaymentIdVal, ok := externalPaymentIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_payment_id expected to be basetypes.StringValue, was: %T`, externalPaymentIdAttribute))
	}

	invoiceIdsAttribute, ok := attributes["invoice_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_ids is missing from object`)

		return nil, diags
	}

	invoiceIdsVal, ok := invoiceIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_ids expected to be basetypes.ListValue, was: %T`, invoiceIdsAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return nil, diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	referenceAttribute, ok := attributes["reference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reference is missing from object`)

		return nil, diags
	}

	referenceVal, ok := referenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reference expected to be basetypes.StringValue, was: %T`, referenceAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PaymentsValue{
		AmountCents:       amountCentsVal,
		AmountCurrency:    amountCurrencyVal,
		CreatedAt:         createdAtVal,
		ExternalPaymentId: externalPaymentIdVal,
		InvoiceIds:        invoiceIdsVal,
		LagoId:            lagoIdVal,
		PaymentStatus:     paymentStatusVal,
		Reference:         referenceVal,
		PaymentsType:      typeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPaymentsValueNull() PaymentsValue {
	return PaymentsValue{
		state: attr.ValueStateNull,
	}
}

func NewPaymentsValueUnknown() PaymentsValue {
	return PaymentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPaymentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PaymentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PaymentsValue Attribute Value",
				"While creating a PaymentsValue value, a missing attribute value was detected. "+
					"A PaymentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PaymentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PaymentsValue Attribute Type",
				"While creating a PaymentsValue value, an invalid attribute value was detected. "+
					"A PaymentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PaymentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PaymentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PaymentsValue Attribute Value",
				"While creating a PaymentsValue value, an extra attribute value was detected. "+
					"A PaymentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PaymentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPaymentsValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewPaymentsValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return NewPaymentsValueUnknown(), diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewPaymentsValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	externalPaymentIdAttribute, ok := attributes["external_payment_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_payment_id is missing from object`)

		return NewPaymentsValueUnknown(), diags
	}

	externalPaymentIdVal, ok := externalPaymentIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_payment_id expected to be basetypes.StringValue, was: %T`, externalPaymentIdAttribute))
	}

	invoiceIdsAttribute, ok := attributes["invoice_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_ids is missing from object`)

		return NewPaymentsValueUnknown(), diags
	}

	invoiceIdsVal, ok := invoiceIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_ids expected to be basetypes.ListValue, was: %T`, invoiceIdsAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewPaymentsValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return NewPaymentsValueUnknown(), diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	referenceAttribute, ok := attributes["reference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reference is missing from object`)

		return NewPaymentsValueUnknown(), diags
	}

	referenceVal, ok := referenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reference expected to be basetypes.StringValue, was: %T`, referenceAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewPaymentsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewPaymentsValueUnknown(), diags
	}

	return PaymentsValue{
		AmountCents:       amountCentsVal,
		AmountCurrency:    amountCurrencyVal,
		CreatedAt:         createdAtVal,
		ExternalPaymentId: externalPaymentIdVal,
		InvoiceIds:        invoiceIdsVal,
		LagoId:            lagoIdVal,
		PaymentStatus:     paymentStatusVal,
		Reference:         referenceVal,
		PaymentsType:      typeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPaymentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PaymentsValue {
	object, diags := NewPaymentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPaymentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PaymentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPaymentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPaymentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPaymentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPaymentsValueMust(PaymentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PaymentsType) ValueType(ctx context.Context) attr.Value {
	return PaymentsValue{}
}

var _ basetypes.ObjectValuable = PaymentsValue{}

type PaymentsValue struct {
	AmountCents       basetypes.Int64Value  `tfsdk:"amount_cents"`
	AmountCurrency    basetypes.StringValue `tfsdk:"amount_currency"`
	CreatedAt         basetypes.StringValue `tfsdk:"created_at"`
	ExternalPaymentId basetypes.StringValue `tfsdk:"external_payment_id"`
	InvoiceIds        basetypes.ListValue   `tfsdk:"invoice_ids"`
	LagoId            basetypes.StringValue `tfsdk:"lago_id"`
	PaymentStatus     basetypes.StringValue `tfsdk:"payment_status"`
	Reference         basetypes.StringValue `tfsdk:"reference"`
	PaymentsType      basetypes.StringValue `tfsdk:"type"`
	state             attr.ValueState
}

func (v PaymentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["amount_currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_payment_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["payment_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reference"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.AmountCurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_currency"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.ExternalPaymentId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_payment_id"] = val

		val, err = v.InvoiceIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_ids"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.PaymentStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_status"] = val

		val, err = v.Reference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reference"] = val

		val, err = v.PaymentsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PaymentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PaymentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PaymentsValue) String() string {
	return "PaymentsValue"
}

func (v PaymentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var invoiceIdsVal basetypes.ListValue
	switch {
	case v.InvoiceIds.IsUnknown():
		invoiceIdsVal = types.ListUnknown(types.StringType)
	case v.InvoiceIds.IsNull():
		invoiceIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		invoiceIdsVal, d = types.ListValue(types.StringType, v.InvoiceIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount_cents":        basetypes.Int64Type{},
			"amount_currency":     basetypes.StringType{},
			"created_at":          basetypes.StringType{},
			"external_payment_id": basetypes.StringType{},
			"invoice_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"lago_id":        basetypes.StringType{},
			"payment_status": basetypes.StringType{},
			"reference":      basetypes.StringType{},
			"type":           basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":        basetypes.Int64Type{},
		"amount_currency":     basetypes.StringType{},
		"created_at":          basetypes.StringType{},
		"external_payment_id": basetypes.StringType{},
		"invoice_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"lago_id":        basetypes.StringType{},
		"payment_status": basetypes.StringType{},
		"reference":      basetypes.StringType{},
		"type":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":        v.AmountCents,
			"amount_currency":     v.AmountCurrency,
			"created_at":          v.CreatedAt,
			"external_payment_id": v.ExternalPaymentId,
			"invoice_ids":         invoiceIdsVal,
			"lago_id":             v.LagoId,
			"payment_status":      v.PaymentStatus,
			"reference":           v.Reference,
			"type":                v.PaymentsType,
		})

	return objVal, diags
}

func (v PaymentsValue) Equal(o attr.Value) bool {
	other, ok := o.(PaymentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.AmountCurrency.Equal(other.AmountCurrency) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.ExternalPaymentId.Equal(other.ExternalPaymentId) {
		return false
	}

	if !v.InvoiceIds.Equal(other.InvoiceIds) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.PaymentStatus.Equal(other.PaymentStatus) {
		return false
	}

	if !v.Reference.Equal(other.Reference) {
		return false
	}

	if !v.PaymentsType.Equal(other.PaymentsType) {
		return false
	}

	return true
}

func (v PaymentsValue) Type(ctx context.Context) attr.Type {
	return PaymentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PaymentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":        basetypes.Int64Type{},
		"amount_currency":     basetypes.StringType{},
		"created_at":          basetypes.StringType{},
		"external_payment_id": basetypes.StringType{},
		"invoice_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"lago_id":        basetypes.StringType{},
		"payment_status": basetypes.StringType{},
		"reference":      basetypes.StringType{},
		"type":           basetypes.StringType{},
	}
}
