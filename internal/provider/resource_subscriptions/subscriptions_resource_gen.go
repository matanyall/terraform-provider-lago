// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_subscriptions

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func SubscriptionsResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"external_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "External ID of the existing subscription",
				MarkdownDescription: "External ID of the existing subscription",
			},
			"lifetime_usage": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"current_usage_amount_cents": schema.Int64Attribute{
						Computed:            true,
						Description:         "The current usage amount in cents for the subscription on the current billing period.",
						MarkdownDescription: "The current usage amount in cents for the subscription on the current billing period.",
					},
					"external_historical_usage_amount_cents": schema.Int64Attribute{
						Computed:            true,
						Description:         "The historical usage amount in cents for the subscription (provided by your own application).",
						MarkdownDescription: "The historical usage amount in cents for the subscription (provided by your own application).",
					},
					"external_subscription_id": schema.StringAttribute{
						Computed:            true,
						Description:         "The subscription external unique identifier (provided by your own application).",
						MarkdownDescription: "The subscription external unique identifier (provided by your own application).",
					},
					"from_datetime": schema.StringAttribute{
						Computed:            true,
						Description:         "The recording start date and time of the subscription lifetime usage. The date and time must be in ISO 8601 format.",
						MarkdownDescription: "The recording start date and time of the subscription lifetime usage. The date and time must be in ISO 8601 format.",
					},
					"invoiced_usage_amount_cents": schema.Int64Attribute{
						Computed:            true,
						Description:         "The total invoiced usage amount in cents for the subscription.",
						MarkdownDescription: "The total invoiced usage amount in cents for the subscription.",
					},
					"lago_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the lifetime usage record within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the lifetime usage record within the Lago system",
						MarkdownDescription: "Unique identifier assigned to the lifetime usage record within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the lifetime usage record within the Lago system",
					},
					"lago_subscription_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the subscription record within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the subscription record within the Lago system",
						MarkdownDescription: "Unique identifier assigned to the subscription record within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the subscription record within the Lago system",
					},
					"to_datetime": schema.StringAttribute{
						Computed:            true,
						Description:         "The recording end date and time of the subscription lifetime usage. The date and time must be in ISO 8601 format.",
						MarkdownDescription: "The recording end date and time of the subscription lifetime usage. The date and time must be in ISO 8601 format.",
					},
					"usage_thresholds": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "The usage threshold amount in cents.",
									MarkdownDescription: "The usage threshold amount in cents.",
								},
								"completion_ratio": schema.NumberAttribute{
									Computed:            true,
									Description:         "The completion ratio of the usage threshold.",
									MarkdownDescription: "The completion ratio of the usage threshold.",
								},
								"reached_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The date and time when the usage threshold was reached. The date and time must be in ISO 8601 format.",
									MarkdownDescription: "The date and time when the usage threshold was reached. The date and time must be in ISO 8601 format.",
								},
							},
							CustomType: UsageThresholdsType{
								ObjectType: types.ObjectType{
									AttrTypes: UsageThresholdsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "Array of usage thresholds attached to the subscription's plan.",
						MarkdownDescription: "Array of usage thresholds attached to the subscription's plan.",
					},
				},
				CustomType: LifetimeUsageType{
					ObjectType: types.ObjectType{
						AttrTypes: LifetimeUsageValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"subscription": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"billing_time": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The billing time for the subscription, which can be set as either `anniversary` or `calendar`. If not explicitly provided, it will default to `calendar`. The billing time determines the timing of recurring billing cycles for the subscription. By specifying `anniversary`, the billing cycle will be based on the specific date the subscription started (billed fully), while `calendar` sets the billing cycle at the first day of the week/month/year (billed with proration).",
						MarkdownDescription: "The billing time for the subscription, which can be set as either `anniversary` or `calendar`. If not explicitly provided, it will default to `calendar`. The billing time determines the timing of recurring billing cycles for the subscription. By specifying `anniversary`, the billing cycle will be based on the specific date the subscription started (billed fully), while `calendar` sets the billing cycle at the first day of the week/month/year (billed with proration).",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"calendar",
								"anniversary",
							),
						},
					},
					"ending_at": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The effective end date of the subscription. If this field is set to null, the subscription will automatically renew. This date should be provided in ISO 8601 datetime format, and use Coordinated Universal Time (UTC).",
						MarkdownDescription: "The effective end date of the subscription. If this field is set to null, the subscription will automatically renew. This date should be provided in ISO 8601 datetime format, and use Coordinated Universal Time (UTC).",
					},
					"external_customer_id": schema.StringAttribute{
						Required:            true,
						Description:         "The customer external unique identifier (provided by your own application)",
						MarkdownDescription: "The customer external unique identifier (provided by your own application)",
					},
					"external_id": schema.StringAttribute{
						Required:            true,
						Description:         "The unique external identifier for the subscription. This identifier serves as an idempotency key, ensuring that each subscription is unique.",
						MarkdownDescription: "The unique external identifier for the subscription. This identifier serves as an idempotency key, ensuring that each subscription is unique.",
					},
					"name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The display name of the subscription on an invoice. This field allows for customization of the subscription's name for billing purposes, especially useful when a single customer has multiple subscriptions using the same plan.",
						MarkdownDescription: "The display name of the subscription on an invoice. This field allows for customization of the subscription's name for billing purposes, especially useful when a single customer has multiple subscriptions using the same plan.",
					},
					"plan_code": schema.StringAttribute{
						Required:            true,
						Description:         "The unique code representing the plan to be attached to the customer. This code must correspond to the `code` property of one of the active plans.",
						MarkdownDescription: "The unique code representing the plan to be attached to the customer. This code must correspond to the `code` property of one of the active plans.",
					},
					"plan_overrides": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"amount_cents": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "The base cost of the plan, excluding any applicable taxes, that is billed on a recurring basis. This value is defined at 0 if your plan is a pay-as-you-go plan.",
								MarkdownDescription: "The base cost of the plan, excluding any applicable taxes, that is billed on a recurring basis. This value is defined at 0 if your plan is a pay-as-you-go plan.",
							},
							"amount_currency": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"AED",
										"AFN",
										"ALL",
										"AMD",
										"ANG",
										"AOA",
										"ARS",
										"AUD",
										"AWG",
										"AZN",
										"BAM",
										"BBD",
										"BDT",
										"BGN",
										"BIF",
										"BMD",
										"BND",
										"BOB",
										"BRL",
										"BSD",
										"BWP",
										"BYN",
										"BZD",
										"CAD",
										"CDF",
										"CHF",
										"CLF",
										"CLP",
										"CNY",
										"COP",
										"CRC",
										"CVE",
										"CZK",
										"DJF",
										"DKK",
										"DOP",
										"DZD",
										"EGP",
										"ETB",
										"EUR",
										"FJD",
										"FKP",
										"GBP",
										"GEL",
										"GIP",
										"GMD",
										"GNF",
										"GTQ",
										"GYD",
										"HKD",
										"HNL",
										"HRK",
										"HTG",
										"HUF",
										"IDR",
										"ILS",
										"INR",
										"ISK",
										"JMD",
										"JPY",
										"KES",
										"KGS",
										"KHR",
										"KMF",
										"KRW",
										"KYD",
										"KZT",
										"LAK",
										"LBP",
										"LKR",
										"LRD",
										"LSL",
										"MAD",
										"MDL",
										"MGA",
										"MKD",
										"MMK",
										"MNT",
										"MOP",
										"MRO",
										"MUR",
										"MVR",
										"MWK",
										"MXN",
										"MYR",
										"MZN",
										"NAD",
										"NGN",
										"NIO",
										"NOK",
										"NPR",
										"NZD",
										"PAB",
										"PEN",
										"PGK",
										"PHP",
										"PKR",
										"PLN",
										"PYG",
										"QAR",
										"RON",
										"RSD",
										"RUB",
										"RWF",
										"SAR",
										"SBD",
										"SCR",
										"SEK",
										"SGD",
										"SHP",
										"SLL",
										"SOS",
										"SRD",
										"STD",
										"SZL",
										"THB",
										"TJS",
										"TOP",
										"TRY",
										"TTD",
										"TWD",
										"TZS",
										"UAH",
										"UGX",
										"USD",
										"UYU",
										"UZS",
										"VND",
										"VUV",
										"WST",
										"XAF",
										"XCD",
										"XOF",
										"XPF",
										"YER",
										"ZAR",
										"ZMW",
									),
								},
							},
							"charges": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"billable_metric_id": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "Unique identifier of the billable metric created by Lago.",
											MarkdownDescription: "Unique identifier of the billable metric created by Lago.",
										},
										"filters": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"invoice_display_name": schema.StringAttribute{
														Optional:            true,
														Computed:            true,
														Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the values of the filter will be used as the default display name.",
														MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the values of the filter will be used as the default display name.",
													},
													"properties": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"amount": schema.StringAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "- The unit price, excluding tax, for a `standard` charge model. It is expressed as a decimal value.\n- The amount, excluding tax, for a complete set of units in a `package` charge model. It is expressed as a decimal value.",
																MarkdownDescription: "- The unit price, excluding tax, for a `standard` charge model. It is expressed as a decimal value.\n- The amount, excluding tax, for a complete set of units in a `package` charge model. It is expressed as a decimal value.",
																Validators: []validator.String{
																	stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																},
															},
															"fixed_amount": schema.StringAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "The fixed fee that is applied to each transaction for a `percentage` charge model. It is expressed as a decimal value.",
																MarkdownDescription: "The fixed fee that is applied to each transaction for a `percentage` charge model. It is expressed as a decimal value.",
																Validators: []validator.String{
																	stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																},
															},
															"free_units": schema.Int64Attribute{
																Optional:            true,
																Computed:            true,
																Description:         "The quantity of units that are provided free of charge for each billing period in a `package` charge model. This field specifies the number of units that customers can use without incurring any additional cost during each billing cycle.",
																MarkdownDescription: "The quantity of units that are provided free of charge for each billing period in a `package` charge model. This field specifies the number of units that customers can use without incurring any additional cost during each billing cycle.",
															},
															"free_units_per_events": schema.Int64Attribute{
																Optional:            true,
																Computed:            true,
																Description:         "The count of transactions that are not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the number of transactions that are exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
																MarkdownDescription: "The count of transactions that are not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the number of transactions that are exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
															},
															"free_units_per_total_aggregation": schema.StringAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "The transaction amount that is not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the portion of the transaction amount that is exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
																MarkdownDescription: "The transaction amount that is not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the portion of the transaction amount that is exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
																Validators: []validator.String{
																	stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																},
															},
															"graduated_percentage_ranges": schema.ListNestedAttribute{
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"flat_amount": schema.StringAttribute{
																			Required:            true,
																			Description:         "The flat amount for a whole tier, excluding tax, for a `graduated_percentage` charge model. It is expressed as a decimal value.",
																			MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `graduated_percentage` charge model. It is expressed as a decimal value.",
																		},
																		"from_value": schema.Int64Attribute{
																			Required:            true,
																			Description:         "Specifies the lower value of a tier for a `graduated_percentage` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																			MarkdownDescription: "Specifies the lower value of a tier for a `graduated_percentage` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																		},
																		"rate": schema.StringAttribute{
																			Required:            true,
																			Description:         "The percentage rate that is applied to the amount of each transaction in the tier for a `graduated_percentage` charge model. It is expressed as a decimal value.",
																			MarkdownDescription: "The percentage rate that is applied to the amount of each transaction in the tier for a `graduated_percentage` charge model. It is expressed as a decimal value.",
																		},
																		"to_value": schema.Int64Attribute{
																			Required:            true,
																			Description:         "Specifies the highest value of a tier for a `graduated_percentage` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
																			MarkdownDescription: "Specifies the highest value of a tier for a `graduated_percentage` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
																		},
																	},
																	CustomType: GraduatedPercentageRangesType{
																		ObjectType: types.ObjectType{
																			AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
																		},
																	},
																},
																Optional:            true,
																Computed:            true,
																Description:         "Graduated percentage ranges, sorted from bottom to top tiers, used for a `graduated_percentage` charge model.",
																MarkdownDescription: "Graduated percentage ranges, sorted from bottom to top tiers, used for a `graduated_percentage` charge model.",
															},
															"graduated_ranges": schema.ListNestedAttribute{
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"flat_amount": schema.StringAttribute{
																			Required:            true,
																			Description:         "The flat amount for a whole tier, excluding tax, for a `graduated` charge model. It is expressed as a decimal value.",
																			MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `graduated` charge model. It is expressed as a decimal value.",
																			Validators: []validator.String{
																				stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																			},
																		},
																		"from_value": schema.Int64Attribute{
																			Required:            true,
																			Description:         "Specifies the lower value of a tier for a `graduated` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																			MarkdownDescription: "Specifies the lower value of a tier for a `graduated` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																		},
																		"per_unit_amount": schema.StringAttribute{
																			Required:            true,
																			Description:         "The unit price, excluding tax, for a specific tier of a `graduated` charge model. It is expressed as a decimal value.",
																			MarkdownDescription: "The unit price, excluding tax, for a specific tier of a `graduated` charge model. It is expressed as a decimal value.",
																			Validators: []validator.String{
																				stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																			},
																		},
																		"to_value": schema.Int64Attribute{
																			Required:            true,
																			Description:         "Specifies the highest value of a tier for a `graduated` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
																			MarkdownDescription: "Specifies the highest value of a tier for a `graduated` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
																		},
																	},
																	CustomType: GraduatedRangesType{
																		ObjectType: types.ObjectType{
																			AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
																		},
																	},
																},
																Optional:            true,
																Computed:            true,
																Description:         "Graduated ranges, sorted from bottom to top tiers, used for a `graduated` charge model.",
																MarkdownDescription: "Graduated ranges, sorted from bottom to top tiers, used for a `graduated` charge model.",
															},
															"grouped_by": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Computed:            true,
																Description:         "The list of event properties that are used to group the events on the invoice for a `standard` charge model.",
																MarkdownDescription: "The list of event properties that are used to group the events on the invoice for a `standard` charge model.",
															},
															"package_size": schema.Int64Attribute{
																Optional:            true,
																Computed:            true,
																Description:         "The quantity of units included in each pack or set for a `package` charge model. It indicates the number of units that are bundled together as a single package or set within the pricing structure.",
																MarkdownDescription: "The quantity of units included in each pack or set for a `package` charge model. It indicates the number of units that are bundled together as a single package or set within the pricing structure.",
															},
															"per_transaction_max_amount": schema.StringAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "Specifies the maximum allowable spending for a single transaction. Working as a transaction cap.",
																MarkdownDescription: "Specifies the maximum allowable spending for a single transaction. Working as a transaction cap.",
															},
															"per_transaction_min_amount": schema.StringAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "Specifies the minimum allowable spending for a single transaction. Working as a transaction floor.",
																MarkdownDescription: "Specifies the minimum allowable spending for a single transaction. Working as a transaction floor.",
															},
															"rate": schema.StringAttribute{
																Optional:            true,
																Computed:            true,
																Description:         "The percentage rate that is applied to the amount of each transaction for a `percentage` charge model. It is expressed as a decimal value.",
																MarkdownDescription: "The percentage rate that is applied to the amount of each transaction for a `percentage` charge model. It is expressed as a decimal value.",
																Validators: []validator.String{
																	stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																},
															},
															"volume_ranges": schema.ListNestedAttribute{
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"flat_amount": schema.StringAttribute{
																			Required:            true,
																			Description:         "The unit price, excluding tax, for a specific tier of a `volume` charge model. It is expressed as a decimal value.",
																			MarkdownDescription: "The unit price, excluding tax, for a specific tier of a `volume` charge model. It is expressed as a decimal value.",
																			Validators: []validator.String{
																				stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																			},
																		},
																		"from_value": schema.Int64Attribute{
																			Required:            true,
																			Description:         "Specifies the lower value of a tier for a `volume` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																			MarkdownDescription: "Specifies the lower value of a tier for a `volume` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																		},
																		"per_unit_amount": schema.StringAttribute{
																			Required:            true,
																			Description:         "The flat amount for a whole tier, excluding tax, for a `volume` charge model. It is expressed as a decimal value.",
																			MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `volume` charge model. It is expressed as a decimal value.",
																			Validators: []validator.String{
																				stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																			},
																		},
																		"to_value": schema.Int64Attribute{
																			Required:            true,
																			Description:         "Specifies the highest value of a tier for a `volume` charge model.\n- This value must be higher than the `from_value` of the same tier.\n- This value must be `null` for the last tier.",
																			MarkdownDescription: "Specifies the highest value of a tier for a `volume` charge model.\n- This value must be higher than the `from_value` of the same tier.\n- This value must be `null` for the last tier.",
																		},
																	},
																	CustomType: VolumeRangesType{
																		ObjectType: types.ObjectType{
																			AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
																		},
																	},
																},
																Optional:            true,
																Computed:            true,
																Description:         "Volume ranges, sorted from bottom to top tiers, used for a `volume` charge model.",
																MarkdownDescription: "Volume ranges, sorted from bottom to top tiers, used for a `volume` charge model.",
															},
														},
														CustomType: PropertiesType{
															ObjectType: types.ObjectType{
																AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
															},
														},
														Optional: true,
														Computed: true,
													},
													"values": schema.MapAttribute{
														ElementType: types.ListType{
															ElemType: types.StringType,
														},
														Optional:            true,
														Computed:            true,
														Description:         "List of possible filter values. The key and values must match one of the billable metric filters.",
														MarkdownDescription: "List of possible filter values. The key and values must match one of the billable metric filters.",
													},
												},
												CustomType: FiltersType{
													ObjectType: types.ObjectType{
														AttrTypes: FiltersValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Computed:            true,
											Description:         "List of filters used to apply differentiated pricing based on additional event properties.",
											MarkdownDescription: "List of filters used to apply differentiated pricing based on additional event properties.",
										},
										"id": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "Unique identifier of the charge created by Lago.",
											MarkdownDescription: "Unique identifier of the charge created by Lago.",
										},
										"invoice_display_name": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
											MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
										},
										"min_amount_cents": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "The minimum spending amount required for the charge, measured in cents and excluding any applicable taxes. It indicates the minimum amount that needs to be charged for each billing period.",
											MarkdownDescription: "The minimum spending amount required for the charge, measured in cents and excluding any applicable taxes. It indicates the minimum amount that needs to be charged for each billing period.",
										},
										"properties": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"amount": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "- The unit price, excluding tax, for a `standard` charge model. It is expressed as a decimal value.\n- The amount, excluding tax, for a complete set of units in a `package` charge model. It is expressed as a decimal value.",
													MarkdownDescription: "- The unit price, excluding tax, for a `standard` charge model. It is expressed as a decimal value.\n- The amount, excluding tax, for a complete set of units in a `package` charge model. It is expressed as a decimal value.",
													Validators: []validator.String{
														stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
													},
												},
												"fixed_amount": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "The fixed fee that is applied to each transaction for a `percentage` charge model. It is expressed as a decimal value.",
													MarkdownDescription: "The fixed fee that is applied to each transaction for a `percentage` charge model. It is expressed as a decimal value.",
													Validators: []validator.String{
														stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
													},
												},
												"free_units": schema.Int64Attribute{
													Optional:            true,
													Computed:            true,
													Description:         "The quantity of units that are provided free of charge for each billing period in a `package` charge model. This field specifies the number of units that customers can use without incurring any additional cost during each billing cycle.",
													MarkdownDescription: "The quantity of units that are provided free of charge for each billing period in a `package` charge model. This field specifies the number of units that customers can use without incurring any additional cost during each billing cycle.",
												},
												"free_units_per_events": schema.Int64Attribute{
													Optional:            true,
													Computed:            true,
													Description:         "The count of transactions that are not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the number of transactions that are exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
													MarkdownDescription: "The count of transactions that are not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the number of transactions that are exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
												},
												"free_units_per_total_aggregation": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "The transaction amount that is not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the portion of the transaction amount that is exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
													MarkdownDescription: "The transaction amount that is not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the portion of the transaction amount that is exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
													Validators: []validator.String{
														stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
													},
												},
												"graduated_percentage_ranges": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"flat_amount": schema.StringAttribute{
																Required:            true,
																Description:         "The flat amount for a whole tier, excluding tax, for a `graduated_percentage` charge model. It is expressed as a decimal value.",
																MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `graduated_percentage` charge model. It is expressed as a decimal value.",
															},
															"from_value": schema.Int64Attribute{
																Required:            true,
																Description:         "Specifies the lower value of a tier for a `graduated_percentage` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																MarkdownDescription: "Specifies the lower value of a tier for a `graduated_percentage` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
															},
															"rate": schema.StringAttribute{
																Required:            true,
																Description:         "The percentage rate that is applied to the amount of each transaction in the tier for a `graduated_percentage` charge model. It is expressed as a decimal value.",
																MarkdownDescription: "The percentage rate that is applied to the amount of each transaction in the tier for a `graduated_percentage` charge model. It is expressed as a decimal value.",
															},
															"to_value": schema.Int64Attribute{
																Required:            true,
																Description:         "Specifies the highest value of a tier for a `graduated_percentage` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
																MarkdownDescription: "Specifies the highest value of a tier for a `graduated_percentage` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
															},
														},
														CustomType: GraduatedPercentageRangesType{
															ObjectType: types.ObjectType{
																AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional:            true,
													Computed:            true,
													Description:         "Graduated percentage ranges, sorted from bottom to top tiers, used for a `graduated_percentage` charge model.",
													MarkdownDescription: "Graduated percentage ranges, sorted from bottom to top tiers, used for a `graduated_percentage` charge model.",
												},
												"graduated_ranges": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"flat_amount": schema.StringAttribute{
																Required:            true,
																Description:         "The flat amount for a whole tier, excluding tax, for a `graduated` charge model. It is expressed as a decimal value.",
																MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `graduated` charge model. It is expressed as a decimal value.",
																Validators: []validator.String{
																	stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																},
															},
															"from_value": schema.Int64Attribute{
																Required:            true,
																Description:         "Specifies the lower value of a tier for a `graduated` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																MarkdownDescription: "Specifies the lower value of a tier for a `graduated` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
															},
															"per_unit_amount": schema.StringAttribute{
																Required:            true,
																Description:         "The unit price, excluding tax, for a specific tier of a `graduated` charge model. It is expressed as a decimal value.",
																MarkdownDescription: "The unit price, excluding tax, for a specific tier of a `graduated` charge model. It is expressed as a decimal value.",
																Validators: []validator.String{
																	stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																},
															},
															"to_value": schema.Int64Attribute{
																Required:            true,
																Description:         "Specifies the highest value of a tier for a `graduated` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
																MarkdownDescription: "Specifies the highest value of a tier for a `graduated` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
															},
														},
														CustomType: GraduatedRangesType{
															ObjectType: types.ObjectType{
																AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional:            true,
													Computed:            true,
													Description:         "Graduated ranges, sorted from bottom to top tiers, used for a `graduated` charge model.",
													MarkdownDescription: "Graduated ranges, sorted from bottom to top tiers, used for a `graduated` charge model.",
												},
												"grouped_by": schema.ListAttribute{
													ElementType:         types.StringType,
													Optional:            true,
													Computed:            true,
													Description:         "The list of event properties that are used to group the events on the invoice for a `standard` charge model.",
													MarkdownDescription: "The list of event properties that are used to group the events on the invoice for a `standard` charge model.",
												},
												"package_size": schema.Int64Attribute{
													Optional:            true,
													Computed:            true,
													Description:         "The quantity of units included in each pack or set for a `package` charge model. It indicates the number of units that are bundled together as a single package or set within the pricing structure.",
													MarkdownDescription: "The quantity of units included in each pack or set for a `package` charge model. It indicates the number of units that are bundled together as a single package or set within the pricing structure.",
												},
												"per_transaction_max_amount": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "Specifies the maximum allowable spending for a single transaction. Working as a transaction cap.",
													MarkdownDescription: "Specifies the maximum allowable spending for a single transaction. Working as a transaction cap.",
												},
												"per_transaction_min_amount": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "Specifies the minimum allowable spending for a single transaction. Working as a transaction floor.",
													MarkdownDescription: "Specifies the minimum allowable spending for a single transaction. Working as a transaction floor.",
												},
												"rate": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "The percentage rate that is applied to the amount of each transaction for a `percentage` charge model. It is expressed as a decimal value.",
													MarkdownDescription: "The percentage rate that is applied to the amount of each transaction for a `percentage` charge model. It is expressed as a decimal value.",
													Validators: []validator.String{
														stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
													},
												},
												"volume_ranges": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"flat_amount": schema.StringAttribute{
																Required:            true,
																Description:         "The unit price, excluding tax, for a specific tier of a `volume` charge model. It is expressed as a decimal value.",
																MarkdownDescription: "The unit price, excluding tax, for a specific tier of a `volume` charge model. It is expressed as a decimal value.",
																Validators: []validator.String{
																	stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																},
															},
															"from_value": schema.Int64Attribute{
																Required:            true,
																Description:         "Specifies the lower value of a tier for a `volume` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																MarkdownDescription: "Specifies the lower value of a tier for a `volume` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
															},
															"per_unit_amount": schema.StringAttribute{
																Required:            true,
																Description:         "The flat amount for a whole tier, excluding tax, for a `volume` charge model. It is expressed as a decimal value.",
																MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `volume` charge model. It is expressed as a decimal value.",
																Validators: []validator.String{
																	stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																},
															},
															"to_value": schema.Int64Attribute{
																Required:            true,
																Description:         "Specifies the highest value of a tier for a `volume` charge model.\n- This value must be higher than the `from_value` of the same tier.\n- This value must be `null` for the last tier.",
																MarkdownDescription: "Specifies the highest value of a tier for a `volume` charge model.\n- This value must be higher than the `from_value` of the same tier.\n- This value must be `null` for the last tier.",
															},
														},
														CustomType: VolumeRangesType{
															ObjectType: types.ObjectType{
																AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional:            true,
													Computed:            true,
													Description:         "Volume ranges, sorted from bottom to top tiers, used for a `volume` charge model.",
													MarkdownDescription: "Volume ranges, sorted from bottom to top tiers, used for a `volume` charge model.",
												},
											},
											CustomType: PropertiesType{
												ObjectType: types.ObjectType{
													AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
												},
											},
											Optional: true,
											Computed: true,
										},
										"tax_codes": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Computed:            true,
											Description:         "List of unique code used to identify the taxes.",
											MarkdownDescription: "List of unique code used to identify the taxes.",
										},
									},
									CustomType: ChargesType{
										ObjectType: types.ObjectType{
											AttrTypes: ChargesValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "Additional usage-based charges for this plan.",
								MarkdownDescription: "Additional usage-based charges for this plan.",
							},
							"description": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The description on the plan.",
								MarkdownDescription: "The description on the plan.",
							},
							"invoice_display_name": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the plan will be used as the default display name.",
								MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the plan will be used as the default display name.",
							},
							"minimum_commitment": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"amount_cents": schema.Int64Attribute{
										Required:            true,
										Description:         "The amount of the minimum commitment in cents.",
										MarkdownDescription: "The amount of the minimum commitment in cents.",
									},
									"created_at": schema.StringAttribute{
										Required:            true,
										Description:         "The date and time when the minimum commitment was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the minimum commitment was initially created.",
										MarkdownDescription: "The date and time when the minimum commitment was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the minimum commitment was initially created.",
									},
									"interval": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The interval used for recurring billing. It represents the frequency at which subscription billing occurs. The interval can be one of the following values: `yearly`, `quarterly`, `monthly` or `weekly`.",
										MarkdownDescription: "The interval used for recurring billing. It represents the frequency at which subscription billing occurs. The interval can be one of the following values: `yearly`, `quarterly`, `monthly` or `weekly`.",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"weekly",
												"monthly",
												"quarterly",
												"yearly",
											),
										},
									},
									"invoice_display_name": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the default name will be used as the display name.",
										MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the default name will be used as the display name.",
									},
									"lago_id": schema.StringAttribute{
										Required:            true,
										Description:         "Unique identifier of the minimum commitment, created by Lago.",
										MarkdownDescription: "Unique identifier of the minimum commitment, created by Lago.",
									},
									"plan_code": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The unique code representing the plan to be attached to the customer.",
										MarkdownDescription: "The unique code representing the plan to be attached to the customer.",
									},
									"taxes": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"applied_to_organization": schema.BoolAttribute{
													Required:            true,
													Description:         "Set to `true` if the tax is used as one of the organization's default",
													MarkdownDescription: "Set to `true` if the tax is used as one of the organization's default",
												},
												"code": schema.StringAttribute{
													Required:            true,
													Description:         "Unique code used to identify the tax associated with the API request.",
													MarkdownDescription: "Unique code used to identify the tax associated with the API request.",
												},
												"created_at": schema.StringAttribute{
													Required:            true,
													Description:         "Creation date of the tax.",
													MarkdownDescription: "Creation date of the tax.",
												},
												"description": schema.StringAttribute{
													Optional:            true,
													Computed:            true,
													Description:         "Internal description of the taxe",
													MarkdownDescription: "Internal description of the taxe",
												},
												"lago_id": schema.StringAttribute{
													Required:            true,
													Description:         "Unique identifier of the tax, created by Lago.",
													MarkdownDescription: "Unique identifier of the tax, created by Lago.",
												},
												"name": schema.StringAttribute{
													Required:            true,
													Description:         "Name of the tax.",
													MarkdownDescription: "Name of the tax.",
												},
												"rate": schema.NumberAttribute{
													Required:            true,
													Description:         "The percentage rate of the tax",
													MarkdownDescription: "The percentage rate of the tax",
												},
											},
											CustomType: TaxesType{
												ObjectType: types.ObjectType{
													AttrTypes: TaxesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional:            true,
										Computed:            true,
										Description:         "All taxes applied to the minimum commitment.",
										MarkdownDescription: "All taxes applied to the minimum commitment.",
									},
									"updated_at": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "The date and time when the minimum commitment was updated. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the minimum commitment was initially created.",
										MarkdownDescription: "The date and time when the minimum commitment was updated. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the minimum commitment was initially created.",
									},
								},
								CustomType: MinimumCommitmentType{
									ObjectType: types.ObjectType{
										AttrTypes: MinimumCommitmentValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
								Computed: true,
							},
							"name": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The name of the plan.",
								MarkdownDescription: "The name of the plan.",
							},
							"tax_codes": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "List of unique code used to identify the taxes.",
								MarkdownDescription: "List of unique code used to identify the taxes.",
							},
							"trial_period": schema.NumberAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The duration in days during which the base cost of the plan is offered for free.",
								MarkdownDescription: "The duration in days during which the base cost of the plan is offered for free.",
							},
							"usage_thresholds": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"amount_cents": schema.Int64Attribute{
											Required:            true,
											Description:         "The amount to reach to trigger a `progressive_billing` invoice.",
											MarkdownDescription: "The amount to reach to trigger a `progressive_billing` invoice.",
										},
										"created_at": schema.StringAttribute{
											Required:            true,
											Description:         "The date and time when the usage threshold was created. It is expressed in UTC format according to the ISO 8601 datetime standard.",
											MarkdownDescription: "The date and time when the usage threshold was created. It is expressed in UTC format according to the ISO 8601 datetime standard.",
										},
										"lago_id": schema.StringAttribute{
											Required:            true,
											Description:         "Unique identifier of the usage threshold created by Lago.",
											MarkdownDescription: "Unique identifier of the usage threshold created by Lago.",
										},
										"recurring": schema.BoolAttribute{
											Required:            true,
											Description:         "This field when set to `true` indicates that a `progressive_billing` invoice will be created every time the lifetime usage increases by the specified amount.",
											MarkdownDescription: "This field when set to `true` indicates that a `progressive_billing` invoice will be created every time the lifetime usage increases by the specified amount.",
										},
										"threshold_display_name": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "The display name of the usage threshold.",
											MarkdownDescription: "The display name of the usage threshold.",
										},
										"updated_at": schema.StringAttribute{
											Required:            true,
											Description:         "The date and time when the usage threshold was last updated. It is expressed in UTC format according to the ISO 8601 datetime standard.",
											MarkdownDescription: "The date and time when the usage threshold was last updated. It is expressed in UTC format according to the ISO 8601 datetime standard.",
										},
									},
									CustomType: UsageThresholdsType{
										ObjectType: types.ObjectType{
											AttrTypes: UsageThresholdsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Computed:            true,
								Description:         "List of usage thresholds applied to the subscription.",
								MarkdownDescription: "List of usage thresholds applied to the subscription.",
							},
						},
						CustomType: PlanOverridesType{
							ObjectType: types.ObjectType{
								AttrTypes: PlanOverridesValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Based plan overrides.",
						MarkdownDescription: "Based plan overrides.",
					},
					"subscription_at": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The start date for the subscription, allowing for the creation of subscriptions that can begin in the past or future. Please note that it cannot be used to update the start date of a pending subscription or schedule an upgrade/downgrade. The start_date should be provided in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC).",
						MarkdownDescription: "The start date for the subscription, allowing for the creation of subscriptions that can begin in the past or future. Please note that it cannot be used to update the start date of a pending subscription or schedule an upgrade/downgrade. The start_date should be provided in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC).",
					},
				},
				CustomType: SubscriptionType{
					ObjectType: types.ObjectType{
						AttrTypes: SubscriptionValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
		},
	}
}

type SubscriptionsModel struct {
	ExternalId    types.String       `tfsdk:"external_id"`
	LifetimeUsage LifetimeUsageValue `tfsdk:"lifetime_usage"`
	Subscription  SubscriptionValue  `tfsdk:"subscription"`
}

var _ basetypes.ObjectTypable = LifetimeUsageType{}

type LifetimeUsageType struct {
	basetypes.ObjectType
}

func (t LifetimeUsageType) Equal(o attr.Type) bool {
	other, ok := o.(LifetimeUsageType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LifetimeUsageType) String() string {
	return "LifetimeUsageType"
}

func (t LifetimeUsageType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	currentUsageAmountCentsAttribute, ok := attributes["current_usage_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_usage_amount_cents is missing from object`)

		return nil, diags
	}

	currentUsageAmountCentsVal, ok := currentUsageAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_usage_amount_cents expected to be basetypes.Int64Value, was: %T`, currentUsageAmountCentsAttribute))
	}

	externalHistoricalUsageAmountCentsAttribute, ok := attributes["external_historical_usage_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_historical_usage_amount_cents is missing from object`)

		return nil, diags
	}

	externalHistoricalUsageAmountCentsVal, ok := externalHistoricalUsageAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_historical_usage_amount_cents expected to be basetypes.Int64Value, was: %T`, externalHistoricalUsageAmountCentsAttribute))
	}

	externalSubscriptionIdAttribute, ok := attributes["external_subscription_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_subscription_id is missing from object`)

		return nil, diags
	}

	externalSubscriptionIdVal, ok := externalSubscriptionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_subscription_id expected to be basetypes.StringValue, was: %T`, externalSubscriptionIdAttribute))
	}

	fromDatetimeAttribute, ok := attributes["from_datetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_datetime is missing from object`)

		return nil, diags
	}

	fromDatetimeVal, ok := fromDatetimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_datetime expected to be basetypes.StringValue, was: %T`, fromDatetimeAttribute))
	}

	invoicedUsageAmountCentsAttribute, ok := attributes["invoiced_usage_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoiced_usage_amount_cents is missing from object`)

		return nil, diags
	}

	invoicedUsageAmountCentsVal, ok := invoicedUsageAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoiced_usage_amount_cents expected to be basetypes.Int64Value, was: %T`, invoicedUsageAmountCentsAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lagoSubscriptionIdAttribute, ok := attributes["lago_subscription_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_subscription_id is missing from object`)

		return nil, diags
	}

	lagoSubscriptionIdVal, ok := lagoSubscriptionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_subscription_id expected to be basetypes.StringValue, was: %T`, lagoSubscriptionIdAttribute))
	}

	toDatetimeAttribute, ok := attributes["to_datetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_datetime is missing from object`)

		return nil, diags
	}

	toDatetimeVal, ok := toDatetimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_datetime expected to be basetypes.StringValue, was: %T`, toDatetimeAttribute))
	}

	usageThresholdsAttribute, ok := attributes["usage_thresholds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage_thresholds is missing from object`)

		return nil, diags
	}

	usageThresholdsVal, ok := usageThresholdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage_thresholds expected to be basetypes.ListValue, was: %T`, usageThresholdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LifetimeUsageValue{
		CurrentUsageAmountCents:            currentUsageAmountCentsVal,
		ExternalHistoricalUsageAmountCents: externalHistoricalUsageAmountCentsVal,
		ExternalSubscriptionId:             externalSubscriptionIdVal,
		FromDatetime:                       fromDatetimeVal,
		InvoicedUsageAmountCents:           invoicedUsageAmountCentsVal,
		LagoId:                             lagoIdVal,
		LagoSubscriptionId:                 lagoSubscriptionIdVal,
		ToDatetime:                         toDatetimeVal,
		UsageThresholds:                    usageThresholdsVal,
		state:                              attr.ValueStateKnown,
	}, diags
}

func NewLifetimeUsageValueNull() LifetimeUsageValue {
	return LifetimeUsageValue{
		state: attr.ValueStateNull,
	}
}

func NewLifetimeUsageValueUnknown() LifetimeUsageValue {
	return LifetimeUsageValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLifetimeUsageValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LifetimeUsageValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LifetimeUsageValue Attribute Value",
				"While creating a LifetimeUsageValue value, a missing attribute value was detected. "+
					"A LifetimeUsageValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LifetimeUsageValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LifetimeUsageValue Attribute Type",
				"While creating a LifetimeUsageValue value, an invalid attribute value was detected. "+
					"A LifetimeUsageValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LifetimeUsageValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LifetimeUsageValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LifetimeUsageValue Attribute Value",
				"While creating a LifetimeUsageValue value, an extra attribute value was detected. "+
					"A LifetimeUsageValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LifetimeUsageValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLifetimeUsageValueUnknown(), diags
	}

	currentUsageAmountCentsAttribute, ok := attributes["current_usage_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_usage_amount_cents is missing from object`)

		return NewLifetimeUsageValueUnknown(), diags
	}

	currentUsageAmountCentsVal, ok := currentUsageAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_usage_amount_cents expected to be basetypes.Int64Value, was: %T`, currentUsageAmountCentsAttribute))
	}

	externalHistoricalUsageAmountCentsAttribute, ok := attributes["external_historical_usage_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_historical_usage_amount_cents is missing from object`)

		return NewLifetimeUsageValueUnknown(), diags
	}

	externalHistoricalUsageAmountCentsVal, ok := externalHistoricalUsageAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_historical_usage_amount_cents expected to be basetypes.Int64Value, was: %T`, externalHistoricalUsageAmountCentsAttribute))
	}

	externalSubscriptionIdAttribute, ok := attributes["external_subscription_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_subscription_id is missing from object`)

		return NewLifetimeUsageValueUnknown(), diags
	}

	externalSubscriptionIdVal, ok := externalSubscriptionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_subscription_id expected to be basetypes.StringValue, was: %T`, externalSubscriptionIdAttribute))
	}

	fromDatetimeAttribute, ok := attributes["from_datetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_datetime is missing from object`)

		return NewLifetimeUsageValueUnknown(), diags
	}

	fromDatetimeVal, ok := fromDatetimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_datetime expected to be basetypes.StringValue, was: %T`, fromDatetimeAttribute))
	}

	invoicedUsageAmountCentsAttribute, ok := attributes["invoiced_usage_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoiced_usage_amount_cents is missing from object`)

		return NewLifetimeUsageValueUnknown(), diags
	}

	invoicedUsageAmountCentsVal, ok := invoicedUsageAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoiced_usage_amount_cents expected to be basetypes.Int64Value, was: %T`, invoicedUsageAmountCentsAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewLifetimeUsageValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lagoSubscriptionIdAttribute, ok := attributes["lago_subscription_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_subscription_id is missing from object`)

		return NewLifetimeUsageValueUnknown(), diags
	}

	lagoSubscriptionIdVal, ok := lagoSubscriptionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_subscription_id expected to be basetypes.StringValue, was: %T`, lagoSubscriptionIdAttribute))
	}

	toDatetimeAttribute, ok := attributes["to_datetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_datetime is missing from object`)

		return NewLifetimeUsageValueUnknown(), diags
	}

	toDatetimeVal, ok := toDatetimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_datetime expected to be basetypes.StringValue, was: %T`, toDatetimeAttribute))
	}

	usageThresholdsAttribute, ok := attributes["usage_thresholds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage_thresholds is missing from object`)

		return NewLifetimeUsageValueUnknown(), diags
	}

	usageThresholdsVal, ok := usageThresholdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage_thresholds expected to be basetypes.ListValue, was: %T`, usageThresholdsAttribute))
	}

	if diags.HasError() {
		return NewLifetimeUsageValueUnknown(), diags
	}

	return LifetimeUsageValue{
		CurrentUsageAmountCents:            currentUsageAmountCentsVal,
		ExternalHistoricalUsageAmountCents: externalHistoricalUsageAmountCentsVal,
		ExternalSubscriptionId:             externalSubscriptionIdVal,
		FromDatetime:                       fromDatetimeVal,
		InvoicedUsageAmountCents:           invoicedUsageAmountCentsVal,
		LagoId:                             lagoIdVal,
		LagoSubscriptionId:                 lagoSubscriptionIdVal,
		ToDatetime:                         toDatetimeVal,
		UsageThresholds:                    usageThresholdsVal,
		state:                              attr.ValueStateKnown,
	}, diags
}

func NewLifetimeUsageValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LifetimeUsageValue {
	object, diags := NewLifetimeUsageValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLifetimeUsageValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LifetimeUsageType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLifetimeUsageValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLifetimeUsageValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLifetimeUsageValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLifetimeUsageValueMust(LifetimeUsageValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LifetimeUsageType) ValueType(ctx context.Context) attr.Value {
	return LifetimeUsageValue{}
}

var _ basetypes.ObjectValuable = LifetimeUsageValue{}

type LifetimeUsageValue struct {
	CurrentUsageAmountCents            basetypes.Int64Value  `tfsdk:"current_usage_amount_cents"`
	ExternalHistoricalUsageAmountCents basetypes.Int64Value  `tfsdk:"external_historical_usage_amount_cents"`
	ExternalSubscriptionId             basetypes.StringValue `tfsdk:"external_subscription_id"`
	FromDatetime                       basetypes.StringValue `tfsdk:"from_datetime"`
	InvoicedUsageAmountCents           basetypes.Int64Value  `tfsdk:"invoiced_usage_amount_cents"`
	LagoId                             basetypes.StringValue `tfsdk:"lago_id"`
	LagoSubscriptionId                 basetypes.StringValue `tfsdk:"lago_subscription_id"`
	ToDatetime                         basetypes.StringValue `tfsdk:"to_datetime"`
	UsageThresholds                    basetypes.ListValue   `tfsdk:"usage_thresholds"`
	state                              attr.ValueState
}

func (v LifetimeUsageValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["current_usage_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["external_historical_usage_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["external_subscription_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_datetime"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoiced_usage_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_subscription_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_datetime"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["usage_thresholds"] = basetypes.ListType{
		ElemType: UsageThresholdsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.CurrentUsageAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_usage_amount_cents"] = val

		val, err = v.ExternalHistoricalUsageAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_historical_usage_amount_cents"] = val

		val, err = v.ExternalSubscriptionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_subscription_id"] = val

		val, err = v.FromDatetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_datetime"] = val

		val, err = v.InvoicedUsageAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoiced_usage_amount_cents"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.LagoSubscriptionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_subscription_id"] = val

		val, err = v.ToDatetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_datetime"] = val

		val, err = v.UsageThresholds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage_thresholds"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LifetimeUsageValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LifetimeUsageValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LifetimeUsageValue) String() string {
	return "LifetimeUsageValue"
}

func (v LifetimeUsageValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	usageThresholds := types.ListValueMust(
		UsageThresholdsType{
			basetypes.ObjectType{
				AttrTypes: UsageThresholdsValue{}.AttributeTypes(ctx),
			},
		},
		v.UsageThresholds.Elements(),
	)

	if v.UsageThresholds.IsNull() {
		usageThresholds = types.ListNull(
			UsageThresholdsType{
				basetypes.ObjectType{
					AttrTypes: UsageThresholdsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.UsageThresholds.IsUnknown() {
		usageThresholds = types.ListUnknown(
			UsageThresholdsType{
				basetypes.ObjectType{
					AttrTypes: UsageThresholdsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"current_usage_amount_cents":             basetypes.Int64Type{},
		"external_historical_usage_amount_cents": basetypes.Int64Type{},
		"external_subscription_id":               basetypes.StringType{},
		"from_datetime":                          basetypes.StringType{},
		"invoiced_usage_amount_cents":            basetypes.Int64Type{},
		"lago_id":                                basetypes.StringType{},
		"lago_subscription_id":                   basetypes.StringType{},
		"to_datetime":                            basetypes.StringType{},
		"usage_thresholds": basetypes.ListType{
			ElemType: UsageThresholdsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"current_usage_amount_cents":             v.CurrentUsageAmountCents,
			"external_historical_usage_amount_cents": v.ExternalHistoricalUsageAmountCents,
			"external_subscription_id":               v.ExternalSubscriptionId,
			"from_datetime":                          v.FromDatetime,
			"invoiced_usage_amount_cents":            v.InvoicedUsageAmountCents,
			"lago_id":                                v.LagoId,
			"lago_subscription_id":                   v.LagoSubscriptionId,
			"to_datetime":                            v.ToDatetime,
			"usage_thresholds":                       usageThresholds,
		})

	return objVal, diags
}

func (v LifetimeUsageValue) Equal(o attr.Value) bool {
	other, ok := o.(LifetimeUsageValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CurrentUsageAmountCents.Equal(other.CurrentUsageAmountCents) {
		return false
	}

	if !v.ExternalHistoricalUsageAmountCents.Equal(other.ExternalHistoricalUsageAmountCents) {
		return false
	}

	if !v.ExternalSubscriptionId.Equal(other.ExternalSubscriptionId) {
		return false
	}

	if !v.FromDatetime.Equal(other.FromDatetime) {
		return false
	}

	if !v.InvoicedUsageAmountCents.Equal(other.InvoicedUsageAmountCents) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.LagoSubscriptionId.Equal(other.LagoSubscriptionId) {
		return false
	}

	if !v.ToDatetime.Equal(other.ToDatetime) {
		return false
	}

	if !v.UsageThresholds.Equal(other.UsageThresholds) {
		return false
	}

	return true
}

func (v LifetimeUsageValue) Type(ctx context.Context) attr.Type {
	return LifetimeUsageType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LifetimeUsageValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"current_usage_amount_cents":             basetypes.Int64Type{},
		"external_historical_usage_amount_cents": basetypes.Int64Type{},
		"external_subscription_id":               basetypes.StringType{},
		"from_datetime":                          basetypes.StringType{},
		"invoiced_usage_amount_cents":            basetypes.Int64Type{},
		"lago_id":                                basetypes.StringType{},
		"lago_subscription_id":                   basetypes.StringType{},
		"to_datetime":                            basetypes.StringType{},
		"usage_thresholds": basetypes.ListType{
			ElemType: UsageThresholdsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = UsageThresholdsType{}

type UsageThresholdsType struct {
	basetypes.ObjectType
}

func (t UsageThresholdsType) Equal(o attr.Type) bool {
	other, ok := o.(UsageThresholdsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsageThresholdsType) String() string {
	return "UsageThresholdsType"
}

func (t UsageThresholdsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	completionRatioAttribute, ok := attributes["completion_ratio"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`completion_ratio is missing from object`)

		return nil, diags
	}

	completionRatioVal, ok := completionRatioAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`completion_ratio expected to be basetypes.NumberValue, was: %T`, completionRatioAttribute))
	}

	reachedAtAttribute, ok := attributes["reached_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reached_at is missing from object`)

		return nil, diags
	}

	reachedAtVal, ok := reachedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reached_at expected to be basetypes.StringValue, was: %T`, reachedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsageThresholdsValue{
		AmountCents:     amountCentsVal,
		CompletionRatio: completionRatioVal,
		ReachedAt:       reachedAtVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewUsageThresholdsValueNull() UsageThresholdsValue {
	return UsageThresholdsValue{
		state: attr.ValueStateNull,
	}
}

func NewUsageThresholdsValueUnknown() UsageThresholdsValue {
	return UsageThresholdsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsageThresholdsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsageThresholdsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsageThresholdsValue Attribute Value",
				"While creating a UsageThresholdsValue value, a missing attribute value was detected. "+
					"A UsageThresholdsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsageThresholdsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsageThresholdsValue Attribute Type",
				"While creating a UsageThresholdsValue value, an invalid attribute value was detected. "+
					"A UsageThresholdsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsageThresholdsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsageThresholdsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsageThresholdsValue Attribute Value",
				"While creating a UsageThresholdsValue value, an extra attribute value was detected. "+
					"A UsageThresholdsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsageThresholdsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsageThresholdsValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	completionRatioAttribute, ok := attributes["completion_ratio"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`completion_ratio is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	completionRatioVal, ok := completionRatioAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`completion_ratio expected to be basetypes.NumberValue, was: %T`, completionRatioAttribute))
	}

	reachedAtAttribute, ok := attributes["reached_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reached_at is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	reachedAtVal, ok := reachedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reached_at expected to be basetypes.StringValue, was: %T`, reachedAtAttribute))
	}

	if diags.HasError() {
		return NewUsageThresholdsValueUnknown(), diags
	}

	return UsageThresholdsValue{
		AmountCents:     amountCentsVal,
		CompletionRatio: completionRatioVal,
		ReachedAt:       reachedAtVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewUsageThresholdsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsageThresholdsValue {
	object, diags := NewUsageThresholdsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsageThresholdsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsageThresholdsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsageThresholdsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsageThresholdsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsageThresholdsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsageThresholdsValueMust(UsageThresholdsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsageThresholdsType) ValueType(ctx context.Context) attr.Value {
	return UsageThresholdsValue{}
}

var _ basetypes.ObjectValuable = UsageThresholdsValue{}

type UsageThresholdsValue struct {
	AmountCents     basetypes.Int64Value  `tfsdk:"amount_cents"`
	CompletionRatio basetypes.NumberValue `tfsdk:"completion_ratio"`
	ReachedAt       basetypes.StringValue `tfsdk:"reached_at"`
	state           attr.ValueState
}

func (v UsageThresholdsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["completion_ratio"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["reached_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.CompletionRatio.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["completion_ratio"] = val

		val, err = v.ReachedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reached_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsageThresholdsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsageThresholdsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsageThresholdsValue) String() string {
	return "UsageThresholdsValue"
}

func (v UsageThresholdsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"amount_cents":     basetypes.Int64Type{},
		"completion_ratio": basetypes.NumberType{},
		"reached_at":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":     v.AmountCents,
			"completion_ratio": v.CompletionRatio,
			"reached_at":       v.ReachedAt,
		})

	return objVal, diags
}

func (v UsageThresholdsValue) Equal(o attr.Value) bool {
	other, ok := o.(UsageThresholdsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.CompletionRatio.Equal(other.CompletionRatio) {
		return false
	}

	if !v.ReachedAt.Equal(other.ReachedAt) {
		return false
	}

	return true
}

func (v UsageThresholdsValue) Type(ctx context.Context) attr.Type {
	return UsageThresholdsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsageThresholdsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":     basetypes.Int64Type{},
		"completion_ratio": basetypes.NumberType{},
		"reached_at":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SubscriptionType{}

type SubscriptionType struct {
	basetypes.ObjectType
}

func (t SubscriptionType) Equal(o attr.Type) bool {
	other, ok := o.(SubscriptionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SubscriptionType) String() string {
	return "SubscriptionType"
}

func (t SubscriptionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	billingTimeAttribute, ok := attributes["billing_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billing_time is missing from object`)

		return nil, diags
	}

	billingTimeVal, ok := billingTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billing_time expected to be basetypes.StringValue, was: %T`, billingTimeAttribute))
	}

	endingAtAttribute, ok := attributes["ending_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ending_at is missing from object`)

		return nil, diags
	}

	endingAtVal, ok := endingAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ending_at expected to be basetypes.StringValue, was: %T`, endingAtAttribute))
	}

	externalCustomerIdAttribute, ok := attributes["external_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_customer_id is missing from object`)

		return nil, diags
	}

	externalCustomerIdVal, ok := externalCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_customer_id expected to be basetypes.StringValue, was: %T`, externalCustomerIdAttribute))
	}

	externalIdAttribute, ok := attributes["external_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_id is missing from object`)

		return nil, diags
	}

	externalIdVal, ok := externalIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_id expected to be basetypes.StringValue, was: %T`, externalIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	planCodeAttribute, ok := attributes["plan_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_code is missing from object`)

		return nil, diags
	}

	planCodeVal, ok := planCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_code expected to be basetypes.StringValue, was: %T`, planCodeAttribute))
	}

	planOverridesAttribute, ok := attributes["plan_overrides"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_overrides is missing from object`)

		return nil, diags
	}

	planOverridesVal, ok := planOverridesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_overrides expected to be basetypes.ObjectValue, was: %T`, planOverridesAttribute))
	}

	subscriptionAtAttribute, ok := attributes["subscription_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subscription_at is missing from object`)

		return nil, diags
	}

	subscriptionAtVal, ok := subscriptionAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subscription_at expected to be basetypes.StringValue, was: %T`, subscriptionAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SubscriptionValue{
		BillingTime:        billingTimeVal,
		EndingAt:           endingAtVal,
		ExternalCustomerId: externalCustomerIdVal,
		ExternalId:         externalIdVal,
		Name:               nameVal,
		PlanCode:           planCodeVal,
		PlanOverrides:      planOverridesVal,
		SubscriptionAt:     subscriptionAtVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSubscriptionValueNull() SubscriptionValue {
	return SubscriptionValue{
		state: attr.ValueStateNull,
	}
}

func NewSubscriptionValueUnknown() SubscriptionValue {
	return SubscriptionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSubscriptionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SubscriptionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SubscriptionValue Attribute Value",
				"While creating a SubscriptionValue value, a missing attribute value was detected. "+
					"A SubscriptionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubscriptionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SubscriptionValue Attribute Type",
				"While creating a SubscriptionValue value, an invalid attribute value was detected. "+
					"A SubscriptionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubscriptionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SubscriptionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SubscriptionValue Attribute Value",
				"While creating a SubscriptionValue value, an extra attribute value was detected. "+
					"A SubscriptionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SubscriptionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubscriptionValueUnknown(), diags
	}

	billingTimeAttribute, ok := attributes["billing_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billing_time is missing from object`)

		return NewSubscriptionValueUnknown(), diags
	}

	billingTimeVal, ok := billingTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billing_time expected to be basetypes.StringValue, was: %T`, billingTimeAttribute))
	}

	endingAtAttribute, ok := attributes["ending_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ending_at is missing from object`)

		return NewSubscriptionValueUnknown(), diags
	}

	endingAtVal, ok := endingAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ending_at expected to be basetypes.StringValue, was: %T`, endingAtAttribute))
	}

	externalCustomerIdAttribute, ok := attributes["external_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_customer_id is missing from object`)

		return NewSubscriptionValueUnknown(), diags
	}

	externalCustomerIdVal, ok := externalCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_customer_id expected to be basetypes.StringValue, was: %T`, externalCustomerIdAttribute))
	}

	externalIdAttribute, ok := attributes["external_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_id is missing from object`)

		return NewSubscriptionValueUnknown(), diags
	}

	externalIdVal, ok := externalIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_id expected to be basetypes.StringValue, was: %T`, externalIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSubscriptionValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	planCodeAttribute, ok := attributes["plan_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_code is missing from object`)

		return NewSubscriptionValueUnknown(), diags
	}

	planCodeVal, ok := planCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_code expected to be basetypes.StringValue, was: %T`, planCodeAttribute))
	}

	planOverridesAttribute, ok := attributes["plan_overrides"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_overrides is missing from object`)

		return NewSubscriptionValueUnknown(), diags
	}

	planOverridesVal, ok := planOverridesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_overrides expected to be basetypes.ObjectValue, was: %T`, planOverridesAttribute))
	}

	subscriptionAtAttribute, ok := attributes["subscription_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subscription_at is missing from object`)

		return NewSubscriptionValueUnknown(), diags
	}

	subscriptionAtVal, ok := subscriptionAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subscription_at expected to be basetypes.StringValue, was: %T`, subscriptionAtAttribute))
	}

	if diags.HasError() {
		return NewSubscriptionValueUnknown(), diags
	}

	return SubscriptionValue{
		BillingTime:        billingTimeVal,
		EndingAt:           endingAtVal,
		ExternalCustomerId: externalCustomerIdVal,
		ExternalId:         externalIdVal,
		Name:               nameVal,
		PlanCode:           planCodeVal,
		PlanOverrides:      planOverridesVal,
		SubscriptionAt:     subscriptionAtVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewSubscriptionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SubscriptionValue {
	object, diags := NewSubscriptionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubscriptionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SubscriptionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubscriptionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubscriptionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubscriptionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubscriptionValueMust(SubscriptionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SubscriptionType) ValueType(ctx context.Context) attr.Value {
	return SubscriptionValue{}
}

var _ basetypes.ObjectValuable = SubscriptionValue{}

type SubscriptionValue struct {
	BillingTime        basetypes.StringValue `tfsdk:"billing_time"`
	EndingAt           basetypes.StringValue `tfsdk:"ending_at"`
	ExternalCustomerId basetypes.StringValue `tfsdk:"external_customer_id"`
	ExternalId         basetypes.StringValue `tfsdk:"external_id"`
	Name               basetypes.StringValue `tfsdk:"name"`
	PlanCode           basetypes.StringValue `tfsdk:"plan_code"`
	PlanOverrides      basetypes.ObjectValue `tfsdk:"plan_overrides"`
	SubscriptionAt     basetypes.StringValue `tfsdk:"subscription_at"`
	state              attr.ValueState
}

func (v SubscriptionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["billing_time"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ending_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_customer_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["plan_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["plan_overrides"] = basetypes.ObjectType{
		AttrTypes: PlanOverridesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["subscription_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.BillingTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billing_time"] = val

		val, err = v.EndingAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ending_at"] = val

		val, err = v.ExternalCustomerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_customer_id"] = val

		val, err = v.ExternalId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PlanCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan_code"] = val

		val, err = v.PlanOverrides.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan_overrides"] = val

		val, err = v.SubscriptionAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subscription_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SubscriptionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SubscriptionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SubscriptionValue) String() string {
	return "SubscriptionValue"
}

func (v SubscriptionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var planOverrides basetypes.ObjectValue

	if v.PlanOverrides.IsNull() {
		planOverrides = types.ObjectNull(
			PlanOverridesValue{}.AttributeTypes(ctx),
		)
	}

	if v.PlanOverrides.IsUnknown() {
		planOverrides = types.ObjectUnknown(
			PlanOverridesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PlanOverrides.IsNull() && !v.PlanOverrides.IsUnknown() {
		planOverrides = types.ObjectValueMust(
			PlanOverridesValue{}.AttributeTypes(ctx),
			v.PlanOverrides.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"billing_time":         basetypes.StringType{},
		"ending_at":            basetypes.StringType{},
		"external_customer_id": basetypes.StringType{},
		"external_id":          basetypes.StringType{},
		"name":                 basetypes.StringType{},
		"plan_code":            basetypes.StringType{},
		"plan_overrides": basetypes.ObjectType{
			AttrTypes: PlanOverridesValue{}.AttributeTypes(ctx),
		},
		"subscription_at": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"billing_time":         v.BillingTime,
			"ending_at":            v.EndingAt,
			"external_customer_id": v.ExternalCustomerId,
			"external_id":          v.ExternalId,
			"name":                 v.Name,
			"plan_code":            v.PlanCode,
			"plan_overrides":       planOverrides,
			"subscription_at":      v.SubscriptionAt,
		})

	return objVal, diags
}

func (v SubscriptionValue) Equal(o attr.Value) bool {
	other, ok := o.(SubscriptionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BillingTime.Equal(other.BillingTime) {
		return false
	}

	if !v.EndingAt.Equal(other.EndingAt) {
		return false
	}

	if !v.ExternalCustomerId.Equal(other.ExternalCustomerId) {
		return false
	}

	if !v.ExternalId.Equal(other.ExternalId) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PlanCode.Equal(other.PlanCode) {
		return false
	}

	if !v.PlanOverrides.Equal(other.PlanOverrides) {
		return false
	}

	if !v.SubscriptionAt.Equal(other.SubscriptionAt) {
		return false
	}

	return true
}

func (v SubscriptionValue) Type(ctx context.Context) attr.Type {
	return SubscriptionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SubscriptionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"billing_time":         basetypes.StringType{},
		"ending_at":            basetypes.StringType{},
		"external_customer_id": basetypes.StringType{},
		"external_id":          basetypes.StringType{},
		"name":                 basetypes.StringType{},
		"plan_code":            basetypes.StringType{},
		"plan_overrides": basetypes.ObjectType{
			AttrTypes: PlanOverridesValue{}.AttributeTypes(ctx),
		},
		"subscription_at": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PlanOverridesType{}

type PlanOverridesType struct {
	basetypes.ObjectType
}

func (t PlanOverridesType) Equal(o attr.Type) bool {
	other, ok := o.(PlanOverridesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PlanOverridesType) String() string {
	return "PlanOverridesType"
}

func (t PlanOverridesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return nil, diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	chargesAttribute, ok := attributes["charges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`charges is missing from object`)

		return nil, diags
	}

	chargesVal, ok := chargesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`charges expected to be basetypes.ListValue, was: %T`, chargesAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	minimumCommitmentAttribute, ok := attributes["minimum_commitment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_commitment is missing from object`)

		return nil, diags
	}

	minimumCommitmentVal, ok := minimumCommitmentAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_commitment expected to be basetypes.ObjectValue, was: %T`, minimumCommitmentAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return nil, diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	trialPeriodAttribute, ok := attributes["trial_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trial_period is missing from object`)

		return nil, diags
	}

	trialPeriodVal, ok := trialPeriodAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trial_period expected to be basetypes.NumberValue, was: %T`, trialPeriodAttribute))
	}

	usageThresholdsAttribute, ok := attributes["usage_thresholds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage_thresholds is missing from object`)

		return nil, diags
	}

	usageThresholdsVal, ok := usageThresholdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage_thresholds expected to be basetypes.ListValue, was: %T`, usageThresholdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PlanOverridesValue{
		AmountCents:        amountCentsVal,
		AmountCurrency:     amountCurrencyVal,
		Charges:            chargesVal,
		Description:        descriptionVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		MinimumCommitment:  minimumCommitmentVal,
		Name:               nameVal,
		TaxCodes:           taxCodesVal,
		TrialPeriod:        trialPeriodVal,
		UsageThresholds:    usageThresholdsVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPlanOverridesValueNull() PlanOverridesValue {
	return PlanOverridesValue{
		state: attr.ValueStateNull,
	}
}

func NewPlanOverridesValueUnknown() PlanOverridesValue {
	return PlanOverridesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPlanOverridesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PlanOverridesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PlanOverridesValue Attribute Value",
				"While creating a PlanOverridesValue value, a missing attribute value was detected. "+
					"A PlanOverridesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanOverridesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PlanOverridesValue Attribute Type",
				"While creating a PlanOverridesValue value, an invalid attribute value was detected. "+
					"A PlanOverridesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanOverridesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PlanOverridesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PlanOverridesValue Attribute Value",
				"While creating a PlanOverridesValue value, an extra attribute value was detected. "+
					"A PlanOverridesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PlanOverridesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlanOverridesValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewPlanOverridesValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return NewPlanOverridesValueUnknown(), diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	chargesAttribute, ok := attributes["charges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`charges is missing from object`)

		return NewPlanOverridesValueUnknown(), diags
	}

	chargesVal, ok := chargesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`charges expected to be basetypes.ListValue, was: %T`, chargesAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPlanOverridesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewPlanOverridesValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	minimumCommitmentAttribute, ok := attributes["minimum_commitment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_commitment is missing from object`)

		return NewPlanOverridesValueUnknown(), diags
	}

	minimumCommitmentVal, ok := minimumCommitmentAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_commitment expected to be basetypes.ObjectValue, was: %T`, minimumCommitmentAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPlanOverridesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return NewPlanOverridesValueUnknown(), diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	trialPeriodAttribute, ok := attributes["trial_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trial_period is missing from object`)

		return NewPlanOverridesValueUnknown(), diags
	}

	trialPeriodVal, ok := trialPeriodAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trial_period expected to be basetypes.NumberValue, was: %T`, trialPeriodAttribute))
	}

	usageThresholdsAttribute, ok := attributes["usage_thresholds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage_thresholds is missing from object`)

		return NewPlanOverridesValueUnknown(), diags
	}

	usageThresholdsVal, ok := usageThresholdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage_thresholds expected to be basetypes.ListValue, was: %T`, usageThresholdsAttribute))
	}

	if diags.HasError() {
		return NewPlanOverridesValueUnknown(), diags
	}

	return PlanOverridesValue{
		AmountCents:        amountCentsVal,
		AmountCurrency:     amountCurrencyVal,
		Charges:            chargesVal,
		Description:        descriptionVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		MinimumCommitment:  minimumCommitmentVal,
		Name:               nameVal,
		TaxCodes:           taxCodesVal,
		TrialPeriod:        trialPeriodVal,
		UsageThresholds:    usageThresholdsVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPlanOverridesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PlanOverridesValue {
	object, diags := NewPlanOverridesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlanOverridesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PlanOverridesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlanOverridesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlanOverridesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlanOverridesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlanOverridesValueMust(PlanOverridesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PlanOverridesType) ValueType(ctx context.Context) attr.Value {
	return PlanOverridesValue{}
}

var _ basetypes.ObjectValuable = PlanOverridesValue{}

type PlanOverridesValue struct {
	AmountCents        basetypes.Int64Value  `tfsdk:"amount_cents"`
	AmountCurrency     basetypes.StringValue `tfsdk:"amount_currency"`
	Charges            basetypes.ListValue   `tfsdk:"charges"`
	Description        basetypes.StringValue `tfsdk:"description"`
	InvoiceDisplayName basetypes.StringValue `tfsdk:"invoice_display_name"`
	MinimumCommitment  basetypes.ObjectValue `tfsdk:"minimum_commitment"`
	Name               basetypes.StringValue `tfsdk:"name"`
	TaxCodes           basetypes.ListValue   `tfsdk:"tax_codes"`
	TrialPeriod        basetypes.NumberValue `tfsdk:"trial_period"`
	UsageThresholds    basetypes.ListValue   `tfsdk:"usage_thresholds"`
	state              attr.ValueState
}

func (v PlanOverridesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["amount_currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["charges"] = basetypes.ListType{
		ElemType: ChargesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["minimum_commitment"] = basetypes.ObjectType{
		AttrTypes: MinimumCommitmentValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tax_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["trial_period"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["usage_thresholds"] = basetypes.ListType{
		ElemType: UsageThresholdsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.AmountCurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_currency"] = val

		val, err = v.Charges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["charges"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.MinimumCommitment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimum_commitment"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.TaxCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_codes"] = val

		val, err = v.TrialPeriod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trial_period"] = val

		val, err = v.UsageThresholds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage_thresholds"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PlanOverridesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PlanOverridesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PlanOverridesValue) String() string {
	return "PlanOverridesValue"
}

func (v PlanOverridesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	charges := types.ListValueMust(
		ChargesType{
			basetypes.ObjectType{
				AttrTypes: ChargesValue{}.AttributeTypes(ctx),
			},
		},
		v.Charges.Elements(),
	)

	if v.Charges.IsNull() {
		charges = types.ListNull(
			ChargesType{
				basetypes.ObjectType{
					AttrTypes: ChargesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Charges.IsUnknown() {
		charges = types.ListUnknown(
			ChargesType{
				basetypes.ObjectType{
					AttrTypes: ChargesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var minimumCommitment basetypes.ObjectValue

	if v.MinimumCommitment.IsNull() {
		minimumCommitment = types.ObjectNull(
			MinimumCommitmentValue{}.AttributeTypes(ctx),
		)
	}

	if v.MinimumCommitment.IsUnknown() {
		minimumCommitment = types.ObjectUnknown(
			MinimumCommitmentValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MinimumCommitment.IsNull() && !v.MinimumCommitment.IsUnknown() {
		minimumCommitment = types.ObjectValueMust(
			MinimumCommitmentValue{}.AttributeTypes(ctx),
			v.MinimumCommitment.Attributes(),
		)
	}

	usageThresholds := types.ListValueMust(
		UsageThresholdsType{
			basetypes.ObjectType{
				AttrTypes: UsageThresholdsValue{}.AttributeTypes(ctx),
			},
		},
		v.UsageThresholds.Elements(),
	)

	if v.UsageThresholds.IsNull() {
		usageThresholds = types.ListNull(
			UsageThresholdsType{
				basetypes.ObjectType{
					AttrTypes: UsageThresholdsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.UsageThresholds.IsUnknown() {
		usageThresholds = types.ListUnknown(
			UsageThresholdsType{
				basetypes.ObjectType{
					AttrTypes: UsageThresholdsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var taxCodesVal basetypes.ListValue
	switch {
	case v.TaxCodes.IsUnknown():
		taxCodesVal = types.ListUnknown(types.StringType)
	case v.TaxCodes.IsNull():
		taxCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		taxCodesVal, d = types.ListValue(types.StringType, v.TaxCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount_cents":    basetypes.Int64Type{},
			"amount_currency": basetypes.StringType{},
			"charges": basetypes.ListType{
				ElemType: ChargesValue{}.Type(ctx),
			},
			"description":          basetypes.StringType{},
			"invoice_display_name": basetypes.StringType{},
			"minimum_commitment": basetypes.ObjectType{
				AttrTypes: MinimumCommitmentValue{}.AttributeTypes(ctx),
			},
			"name": basetypes.StringType{},
			"tax_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"trial_period": basetypes.NumberType{},
			"usage_thresholds": basetypes.ListType{
				ElemType: UsageThresholdsValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"charges": basetypes.ListType{
			ElemType: ChargesValue{}.Type(ctx),
		},
		"description":          basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"minimum_commitment": basetypes.ObjectType{
			AttrTypes: MinimumCommitmentValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"trial_period": basetypes.NumberType{},
		"usage_thresholds": basetypes.ListType{
			ElemType: UsageThresholdsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":         v.AmountCents,
			"amount_currency":      v.AmountCurrency,
			"charges":              charges,
			"description":          v.Description,
			"invoice_display_name": v.InvoiceDisplayName,
			"minimum_commitment":   minimumCommitment,
			"name":                 v.Name,
			"tax_codes":            taxCodesVal,
			"trial_period":         v.TrialPeriod,
			"usage_thresholds":     usageThresholds,
		})

	return objVal, diags
}

func (v PlanOverridesValue) Equal(o attr.Value) bool {
	other, ok := o.(PlanOverridesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.AmountCurrency.Equal(other.AmountCurrency) {
		return false
	}

	if !v.Charges.Equal(other.Charges) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.MinimumCommitment.Equal(other.MinimumCommitment) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.TaxCodes.Equal(other.TaxCodes) {
		return false
	}

	if !v.TrialPeriod.Equal(other.TrialPeriod) {
		return false
	}

	if !v.UsageThresholds.Equal(other.UsageThresholds) {
		return false
	}

	return true
}

func (v PlanOverridesValue) Type(ctx context.Context) attr.Type {
	return PlanOverridesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PlanOverridesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"charges": basetypes.ListType{
			ElemType: ChargesValue{}.Type(ctx),
		},
		"description":          basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"minimum_commitment": basetypes.ObjectType{
			AttrTypes: MinimumCommitmentValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"trial_period": basetypes.NumberType{},
		"usage_thresholds": basetypes.ListType{
			ElemType: UsageThresholdsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ChargesType{}

type ChargesType struct {
	basetypes.ObjectType
}

func (t ChargesType) Equal(o attr.Type) bool {
	other, ok := o.(ChargesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ChargesType) String() string {
	return "ChargesType"
}

func (t ChargesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	billableMetricIdAttribute, ok := attributes["billable_metric_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable_metric_id is missing from object`)

		return nil, diags
	}

	billableMetricIdVal, ok := billableMetricIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable_metric_id expected to be basetypes.StringValue, was: %T`, billableMetricIdAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	minAmountCentsAttribute, ok := attributes["min_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_amount_cents is missing from object`)

		return nil, diags
	}

	minAmountCentsVal, ok := minAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_amount_cents expected to be basetypes.Int64Value, was: %T`, minAmountCentsAttribute))
	}

	propertiesAttribute, ok := attributes["properties"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`properties is missing from object`)

		return nil, diags
	}

	propertiesVal, ok := propertiesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`properties expected to be basetypes.ObjectValue, was: %T`, propertiesAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return nil, diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ChargesValue{
		BillableMetricId:   billableMetricIdVal,
		Filters:            filtersVal,
		Id:                 idVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		MinAmountCents:     minAmountCentsVal,
		Properties:         propertiesVal,
		TaxCodes:           taxCodesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewChargesValueNull() ChargesValue {
	return ChargesValue{
		state: attr.ValueStateNull,
	}
}

func NewChargesValueUnknown() ChargesValue {
	return ChargesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewChargesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ChargesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ChargesValue Attribute Value",
				"While creating a ChargesValue value, a missing attribute value was detected. "+
					"A ChargesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChargesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ChargesValue Attribute Type",
				"While creating a ChargesValue value, an invalid attribute value was detected. "+
					"A ChargesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChargesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ChargesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ChargesValue Attribute Value",
				"While creating a ChargesValue value, an extra attribute value was detected. "+
					"A ChargesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ChargesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewChargesValueUnknown(), diags
	}

	billableMetricIdAttribute, ok := attributes["billable_metric_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable_metric_id is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	billableMetricIdVal, ok := billableMetricIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable_metric_id expected to be basetypes.StringValue, was: %T`, billableMetricIdAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	minAmountCentsAttribute, ok := attributes["min_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_amount_cents is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	minAmountCentsVal, ok := minAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_amount_cents expected to be basetypes.Int64Value, was: %T`, minAmountCentsAttribute))
	}

	propertiesAttribute, ok := attributes["properties"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`properties is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	propertiesVal, ok := propertiesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`properties expected to be basetypes.ObjectValue, was: %T`, propertiesAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	if diags.HasError() {
		return NewChargesValueUnknown(), diags
	}

	return ChargesValue{
		BillableMetricId:   billableMetricIdVal,
		Filters:            filtersVal,
		Id:                 idVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		MinAmountCents:     minAmountCentsVal,
		Properties:         propertiesVal,
		TaxCodes:           taxCodesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewChargesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ChargesValue {
	object, diags := NewChargesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewChargesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ChargesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewChargesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewChargesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewChargesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewChargesValueMust(ChargesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ChargesType) ValueType(ctx context.Context) attr.Value {
	return ChargesValue{}
}

var _ basetypes.ObjectValuable = ChargesValue{}

type ChargesValue struct {
	BillableMetricId   basetypes.StringValue `tfsdk:"billable_metric_id"`
	Filters            basetypes.ListValue   `tfsdk:"filters"`
	Id                 basetypes.StringValue `tfsdk:"id"`
	InvoiceDisplayName basetypes.StringValue `tfsdk:"invoice_display_name"`
	MinAmountCents     basetypes.Int64Value  `tfsdk:"min_amount_cents"`
	Properties         basetypes.ObjectValue `tfsdk:"properties"`
	TaxCodes           basetypes.ListValue   `tfsdk:"tax_codes"`
	state              attr.ValueState
}

func (v ChargesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["billable_metric_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["filters"] = basetypes.ListType{
		ElemType: FiltersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["min_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["properties"] = basetypes.ObjectType{
		AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["tax_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.BillableMetricId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billable_metric_id"] = val

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.MinAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_amount_cents"] = val

		val, err = v.Properties.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["properties"] = val

		val, err = v.TaxCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_codes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ChargesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ChargesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ChargesValue) String() string {
	return "ChargesValue"
}

func (v ChargesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	filters := types.ListValueMust(
		FiltersType{
			basetypes.ObjectType{
				AttrTypes: FiltersValue{}.AttributeTypes(ctx),
			},
		},
		v.Filters.Elements(),
	)

	if v.Filters.IsNull() {
		filters = types.ListNull(
			FiltersType{
				basetypes.ObjectType{
					AttrTypes: FiltersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Filters.IsUnknown() {
		filters = types.ListUnknown(
			FiltersType{
				basetypes.ObjectType{
					AttrTypes: FiltersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var properties basetypes.ObjectValue

	if v.Properties.IsNull() {
		properties = types.ObjectNull(
			PropertiesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Properties.IsUnknown() {
		properties = types.ObjectUnknown(
			PropertiesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Properties.IsNull() && !v.Properties.IsUnknown() {
		properties = types.ObjectValueMust(
			PropertiesValue{}.AttributeTypes(ctx),
			v.Properties.Attributes(),
		)
	}

	var taxCodesVal basetypes.ListValue
	switch {
	case v.TaxCodes.IsUnknown():
		taxCodesVal = types.ListUnknown(types.StringType)
	case v.TaxCodes.IsNull():
		taxCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		taxCodesVal, d = types.ListValue(types.StringType, v.TaxCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"billable_metric_id": basetypes.StringType{},
			"filters": basetypes.ListType{
				ElemType: FiltersValue{}.Type(ctx),
			},
			"id":                   basetypes.StringType{},
			"invoice_display_name": basetypes.StringType{},
			"min_amount_cents":     basetypes.Int64Type{},
			"properties": basetypes.ObjectType{
				AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
			},
			"tax_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"billable_metric_id": basetypes.StringType{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"id":                   basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"min_amount_cents":     basetypes.Int64Type{},
		"properties": basetypes.ObjectType{
			AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
		},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"billable_metric_id":   v.BillableMetricId,
			"filters":              filters,
			"id":                   v.Id,
			"invoice_display_name": v.InvoiceDisplayName,
			"min_amount_cents":     v.MinAmountCents,
			"properties":           properties,
			"tax_codes":            taxCodesVal,
		})

	return objVal, diags
}

func (v ChargesValue) Equal(o attr.Value) bool {
	other, ok := o.(ChargesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BillableMetricId.Equal(other.BillableMetricId) {
		return false
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.MinAmountCents.Equal(other.MinAmountCents) {
		return false
	}

	if !v.Properties.Equal(other.Properties) {
		return false
	}

	if !v.TaxCodes.Equal(other.TaxCodes) {
		return false
	}

	return true
}

func (v ChargesValue) Type(ctx context.Context) attr.Type {
	return ChargesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ChargesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"billable_metric_id": basetypes.StringType{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"id":                   basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"min_amount_cents":     basetypes.Int64Type{},
		"properties": basetypes.ObjectType{
			AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
		},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = FiltersType{}

type FiltersType struct {
	basetypes.ObjectType
}

func (t FiltersType) Equal(o attr.Type) bool {
	other, ok := o.(FiltersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FiltersType) String() string {
	return "FiltersType"
}

func (t FiltersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	propertiesAttribute, ok := attributes["properties"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`properties is missing from object`)

		return nil, diags
	}

	propertiesVal, ok := propertiesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`properties expected to be basetypes.ObjectValue, was: %T`, propertiesAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.MapValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FiltersValue{
		InvoiceDisplayName: invoiceDisplayNameVal,
		Properties:         propertiesVal,
		Values:             valuesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueNull() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateNull,
	}
}

func NewFiltersValueUnknown() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFiltersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FiltersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FiltersValue Attribute Value",
				"While creating a FiltersValue value, a missing attribute value was detected. "+
					"A FiltersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FiltersValue Attribute Type",
				"While creating a FiltersValue value, an invalid attribute value was detected. "+
					"A FiltersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FiltersValue Attribute Value",
				"While creating a FiltersValue value, an extra attribute value was detected. "+
					"A FiltersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FiltersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	propertiesAttribute, ok := attributes["properties"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`properties is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	propertiesVal, ok := propertiesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`properties expected to be basetypes.ObjectValue, was: %T`, propertiesAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.MapValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	return FiltersValue{
		InvoiceDisplayName: invoiceDisplayNameVal,
		Properties:         propertiesVal,
		Values:             valuesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FiltersValue {
	object, diags := NewFiltersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFiltersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FiltersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFiltersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFiltersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFiltersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFiltersValueMust(FiltersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FiltersType) ValueType(ctx context.Context) attr.Value {
	return FiltersValue{}
}

var _ basetypes.ObjectValuable = FiltersValue{}

type FiltersValue struct {
	InvoiceDisplayName basetypes.StringValue `tfsdk:"invoice_display_name"`
	Properties         basetypes.ObjectValue `tfsdk:"properties"`
	Values             basetypes.MapValue    `tfsdk:"values"`
	state              attr.ValueState
}

func (v FiltersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["properties"] = basetypes.ObjectType{
		AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["values"] = basetypes.MapType{
		ElemType: types.ListType{
			ElemType: types.StringType,
		},
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.Properties.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["properties"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FiltersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FiltersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FiltersValue) String() string {
	return "FiltersValue"
}

func (v FiltersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var properties basetypes.ObjectValue

	if v.Properties.IsNull() {
		properties = types.ObjectNull(
			PropertiesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Properties.IsUnknown() {
		properties = types.ObjectUnknown(
			PropertiesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Properties.IsNull() && !v.Properties.IsUnknown() {
		properties = types.ObjectValueMust(
			PropertiesValue{}.AttributeTypes(ctx),
			v.Properties.Attributes(),
		)
	}

	var valuesVal basetypes.MapValue
	switch {
	case v.Values.IsUnknown():
		valuesVal = types.MapUnknown(types.ListType{
			ElemType: types.StringType,
		})
	case v.Values.IsNull():
		valuesVal = types.MapNull(types.ListType{
			ElemType: types.StringType,
		})
	default:
		var d diag.Diagnostics
		valuesVal, d = types.MapValue(types.ListType{
			ElemType: types.StringType,
		}, v.Values.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"invoice_display_name": basetypes.StringType{},
			"properties": basetypes.ObjectType{
				AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
			},
			"values": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"invoice_display_name": basetypes.StringType{},
		"properties": basetypes.ObjectType{
			AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
		},
		"values": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"invoice_display_name": v.InvoiceDisplayName,
			"properties":           properties,
			"values":               valuesVal,
		})

	return objVal, diags
}

func (v FiltersValue) Equal(o attr.Value) bool {
	other, ok := o.(FiltersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.Properties.Equal(other.Properties) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v FiltersValue) Type(ctx context.Context) attr.Type {
	return FiltersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FiltersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"invoice_display_name": basetypes.StringType{},
		"properties": basetypes.ObjectType{
			AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
		},
		"values": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

var _ basetypes.ObjectTypable = PropertiesType{}

type PropertiesType struct {
	basetypes.ObjectType
}

func (t PropertiesType) Equal(o attr.Type) bool {
	other, ok := o.(PropertiesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PropertiesType) String() string {
	return "PropertiesType"
}

func (t PropertiesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountAttribute, ok := attributes["amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount is missing from object`)

		return nil, diags
	}

	amountVal, ok := amountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount expected to be basetypes.StringValue, was: %T`, amountAttribute))
	}

	fixedAmountAttribute, ok := attributes["fixed_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_amount is missing from object`)

		return nil, diags
	}

	fixedAmountVal, ok := fixedAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_amount expected to be basetypes.StringValue, was: %T`, fixedAmountAttribute))
	}

	freeUnitsAttribute, ok := attributes["free_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units is missing from object`)

		return nil, diags
	}

	freeUnitsVal, ok := freeUnitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units expected to be basetypes.Int64Value, was: %T`, freeUnitsAttribute))
	}

	freeUnitsPerEventsAttribute, ok := attributes["free_units_per_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_events is missing from object`)

		return nil, diags
	}

	freeUnitsPerEventsVal, ok := freeUnitsPerEventsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_events expected to be basetypes.Int64Value, was: %T`, freeUnitsPerEventsAttribute))
	}

	freeUnitsPerTotalAggregationAttribute, ok := attributes["free_units_per_total_aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_total_aggregation is missing from object`)

		return nil, diags
	}

	freeUnitsPerTotalAggregationVal, ok := freeUnitsPerTotalAggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_total_aggregation expected to be basetypes.StringValue, was: %T`, freeUnitsPerTotalAggregationAttribute))
	}

	graduatedPercentageRangesAttribute, ok := attributes["graduated_percentage_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_percentage_ranges is missing from object`)

		return nil, diags
	}

	graduatedPercentageRangesVal, ok := graduatedPercentageRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_percentage_ranges expected to be basetypes.ListValue, was: %T`, graduatedPercentageRangesAttribute))
	}

	graduatedRangesAttribute, ok := attributes["graduated_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_ranges is missing from object`)

		return nil, diags
	}

	graduatedRangesVal, ok := graduatedRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_ranges expected to be basetypes.ListValue, was: %T`, graduatedRangesAttribute))
	}

	groupedByAttribute, ok := attributes["grouped_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_by is missing from object`)

		return nil, diags
	}

	groupedByVal, ok := groupedByAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_by expected to be basetypes.ListValue, was: %T`, groupedByAttribute))
	}

	packageSizeAttribute, ok := attributes["package_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_size is missing from object`)

		return nil, diags
	}

	packageSizeVal, ok := packageSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_size expected to be basetypes.Int64Value, was: %T`, packageSizeAttribute))
	}

	perTransactionMaxAmountAttribute, ok := attributes["per_transaction_max_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_max_amount is missing from object`)

		return nil, diags
	}

	perTransactionMaxAmountVal, ok := perTransactionMaxAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_max_amount expected to be basetypes.StringValue, was: %T`, perTransactionMaxAmountAttribute))
	}

	perTransactionMinAmountAttribute, ok := attributes["per_transaction_min_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_min_amount is missing from object`)

		return nil, diags
	}

	perTransactionMinAmountVal, ok := perTransactionMinAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_min_amount expected to be basetypes.StringValue, was: %T`, perTransactionMinAmountAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	volumeRangesAttribute, ok := attributes["volume_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_ranges is missing from object`)

		return nil, diags
	}

	volumeRangesVal, ok := volumeRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_ranges expected to be basetypes.ListValue, was: %T`, volumeRangesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PropertiesValue{
		Amount:                       amountVal,
		FixedAmount:                  fixedAmountVal,
		FreeUnits:                    freeUnitsVal,
		FreeUnitsPerEvents:           freeUnitsPerEventsVal,
		FreeUnitsPerTotalAggregation: freeUnitsPerTotalAggregationVal,
		GraduatedPercentageRanges:    graduatedPercentageRangesVal,
		GraduatedRanges:              graduatedRangesVal,
		GroupedBy:                    groupedByVal,
		PackageSize:                  packageSizeVal,
		PerTransactionMaxAmount:      perTransactionMaxAmountVal,
		PerTransactionMinAmount:      perTransactionMinAmountVal,
		Rate:                         rateVal,
		VolumeRanges:                 volumeRangesVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewPropertiesValueNull() PropertiesValue {
	return PropertiesValue{
		state: attr.ValueStateNull,
	}
}

func NewPropertiesValueUnknown() PropertiesValue {
	return PropertiesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPropertiesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PropertiesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PropertiesValue Attribute Value",
				"While creating a PropertiesValue value, a missing attribute value was detected. "+
					"A PropertiesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PropertiesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PropertiesValue Attribute Type",
				"While creating a PropertiesValue value, an invalid attribute value was detected. "+
					"A PropertiesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PropertiesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PropertiesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PropertiesValue Attribute Value",
				"While creating a PropertiesValue value, an extra attribute value was detected. "+
					"A PropertiesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PropertiesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPropertiesValueUnknown(), diags
	}

	amountAttribute, ok := attributes["amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	amountVal, ok := amountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount expected to be basetypes.StringValue, was: %T`, amountAttribute))
	}

	fixedAmountAttribute, ok := attributes["fixed_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	fixedAmountVal, ok := fixedAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_amount expected to be basetypes.StringValue, was: %T`, fixedAmountAttribute))
	}

	freeUnitsAttribute, ok := attributes["free_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	freeUnitsVal, ok := freeUnitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units expected to be basetypes.Int64Value, was: %T`, freeUnitsAttribute))
	}

	freeUnitsPerEventsAttribute, ok := attributes["free_units_per_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_events is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	freeUnitsPerEventsVal, ok := freeUnitsPerEventsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_events expected to be basetypes.Int64Value, was: %T`, freeUnitsPerEventsAttribute))
	}

	freeUnitsPerTotalAggregationAttribute, ok := attributes["free_units_per_total_aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_total_aggregation is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	freeUnitsPerTotalAggregationVal, ok := freeUnitsPerTotalAggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_total_aggregation expected to be basetypes.StringValue, was: %T`, freeUnitsPerTotalAggregationAttribute))
	}

	graduatedPercentageRangesAttribute, ok := attributes["graduated_percentage_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_percentage_ranges is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	graduatedPercentageRangesVal, ok := graduatedPercentageRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_percentage_ranges expected to be basetypes.ListValue, was: %T`, graduatedPercentageRangesAttribute))
	}

	graduatedRangesAttribute, ok := attributes["graduated_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_ranges is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	graduatedRangesVal, ok := graduatedRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_ranges expected to be basetypes.ListValue, was: %T`, graduatedRangesAttribute))
	}

	groupedByAttribute, ok := attributes["grouped_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_by is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	groupedByVal, ok := groupedByAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_by expected to be basetypes.ListValue, was: %T`, groupedByAttribute))
	}

	packageSizeAttribute, ok := attributes["package_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_size is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	packageSizeVal, ok := packageSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_size expected to be basetypes.Int64Value, was: %T`, packageSizeAttribute))
	}

	perTransactionMaxAmountAttribute, ok := attributes["per_transaction_max_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_max_amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	perTransactionMaxAmountVal, ok := perTransactionMaxAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_max_amount expected to be basetypes.StringValue, was: %T`, perTransactionMaxAmountAttribute))
	}

	perTransactionMinAmountAttribute, ok := attributes["per_transaction_min_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_min_amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	perTransactionMinAmountVal, ok := perTransactionMinAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_min_amount expected to be basetypes.StringValue, was: %T`, perTransactionMinAmountAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	volumeRangesAttribute, ok := attributes["volume_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_ranges is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	volumeRangesVal, ok := volumeRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_ranges expected to be basetypes.ListValue, was: %T`, volumeRangesAttribute))
	}

	if diags.HasError() {
		return NewPropertiesValueUnknown(), diags
	}

	return PropertiesValue{
		Amount:                       amountVal,
		FixedAmount:                  fixedAmountVal,
		FreeUnits:                    freeUnitsVal,
		FreeUnitsPerEvents:           freeUnitsPerEventsVal,
		FreeUnitsPerTotalAggregation: freeUnitsPerTotalAggregationVal,
		GraduatedPercentageRanges:    graduatedPercentageRangesVal,
		GraduatedRanges:              graduatedRangesVal,
		GroupedBy:                    groupedByVal,
		PackageSize:                  packageSizeVal,
		PerTransactionMaxAmount:      perTransactionMaxAmountVal,
		PerTransactionMinAmount:      perTransactionMinAmountVal,
		Rate:                         rateVal,
		VolumeRanges:                 volumeRangesVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewPropertiesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PropertiesValue {
	object, diags := NewPropertiesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPropertiesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PropertiesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPropertiesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPropertiesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPropertiesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPropertiesValueMust(PropertiesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PropertiesType) ValueType(ctx context.Context) attr.Value {
	return PropertiesValue{}
}

var _ basetypes.ObjectValuable = PropertiesValue{}

type PropertiesValue struct {
	Amount                       basetypes.StringValue `tfsdk:"amount"`
	FixedAmount                  basetypes.StringValue `tfsdk:"fixed_amount"`
	FreeUnits                    basetypes.Int64Value  `tfsdk:"free_units"`
	FreeUnitsPerEvents           basetypes.Int64Value  `tfsdk:"free_units_per_events"`
	FreeUnitsPerTotalAggregation basetypes.StringValue `tfsdk:"free_units_per_total_aggregation"`
	GraduatedPercentageRanges    basetypes.ListValue   `tfsdk:"graduated_percentage_ranges"`
	GraduatedRanges              basetypes.ListValue   `tfsdk:"graduated_ranges"`
	GroupedBy                    basetypes.ListValue   `tfsdk:"grouped_by"`
	PackageSize                  basetypes.Int64Value  `tfsdk:"package_size"`
	PerTransactionMaxAmount      basetypes.StringValue `tfsdk:"per_transaction_max_amount"`
	PerTransactionMinAmount      basetypes.StringValue `tfsdk:"per_transaction_min_amount"`
	Rate                         basetypes.StringValue `tfsdk:"rate"`
	VolumeRanges                 basetypes.ListValue   `tfsdk:"volume_ranges"`
	state                        attr.ValueState
}

func (v PropertiesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fixed_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["free_units"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["free_units_per_events"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["free_units_per_total_aggregation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["graduated_percentage_ranges"] = basetypes.ListType{
		ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["graduated_ranges"] = basetypes.ListType{
		ElemType: GraduatedRangesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["grouped_by"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["package_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_transaction_max_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["per_transaction_min_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_ranges"] = basetypes.ListType{
		ElemType: VolumeRangesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.Amount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount"] = val

		val, err = v.FixedAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_amount"] = val

		val, err = v.FreeUnits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units"] = val

		val, err = v.FreeUnitsPerEvents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units_per_events"] = val

		val, err = v.FreeUnitsPerTotalAggregation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units_per_total_aggregation"] = val

		val, err = v.GraduatedPercentageRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["graduated_percentage_ranges"] = val

		val, err = v.GraduatedRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["graduated_ranges"] = val

		val, err = v.GroupedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["grouped_by"] = val

		val, err = v.PackageSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["package_size"] = val

		val, err = v.PerTransactionMaxAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_transaction_max_amount"] = val

		val, err = v.PerTransactionMinAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_transaction_min_amount"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		val, err = v.VolumeRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_ranges"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PropertiesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PropertiesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PropertiesValue) String() string {
	return "PropertiesValue"
}

func (v PropertiesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	graduatedPercentageRanges := types.ListValueMust(
		GraduatedPercentageRangesType{
			basetypes.ObjectType{
				AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.GraduatedPercentageRanges.Elements(),
	)

	if v.GraduatedPercentageRanges.IsNull() {
		graduatedPercentageRanges = types.ListNull(
			GraduatedPercentageRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.GraduatedPercentageRanges.IsUnknown() {
		graduatedPercentageRanges = types.ListUnknown(
			GraduatedPercentageRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	graduatedRanges := types.ListValueMust(
		GraduatedRangesType{
			basetypes.ObjectType{
				AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.GraduatedRanges.Elements(),
	)

	if v.GraduatedRanges.IsNull() {
		graduatedRanges = types.ListNull(
			GraduatedRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.GraduatedRanges.IsUnknown() {
		graduatedRanges = types.ListUnknown(
			GraduatedRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	volumeRanges := types.ListValueMust(
		VolumeRangesType{
			basetypes.ObjectType{
				AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.VolumeRanges.Elements(),
	)

	if v.VolumeRanges.IsNull() {
		volumeRanges = types.ListNull(
			VolumeRangesType{
				basetypes.ObjectType{
					AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VolumeRanges.IsUnknown() {
		volumeRanges = types.ListUnknown(
			VolumeRangesType{
				basetypes.ObjectType{
					AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var groupedByVal basetypes.ListValue
	switch {
	case v.GroupedBy.IsUnknown():
		groupedByVal = types.ListUnknown(types.StringType)
	case v.GroupedBy.IsNull():
		groupedByVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		groupedByVal, d = types.ListValue(types.StringType, v.GroupedBy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount":                           basetypes.StringType{},
			"fixed_amount":                     basetypes.StringType{},
			"free_units":                       basetypes.Int64Type{},
			"free_units_per_events":            basetypes.Int64Type{},
			"free_units_per_total_aggregation": basetypes.StringType{},
			"graduated_percentage_ranges": basetypes.ListType{
				ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
			},
			"graduated_ranges": basetypes.ListType{
				ElemType: GraduatedRangesValue{}.Type(ctx),
			},
			"grouped_by": basetypes.ListType{
				ElemType: types.StringType,
			},
			"package_size":               basetypes.Int64Type{},
			"per_transaction_max_amount": basetypes.StringType{},
			"per_transaction_min_amount": basetypes.StringType{},
			"rate":                       basetypes.StringType{},
			"volume_ranges": basetypes.ListType{
				ElemType: VolumeRangesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount":                           basetypes.StringType{},
		"fixed_amount":                     basetypes.StringType{},
		"free_units":                       basetypes.Int64Type{},
		"free_units_per_events":            basetypes.Int64Type{},
		"free_units_per_total_aggregation": basetypes.StringType{},
		"graduated_percentage_ranges": basetypes.ListType{
			ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
		},
		"graduated_ranges": basetypes.ListType{
			ElemType: GraduatedRangesValue{}.Type(ctx),
		},
		"grouped_by": basetypes.ListType{
			ElemType: types.StringType,
		},
		"package_size":               basetypes.Int64Type{},
		"per_transaction_max_amount": basetypes.StringType{},
		"per_transaction_min_amount": basetypes.StringType{},
		"rate":                       basetypes.StringType{},
		"volume_ranges": basetypes.ListType{
			ElemType: VolumeRangesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount":                           v.Amount,
			"fixed_amount":                     v.FixedAmount,
			"free_units":                       v.FreeUnits,
			"free_units_per_events":            v.FreeUnitsPerEvents,
			"free_units_per_total_aggregation": v.FreeUnitsPerTotalAggregation,
			"graduated_percentage_ranges":      graduatedPercentageRanges,
			"graduated_ranges":                 graduatedRanges,
			"grouped_by":                       groupedByVal,
			"package_size":                     v.PackageSize,
			"per_transaction_max_amount":       v.PerTransactionMaxAmount,
			"per_transaction_min_amount":       v.PerTransactionMinAmount,
			"rate":                             v.Rate,
			"volume_ranges":                    volumeRanges,
		})

	return objVal, diags
}

func (v PropertiesValue) Equal(o attr.Value) bool {
	other, ok := o.(PropertiesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Amount.Equal(other.Amount) {
		return false
	}

	if !v.FixedAmount.Equal(other.FixedAmount) {
		return false
	}

	if !v.FreeUnits.Equal(other.FreeUnits) {
		return false
	}

	if !v.FreeUnitsPerEvents.Equal(other.FreeUnitsPerEvents) {
		return false
	}

	if !v.FreeUnitsPerTotalAggregation.Equal(other.FreeUnitsPerTotalAggregation) {
		return false
	}

	if !v.GraduatedPercentageRanges.Equal(other.GraduatedPercentageRanges) {
		return false
	}

	if !v.GraduatedRanges.Equal(other.GraduatedRanges) {
		return false
	}

	if !v.GroupedBy.Equal(other.GroupedBy) {
		return false
	}

	if !v.PackageSize.Equal(other.PackageSize) {
		return false
	}

	if !v.PerTransactionMaxAmount.Equal(other.PerTransactionMaxAmount) {
		return false
	}

	if !v.PerTransactionMinAmount.Equal(other.PerTransactionMinAmount) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	if !v.VolumeRanges.Equal(other.VolumeRanges) {
		return false
	}

	return true
}

func (v PropertiesValue) Type(ctx context.Context) attr.Type {
	return PropertiesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PropertiesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount":                           basetypes.StringType{},
		"fixed_amount":                     basetypes.StringType{},
		"free_units":                       basetypes.Int64Type{},
		"free_units_per_events":            basetypes.Int64Type{},
		"free_units_per_total_aggregation": basetypes.StringType{},
		"graduated_percentage_ranges": basetypes.ListType{
			ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
		},
		"graduated_ranges": basetypes.ListType{
			ElemType: GraduatedRangesValue{}.Type(ctx),
		},
		"grouped_by": basetypes.ListType{
			ElemType: types.StringType,
		},
		"package_size":               basetypes.Int64Type{},
		"per_transaction_max_amount": basetypes.StringType{},
		"per_transaction_min_amount": basetypes.StringType{},
		"rate":                       basetypes.StringType{},
		"volume_ranges": basetypes.ListType{
			ElemType: VolumeRangesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = GraduatedPercentageRangesType{}

type GraduatedPercentageRangesType struct {
	basetypes.ObjectType
}

func (t GraduatedPercentageRangesType) Equal(o attr.Type) bool {
	other, ok := o.(GraduatedPercentageRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GraduatedPercentageRangesType) String() string {
	return "GraduatedPercentageRangesType"
}

func (t GraduatedPercentageRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return nil, diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GraduatedPercentageRangesValue{
		FlatAmount: flatAmountVal,
		FromValue:  fromValueVal,
		Rate:       rateVal,
		ToValue:    toValueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewGraduatedPercentageRangesValueNull() GraduatedPercentageRangesValue {
	return GraduatedPercentageRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewGraduatedPercentageRangesValueUnknown() GraduatedPercentageRangesValue {
	return GraduatedPercentageRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGraduatedPercentageRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GraduatedPercentageRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GraduatedPercentageRangesValue Attribute Value",
				"While creating a GraduatedPercentageRangesValue value, a missing attribute value was detected. "+
					"A GraduatedPercentageRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GraduatedPercentageRangesValue Attribute Type",
				"While creating a GraduatedPercentageRangesValue value, an invalid attribute value was detected. "+
					"A GraduatedPercentageRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GraduatedPercentageRangesValue Attribute Value",
				"While creating a GraduatedPercentageRangesValue value, an extra attribute value was detected. "+
					"A GraduatedPercentageRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GraduatedPercentageRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	return GraduatedPercentageRangesValue{
		FlatAmount: flatAmountVal,
		FromValue:  fromValueVal,
		Rate:       rateVal,
		ToValue:    toValueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewGraduatedPercentageRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GraduatedPercentageRangesValue {
	object, diags := NewGraduatedPercentageRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGraduatedPercentageRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GraduatedPercentageRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGraduatedPercentageRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGraduatedPercentageRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGraduatedPercentageRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGraduatedPercentageRangesValueMust(GraduatedPercentageRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GraduatedPercentageRangesType) ValueType(ctx context.Context) attr.Value {
	return GraduatedPercentageRangesValue{}
}

var _ basetypes.ObjectValuable = GraduatedPercentageRangesValue{}

type GraduatedPercentageRangesValue struct {
	FlatAmount basetypes.StringValue `tfsdk:"flat_amount"`
	FromValue  basetypes.Int64Value  `tfsdk:"from_value"`
	Rate       basetypes.StringValue `tfsdk:"rate"`
	ToValue    basetypes.Int64Value  `tfsdk:"to_value"`
	state      attr.ValueState
}

func (v GraduatedPercentageRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GraduatedPercentageRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GraduatedPercentageRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GraduatedPercentageRangesValue) String() string {
	return "GraduatedPercentageRangesValue"
}

func (v GraduatedPercentageRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_amount": basetypes.StringType{},
		"from_value":  basetypes.Int64Type{},
		"rate":        basetypes.StringType{},
		"to_value":    basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_amount": v.FlatAmount,
			"from_value":  v.FromValue,
			"rate":        v.Rate,
			"to_value":    v.ToValue,
		})

	return objVal, diags
}

func (v GraduatedPercentageRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(GraduatedPercentageRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatAmount.Equal(other.FlatAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	return true
}

func (v GraduatedPercentageRangesValue) Type(ctx context.Context) attr.Type {
	return GraduatedPercentageRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GraduatedPercentageRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_amount": basetypes.StringType{},
		"from_value":  basetypes.Int64Type{},
		"rate":        basetypes.StringType{},
		"to_value":    basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = GraduatedRangesType{}

type GraduatedRangesType struct {
	basetypes.ObjectType
}

func (t GraduatedRangesType) Equal(o attr.Type) bool {
	other, ok := o.(GraduatedRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GraduatedRangesType) String() string {
	return "GraduatedRangesType"
}

func (t GraduatedRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return nil, diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return nil, diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GraduatedRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewGraduatedRangesValueNull() GraduatedRangesValue {
	return GraduatedRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewGraduatedRangesValueUnknown() GraduatedRangesValue {
	return GraduatedRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGraduatedRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GraduatedRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GraduatedRangesValue Attribute Value",
				"While creating a GraduatedRangesValue value, a missing attribute value was detected. "+
					"A GraduatedRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GraduatedRangesValue Attribute Type",
				"While creating a GraduatedRangesValue value, an invalid attribute value was detected. "+
					"A GraduatedRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GraduatedRangesValue Attribute Value",
				"While creating a GraduatedRangesValue value, an extra attribute value was detected. "+
					"A GraduatedRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GraduatedRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGraduatedRangesValueUnknown(), diags
	}

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return NewGraduatedRangesValueUnknown(), diags
	}

	return GraduatedRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewGraduatedRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GraduatedRangesValue {
	object, diags := NewGraduatedRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGraduatedRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GraduatedRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGraduatedRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGraduatedRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGraduatedRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGraduatedRangesValueMust(GraduatedRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GraduatedRangesType) ValueType(ctx context.Context) attr.Value {
	return GraduatedRangesValue{}
}

var _ basetypes.ObjectValuable = GraduatedRangesValue{}

type GraduatedRangesValue struct {
	FlatAmount    basetypes.StringValue `tfsdk:"flat_amount"`
	FromValue     basetypes.Int64Value  `tfsdk:"from_value"`
	PerUnitAmount basetypes.StringValue `tfsdk:"per_unit_amount"`
	ToValue       basetypes.Int64Value  `tfsdk:"to_value"`
	state         attr.ValueState
}

func (v GraduatedRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.PerUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_amount"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GraduatedRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GraduatedRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GraduatedRangesValue) String() string {
	return "GraduatedRangesValue"
}

func (v GraduatedRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_amount":     v.FlatAmount,
			"from_value":      v.FromValue,
			"per_unit_amount": v.PerUnitAmount,
			"to_value":        v.ToValue,
		})

	return objVal, diags
}

func (v GraduatedRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(GraduatedRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatAmount.Equal(other.FlatAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.PerUnitAmount.Equal(other.PerUnitAmount) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	return true
}

func (v GraduatedRangesValue) Type(ctx context.Context) attr.Type {
	return GraduatedRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GraduatedRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = VolumeRangesType{}

type VolumeRangesType struct {
	basetypes.ObjectType
}

func (t VolumeRangesType) Equal(o attr.Type) bool {
	other, ok := o.(VolumeRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumeRangesType) String() string {
	return "VolumeRangesType"
}

func (t VolumeRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return nil, diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return nil, diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumeRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewVolumeRangesValueNull() VolumeRangesValue {
	return VolumeRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumeRangesValueUnknown() VolumeRangesValue {
	return VolumeRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumeRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumeRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumeRangesValue Attribute Value",
				"While creating a VolumeRangesValue value, a missing attribute value was detected. "+
					"A VolumeRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumeRangesValue Attribute Type",
				"While creating a VolumeRangesValue value, an invalid attribute value was detected. "+
					"A VolumeRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumeRangesValue Attribute Value",
				"While creating a VolumeRangesValue value, an extra attribute value was detected. "+
					"A VolumeRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumeRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumeRangesValueUnknown(), diags
	}

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return NewVolumeRangesValueUnknown(), diags
	}

	return VolumeRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewVolumeRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumeRangesValue {
	object, diags := NewVolumeRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumeRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumeRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumeRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumeRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumeRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumeRangesValueMust(VolumeRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumeRangesType) ValueType(ctx context.Context) attr.Value {
	return VolumeRangesValue{}
}

var _ basetypes.ObjectValuable = VolumeRangesValue{}

type VolumeRangesValue struct {
	FlatAmount    basetypes.StringValue `tfsdk:"flat_amount"`
	FromValue     basetypes.Int64Value  `tfsdk:"from_value"`
	PerUnitAmount basetypes.StringValue `tfsdk:"per_unit_amount"`
	ToValue       basetypes.Int64Value  `tfsdk:"to_value"`
	state         attr.ValueState
}

func (v VolumeRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.PerUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_amount"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumeRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumeRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumeRangesValue) String() string {
	return "VolumeRangesValue"
}

func (v VolumeRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_amount":     v.FlatAmount,
			"from_value":      v.FromValue,
			"per_unit_amount": v.PerUnitAmount,
			"to_value":        v.ToValue,
		})

	return objVal, diags
}

func (v VolumeRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumeRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatAmount.Equal(other.FlatAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.PerUnitAmount.Equal(other.PerUnitAmount) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	return true
}

func (v VolumeRangesValue) Type(ctx context.Context) attr.Type {
	return VolumeRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumeRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PropertiesType{}

type PropertiesType struct {
	basetypes.ObjectType
}

func (t PropertiesType) Equal(o attr.Type) bool {
	other, ok := o.(PropertiesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PropertiesType) String() string {
	return "PropertiesType"
}

func (t PropertiesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountAttribute, ok := attributes["amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount is missing from object`)

		return nil, diags
	}

	amountVal, ok := amountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount expected to be basetypes.StringValue, was: %T`, amountAttribute))
	}

	fixedAmountAttribute, ok := attributes["fixed_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_amount is missing from object`)

		return nil, diags
	}

	fixedAmountVal, ok := fixedAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_amount expected to be basetypes.StringValue, was: %T`, fixedAmountAttribute))
	}

	freeUnitsAttribute, ok := attributes["free_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units is missing from object`)

		return nil, diags
	}

	freeUnitsVal, ok := freeUnitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units expected to be basetypes.Int64Value, was: %T`, freeUnitsAttribute))
	}

	freeUnitsPerEventsAttribute, ok := attributes["free_units_per_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_events is missing from object`)

		return nil, diags
	}

	freeUnitsPerEventsVal, ok := freeUnitsPerEventsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_events expected to be basetypes.Int64Value, was: %T`, freeUnitsPerEventsAttribute))
	}

	freeUnitsPerTotalAggregationAttribute, ok := attributes["free_units_per_total_aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_total_aggregation is missing from object`)

		return nil, diags
	}

	freeUnitsPerTotalAggregationVal, ok := freeUnitsPerTotalAggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_total_aggregation expected to be basetypes.StringValue, was: %T`, freeUnitsPerTotalAggregationAttribute))
	}

	graduatedPercentageRangesAttribute, ok := attributes["graduated_percentage_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_percentage_ranges is missing from object`)

		return nil, diags
	}

	graduatedPercentageRangesVal, ok := graduatedPercentageRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_percentage_ranges expected to be basetypes.ListValue, was: %T`, graduatedPercentageRangesAttribute))
	}

	graduatedRangesAttribute, ok := attributes["graduated_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_ranges is missing from object`)

		return nil, diags
	}

	graduatedRangesVal, ok := graduatedRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_ranges expected to be basetypes.ListValue, was: %T`, graduatedRangesAttribute))
	}

	groupedByAttribute, ok := attributes["grouped_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_by is missing from object`)

		return nil, diags
	}

	groupedByVal, ok := groupedByAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_by expected to be basetypes.ListValue, was: %T`, groupedByAttribute))
	}

	packageSizeAttribute, ok := attributes["package_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_size is missing from object`)

		return nil, diags
	}

	packageSizeVal, ok := packageSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_size expected to be basetypes.Int64Value, was: %T`, packageSizeAttribute))
	}

	perTransactionMaxAmountAttribute, ok := attributes["per_transaction_max_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_max_amount is missing from object`)

		return nil, diags
	}

	perTransactionMaxAmountVal, ok := perTransactionMaxAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_max_amount expected to be basetypes.StringValue, was: %T`, perTransactionMaxAmountAttribute))
	}

	perTransactionMinAmountAttribute, ok := attributes["per_transaction_min_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_min_amount is missing from object`)

		return nil, diags
	}

	perTransactionMinAmountVal, ok := perTransactionMinAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_min_amount expected to be basetypes.StringValue, was: %T`, perTransactionMinAmountAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	volumeRangesAttribute, ok := attributes["volume_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_ranges is missing from object`)

		return nil, diags
	}

	volumeRangesVal, ok := volumeRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_ranges expected to be basetypes.ListValue, was: %T`, volumeRangesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PropertiesValue{
		Amount:                       amountVal,
		FixedAmount:                  fixedAmountVal,
		FreeUnits:                    freeUnitsVal,
		FreeUnitsPerEvents:           freeUnitsPerEventsVal,
		FreeUnitsPerTotalAggregation: freeUnitsPerTotalAggregationVal,
		GraduatedPercentageRanges:    graduatedPercentageRangesVal,
		GraduatedRanges:              graduatedRangesVal,
		GroupedBy:                    groupedByVal,
		PackageSize:                  packageSizeVal,
		PerTransactionMaxAmount:      perTransactionMaxAmountVal,
		PerTransactionMinAmount:      perTransactionMinAmountVal,
		Rate:                         rateVal,
		VolumeRanges:                 volumeRangesVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewPropertiesValueNull() PropertiesValue {
	return PropertiesValue{
		state: attr.ValueStateNull,
	}
}

func NewPropertiesValueUnknown() PropertiesValue {
	return PropertiesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPropertiesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PropertiesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PropertiesValue Attribute Value",
				"While creating a PropertiesValue value, a missing attribute value was detected. "+
					"A PropertiesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PropertiesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PropertiesValue Attribute Type",
				"While creating a PropertiesValue value, an invalid attribute value was detected. "+
					"A PropertiesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PropertiesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PropertiesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PropertiesValue Attribute Value",
				"While creating a PropertiesValue value, an extra attribute value was detected. "+
					"A PropertiesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PropertiesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPropertiesValueUnknown(), diags
	}

	amountAttribute, ok := attributes["amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	amountVal, ok := amountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount expected to be basetypes.StringValue, was: %T`, amountAttribute))
	}

	fixedAmountAttribute, ok := attributes["fixed_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	fixedAmountVal, ok := fixedAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_amount expected to be basetypes.StringValue, was: %T`, fixedAmountAttribute))
	}

	freeUnitsAttribute, ok := attributes["free_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	freeUnitsVal, ok := freeUnitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units expected to be basetypes.Int64Value, was: %T`, freeUnitsAttribute))
	}

	freeUnitsPerEventsAttribute, ok := attributes["free_units_per_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_events is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	freeUnitsPerEventsVal, ok := freeUnitsPerEventsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_events expected to be basetypes.Int64Value, was: %T`, freeUnitsPerEventsAttribute))
	}

	freeUnitsPerTotalAggregationAttribute, ok := attributes["free_units_per_total_aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_total_aggregation is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	freeUnitsPerTotalAggregationVal, ok := freeUnitsPerTotalAggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_total_aggregation expected to be basetypes.StringValue, was: %T`, freeUnitsPerTotalAggregationAttribute))
	}

	graduatedPercentageRangesAttribute, ok := attributes["graduated_percentage_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_percentage_ranges is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	graduatedPercentageRangesVal, ok := graduatedPercentageRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_percentage_ranges expected to be basetypes.ListValue, was: %T`, graduatedPercentageRangesAttribute))
	}

	graduatedRangesAttribute, ok := attributes["graduated_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_ranges is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	graduatedRangesVal, ok := graduatedRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_ranges expected to be basetypes.ListValue, was: %T`, graduatedRangesAttribute))
	}

	groupedByAttribute, ok := attributes["grouped_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_by is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	groupedByVal, ok := groupedByAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_by expected to be basetypes.ListValue, was: %T`, groupedByAttribute))
	}

	packageSizeAttribute, ok := attributes["package_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_size is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	packageSizeVal, ok := packageSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_size expected to be basetypes.Int64Value, was: %T`, packageSizeAttribute))
	}

	perTransactionMaxAmountAttribute, ok := attributes["per_transaction_max_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_max_amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	perTransactionMaxAmountVal, ok := perTransactionMaxAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_max_amount expected to be basetypes.StringValue, was: %T`, perTransactionMaxAmountAttribute))
	}

	perTransactionMinAmountAttribute, ok := attributes["per_transaction_min_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_min_amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	perTransactionMinAmountVal, ok := perTransactionMinAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_min_amount expected to be basetypes.StringValue, was: %T`, perTransactionMinAmountAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	volumeRangesAttribute, ok := attributes["volume_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_ranges is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	volumeRangesVal, ok := volumeRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_ranges expected to be basetypes.ListValue, was: %T`, volumeRangesAttribute))
	}

	if diags.HasError() {
		return NewPropertiesValueUnknown(), diags
	}

	return PropertiesValue{
		Amount:                       amountVal,
		FixedAmount:                  fixedAmountVal,
		FreeUnits:                    freeUnitsVal,
		FreeUnitsPerEvents:           freeUnitsPerEventsVal,
		FreeUnitsPerTotalAggregation: freeUnitsPerTotalAggregationVal,
		GraduatedPercentageRanges:    graduatedPercentageRangesVal,
		GraduatedRanges:              graduatedRangesVal,
		GroupedBy:                    groupedByVal,
		PackageSize:                  packageSizeVal,
		PerTransactionMaxAmount:      perTransactionMaxAmountVal,
		PerTransactionMinAmount:      perTransactionMinAmountVal,
		Rate:                         rateVal,
		VolumeRanges:                 volumeRangesVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewPropertiesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PropertiesValue {
	object, diags := NewPropertiesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPropertiesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PropertiesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPropertiesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPropertiesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPropertiesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPropertiesValueMust(PropertiesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PropertiesType) ValueType(ctx context.Context) attr.Value {
	return PropertiesValue{}
}

var _ basetypes.ObjectValuable = PropertiesValue{}

type PropertiesValue struct {
	Amount                       basetypes.StringValue `tfsdk:"amount"`
	FixedAmount                  basetypes.StringValue `tfsdk:"fixed_amount"`
	FreeUnits                    basetypes.Int64Value  `tfsdk:"free_units"`
	FreeUnitsPerEvents           basetypes.Int64Value  `tfsdk:"free_units_per_events"`
	FreeUnitsPerTotalAggregation basetypes.StringValue `tfsdk:"free_units_per_total_aggregation"`
	GraduatedPercentageRanges    basetypes.ListValue   `tfsdk:"graduated_percentage_ranges"`
	GraduatedRanges              basetypes.ListValue   `tfsdk:"graduated_ranges"`
	GroupedBy                    basetypes.ListValue   `tfsdk:"grouped_by"`
	PackageSize                  basetypes.Int64Value  `tfsdk:"package_size"`
	PerTransactionMaxAmount      basetypes.StringValue `tfsdk:"per_transaction_max_amount"`
	PerTransactionMinAmount      basetypes.StringValue `tfsdk:"per_transaction_min_amount"`
	Rate                         basetypes.StringValue `tfsdk:"rate"`
	VolumeRanges                 basetypes.ListValue   `tfsdk:"volume_ranges"`
	state                        attr.ValueState
}

func (v PropertiesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fixed_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["free_units"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["free_units_per_events"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["free_units_per_total_aggregation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["graduated_percentage_ranges"] = basetypes.ListType{
		ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["graduated_ranges"] = basetypes.ListType{
		ElemType: GraduatedRangesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["grouped_by"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["package_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_transaction_max_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["per_transaction_min_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_ranges"] = basetypes.ListType{
		ElemType: VolumeRangesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.Amount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount"] = val

		val, err = v.FixedAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_amount"] = val

		val, err = v.FreeUnits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units"] = val

		val, err = v.FreeUnitsPerEvents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units_per_events"] = val

		val, err = v.FreeUnitsPerTotalAggregation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units_per_total_aggregation"] = val

		val, err = v.GraduatedPercentageRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["graduated_percentage_ranges"] = val

		val, err = v.GraduatedRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["graduated_ranges"] = val

		val, err = v.GroupedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["grouped_by"] = val

		val, err = v.PackageSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["package_size"] = val

		val, err = v.PerTransactionMaxAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_transaction_max_amount"] = val

		val, err = v.PerTransactionMinAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_transaction_min_amount"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		val, err = v.VolumeRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_ranges"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PropertiesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PropertiesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PropertiesValue) String() string {
	return "PropertiesValue"
}

func (v PropertiesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	graduatedPercentageRanges := types.ListValueMust(
		GraduatedPercentageRangesType{
			basetypes.ObjectType{
				AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.GraduatedPercentageRanges.Elements(),
	)

	if v.GraduatedPercentageRanges.IsNull() {
		graduatedPercentageRanges = types.ListNull(
			GraduatedPercentageRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.GraduatedPercentageRanges.IsUnknown() {
		graduatedPercentageRanges = types.ListUnknown(
			GraduatedPercentageRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	graduatedRanges := types.ListValueMust(
		GraduatedRangesType{
			basetypes.ObjectType{
				AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.GraduatedRanges.Elements(),
	)

	if v.GraduatedRanges.IsNull() {
		graduatedRanges = types.ListNull(
			GraduatedRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.GraduatedRanges.IsUnknown() {
		graduatedRanges = types.ListUnknown(
			GraduatedRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	volumeRanges := types.ListValueMust(
		VolumeRangesType{
			basetypes.ObjectType{
				AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.VolumeRanges.Elements(),
	)

	if v.VolumeRanges.IsNull() {
		volumeRanges = types.ListNull(
			VolumeRangesType{
				basetypes.ObjectType{
					AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VolumeRanges.IsUnknown() {
		volumeRanges = types.ListUnknown(
			VolumeRangesType{
				basetypes.ObjectType{
					AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var groupedByVal basetypes.ListValue
	switch {
	case v.GroupedBy.IsUnknown():
		groupedByVal = types.ListUnknown(types.StringType)
	case v.GroupedBy.IsNull():
		groupedByVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		groupedByVal, d = types.ListValue(types.StringType, v.GroupedBy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount":                           basetypes.StringType{},
			"fixed_amount":                     basetypes.StringType{},
			"free_units":                       basetypes.Int64Type{},
			"free_units_per_events":            basetypes.Int64Type{},
			"free_units_per_total_aggregation": basetypes.StringType{},
			"graduated_percentage_ranges": basetypes.ListType{
				ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
			},
			"graduated_ranges": basetypes.ListType{
				ElemType: GraduatedRangesValue{}.Type(ctx),
			},
			"grouped_by": basetypes.ListType{
				ElemType: types.StringType,
			},
			"package_size":               basetypes.Int64Type{},
			"per_transaction_max_amount": basetypes.StringType{},
			"per_transaction_min_amount": basetypes.StringType{},
			"rate":                       basetypes.StringType{},
			"volume_ranges": basetypes.ListType{
				ElemType: VolumeRangesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount":                           basetypes.StringType{},
		"fixed_amount":                     basetypes.StringType{},
		"free_units":                       basetypes.Int64Type{},
		"free_units_per_events":            basetypes.Int64Type{},
		"free_units_per_total_aggregation": basetypes.StringType{},
		"graduated_percentage_ranges": basetypes.ListType{
			ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
		},
		"graduated_ranges": basetypes.ListType{
			ElemType: GraduatedRangesValue{}.Type(ctx),
		},
		"grouped_by": basetypes.ListType{
			ElemType: types.StringType,
		},
		"package_size":               basetypes.Int64Type{},
		"per_transaction_max_amount": basetypes.StringType{},
		"per_transaction_min_amount": basetypes.StringType{},
		"rate":                       basetypes.StringType{},
		"volume_ranges": basetypes.ListType{
			ElemType: VolumeRangesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount":                           v.Amount,
			"fixed_amount":                     v.FixedAmount,
			"free_units":                       v.FreeUnits,
			"free_units_per_events":            v.FreeUnitsPerEvents,
			"free_units_per_total_aggregation": v.FreeUnitsPerTotalAggregation,
			"graduated_percentage_ranges":      graduatedPercentageRanges,
			"graduated_ranges":                 graduatedRanges,
			"grouped_by":                       groupedByVal,
			"package_size":                     v.PackageSize,
			"per_transaction_max_amount":       v.PerTransactionMaxAmount,
			"per_transaction_min_amount":       v.PerTransactionMinAmount,
			"rate":                             v.Rate,
			"volume_ranges":                    volumeRanges,
		})

	return objVal, diags
}

func (v PropertiesValue) Equal(o attr.Value) bool {
	other, ok := o.(PropertiesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Amount.Equal(other.Amount) {
		return false
	}

	if !v.FixedAmount.Equal(other.FixedAmount) {
		return false
	}

	if !v.FreeUnits.Equal(other.FreeUnits) {
		return false
	}

	if !v.FreeUnitsPerEvents.Equal(other.FreeUnitsPerEvents) {
		return false
	}

	if !v.FreeUnitsPerTotalAggregation.Equal(other.FreeUnitsPerTotalAggregation) {
		return false
	}

	if !v.GraduatedPercentageRanges.Equal(other.GraduatedPercentageRanges) {
		return false
	}

	if !v.GraduatedRanges.Equal(other.GraduatedRanges) {
		return false
	}

	if !v.GroupedBy.Equal(other.GroupedBy) {
		return false
	}

	if !v.PackageSize.Equal(other.PackageSize) {
		return false
	}

	if !v.PerTransactionMaxAmount.Equal(other.PerTransactionMaxAmount) {
		return false
	}

	if !v.PerTransactionMinAmount.Equal(other.PerTransactionMinAmount) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	if !v.VolumeRanges.Equal(other.VolumeRanges) {
		return false
	}

	return true
}

func (v PropertiesValue) Type(ctx context.Context) attr.Type {
	return PropertiesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PropertiesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount":                           basetypes.StringType{},
		"fixed_amount":                     basetypes.StringType{},
		"free_units":                       basetypes.Int64Type{},
		"free_units_per_events":            basetypes.Int64Type{},
		"free_units_per_total_aggregation": basetypes.StringType{},
		"graduated_percentage_ranges": basetypes.ListType{
			ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
		},
		"graduated_ranges": basetypes.ListType{
			ElemType: GraduatedRangesValue{}.Type(ctx),
		},
		"grouped_by": basetypes.ListType{
			ElemType: types.StringType,
		},
		"package_size":               basetypes.Int64Type{},
		"per_transaction_max_amount": basetypes.StringType{},
		"per_transaction_min_amount": basetypes.StringType{},
		"rate":                       basetypes.StringType{},
		"volume_ranges": basetypes.ListType{
			ElemType: VolumeRangesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = GraduatedPercentageRangesType{}

type GraduatedPercentageRangesType struct {
	basetypes.ObjectType
}

func (t GraduatedPercentageRangesType) Equal(o attr.Type) bool {
	other, ok := o.(GraduatedPercentageRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GraduatedPercentageRangesType) String() string {
	return "GraduatedPercentageRangesType"
}

func (t GraduatedPercentageRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return nil, diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GraduatedPercentageRangesValue{
		FlatAmount: flatAmountVal,
		FromValue:  fromValueVal,
		Rate:       rateVal,
		ToValue:    toValueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewGraduatedPercentageRangesValueNull() GraduatedPercentageRangesValue {
	return GraduatedPercentageRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewGraduatedPercentageRangesValueUnknown() GraduatedPercentageRangesValue {
	return GraduatedPercentageRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGraduatedPercentageRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GraduatedPercentageRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GraduatedPercentageRangesValue Attribute Value",
				"While creating a GraduatedPercentageRangesValue value, a missing attribute value was detected. "+
					"A GraduatedPercentageRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GraduatedPercentageRangesValue Attribute Type",
				"While creating a GraduatedPercentageRangesValue value, an invalid attribute value was detected. "+
					"A GraduatedPercentageRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GraduatedPercentageRangesValue Attribute Value",
				"While creating a GraduatedPercentageRangesValue value, an extra attribute value was detected. "+
					"A GraduatedPercentageRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GraduatedPercentageRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	return GraduatedPercentageRangesValue{
		FlatAmount: flatAmountVal,
		FromValue:  fromValueVal,
		Rate:       rateVal,
		ToValue:    toValueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewGraduatedPercentageRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GraduatedPercentageRangesValue {
	object, diags := NewGraduatedPercentageRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGraduatedPercentageRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GraduatedPercentageRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGraduatedPercentageRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGraduatedPercentageRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGraduatedPercentageRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGraduatedPercentageRangesValueMust(GraduatedPercentageRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GraduatedPercentageRangesType) ValueType(ctx context.Context) attr.Value {
	return GraduatedPercentageRangesValue{}
}

var _ basetypes.ObjectValuable = GraduatedPercentageRangesValue{}

type GraduatedPercentageRangesValue struct {
	FlatAmount basetypes.StringValue `tfsdk:"flat_amount"`
	FromValue  basetypes.Int64Value  `tfsdk:"from_value"`
	Rate       basetypes.StringValue `tfsdk:"rate"`
	ToValue    basetypes.Int64Value  `tfsdk:"to_value"`
	state      attr.ValueState
}

func (v GraduatedPercentageRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GraduatedPercentageRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GraduatedPercentageRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GraduatedPercentageRangesValue) String() string {
	return "GraduatedPercentageRangesValue"
}

func (v GraduatedPercentageRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_amount": basetypes.StringType{},
		"from_value":  basetypes.Int64Type{},
		"rate":        basetypes.StringType{},
		"to_value":    basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_amount": v.FlatAmount,
			"from_value":  v.FromValue,
			"rate":        v.Rate,
			"to_value":    v.ToValue,
		})

	return objVal, diags
}

func (v GraduatedPercentageRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(GraduatedPercentageRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatAmount.Equal(other.FlatAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	return true
}

func (v GraduatedPercentageRangesValue) Type(ctx context.Context) attr.Type {
	return GraduatedPercentageRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GraduatedPercentageRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_amount": basetypes.StringType{},
		"from_value":  basetypes.Int64Type{},
		"rate":        basetypes.StringType{},
		"to_value":    basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = GraduatedRangesType{}

type GraduatedRangesType struct {
	basetypes.ObjectType
}

func (t GraduatedRangesType) Equal(o attr.Type) bool {
	other, ok := o.(GraduatedRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GraduatedRangesType) String() string {
	return "GraduatedRangesType"
}

func (t GraduatedRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return nil, diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return nil, diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GraduatedRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewGraduatedRangesValueNull() GraduatedRangesValue {
	return GraduatedRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewGraduatedRangesValueUnknown() GraduatedRangesValue {
	return GraduatedRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGraduatedRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GraduatedRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GraduatedRangesValue Attribute Value",
				"While creating a GraduatedRangesValue value, a missing attribute value was detected. "+
					"A GraduatedRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GraduatedRangesValue Attribute Type",
				"While creating a GraduatedRangesValue value, an invalid attribute value was detected. "+
					"A GraduatedRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GraduatedRangesValue Attribute Value",
				"While creating a GraduatedRangesValue value, an extra attribute value was detected. "+
					"A GraduatedRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GraduatedRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGraduatedRangesValueUnknown(), diags
	}

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return NewGraduatedRangesValueUnknown(), diags
	}

	return GraduatedRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewGraduatedRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GraduatedRangesValue {
	object, diags := NewGraduatedRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGraduatedRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GraduatedRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGraduatedRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGraduatedRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGraduatedRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGraduatedRangesValueMust(GraduatedRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GraduatedRangesType) ValueType(ctx context.Context) attr.Value {
	return GraduatedRangesValue{}
}

var _ basetypes.ObjectValuable = GraduatedRangesValue{}

type GraduatedRangesValue struct {
	FlatAmount    basetypes.StringValue `tfsdk:"flat_amount"`
	FromValue     basetypes.Int64Value  `tfsdk:"from_value"`
	PerUnitAmount basetypes.StringValue `tfsdk:"per_unit_amount"`
	ToValue       basetypes.Int64Value  `tfsdk:"to_value"`
	state         attr.ValueState
}

func (v GraduatedRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.PerUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_amount"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GraduatedRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GraduatedRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GraduatedRangesValue) String() string {
	return "GraduatedRangesValue"
}

func (v GraduatedRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_amount":     v.FlatAmount,
			"from_value":      v.FromValue,
			"per_unit_amount": v.PerUnitAmount,
			"to_value":        v.ToValue,
		})

	return objVal, diags
}

func (v GraduatedRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(GraduatedRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatAmount.Equal(other.FlatAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.PerUnitAmount.Equal(other.PerUnitAmount) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	return true
}

func (v GraduatedRangesValue) Type(ctx context.Context) attr.Type {
	return GraduatedRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GraduatedRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = VolumeRangesType{}

type VolumeRangesType struct {
	basetypes.ObjectType
}

func (t VolumeRangesType) Equal(o attr.Type) bool {
	other, ok := o.(VolumeRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumeRangesType) String() string {
	return "VolumeRangesType"
}

func (t VolumeRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return nil, diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return nil, diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumeRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewVolumeRangesValueNull() VolumeRangesValue {
	return VolumeRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumeRangesValueUnknown() VolumeRangesValue {
	return VolumeRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumeRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumeRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumeRangesValue Attribute Value",
				"While creating a VolumeRangesValue value, a missing attribute value was detected. "+
					"A VolumeRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumeRangesValue Attribute Type",
				"While creating a VolumeRangesValue value, an invalid attribute value was detected. "+
					"A VolumeRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumeRangesValue Attribute Value",
				"While creating a VolumeRangesValue value, an extra attribute value was detected. "+
					"A VolumeRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumeRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumeRangesValueUnknown(), diags
	}

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return NewVolumeRangesValueUnknown(), diags
	}

	return VolumeRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewVolumeRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumeRangesValue {
	object, diags := NewVolumeRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumeRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumeRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumeRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumeRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumeRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumeRangesValueMust(VolumeRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumeRangesType) ValueType(ctx context.Context) attr.Value {
	return VolumeRangesValue{}
}

var _ basetypes.ObjectValuable = VolumeRangesValue{}

type VolumeRangesValue struct {
	FlatAmount    basetypes.StringValue `tfsdk:"flat_amount"`
	FromValue     basetypes.Int64Value  `tfsdk:"from_value"`
	PerUnitAmount basetypes.StringValue `tfsdk:"per_unit_amount"`
	ToValue       basetypes.Int64Value  `tfsdk:"to_value"`
	state         attr.ValueState
}

func (v VolumeRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.PerUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_amount"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumeRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumeRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumeRangesValue) String() string {
	return "VolumeRangesValue"
}

func (v VolumeRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_amount":     v.FlatAmount,
			"from_value":      v.FromValue,
			"per_unit_amount": v.PerUnitAmount,
			"to_value":        v.ToValue,
		})

	return objVal, diags
}

func (v VolumeRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumeRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatAmount.Equal(other.FlatAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.PerUnitAmount.Equal(other.PerUnitAmount) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	return true
}

func (v VolumeRangesValue) Type(ctx context.Context) attr.Type {
	return VolumeRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumeRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MinimumCommitmentType{}

type MinimumCommitmentType struct {
	basetypes.ObjectType
}

func (t MinimumCommitmentType) Equal(o attr.Type) bool {
	other, ok := o.(MinimumCommitmentType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MinimumCommitmentType) String() string {
	return "MinimumCommitmentType"
}

func (t MinimumCommitmentType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return nil, diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	planCodeAttribute, ok := attributes["plan_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_code is missing from object`)

		return nil, diags
	}

	planCodeVal, ok := planCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_code expected to be basetypes.StringValue, was: %T`, planCodeAttribute))
	}

	taxesAttribute, ok := attributes["taxes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes is missing from object`)

		return nil, diags
	}

	taxesVal, ok := taxesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes expected to be basetypes.ListValue, was: %T`, taxesAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MinimumCommitmentValue{
		AmountCents:        amountCentsVal,
		CreatedAt:          createdAtVal,
		Interval:           intervalVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		LagoId:             lagoIdVal,
		PlanCode:           planCodeVal,
		Taxes:              taxesVal,
		UpdatedAt:          updatedAtVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewMinimumCommitmentValueNull() MinimumCommitmentValue {
	return MinimumCommitmentValue{
		state: attr.ValueStateNull,
	}
}

func NewMinimumCommitmentValueUnknown() MinimumCommitmentValue {
	return MinimumCommitmentValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMinimumCommitmentValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MinimumCommitmentValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MinimumCommitmentValue Attribute Value",
				"While creating a MinimumCommitmentValue value, a missing attribute value was detected. "+
					"A MinimumCommitmentValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MinimumCommitmentValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MinimumCommitmentValue Attribute Type",
				"While creating a MinimumCommitmentValue value, an invalid attribute value was detected. "+
					"A MinimumCommitmentValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MinimumCommitmentValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MinimumCommitmentValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MinimumCommitmentValue Attribute Value",
				"While creating a MinimumCommitmentValue value, an extra attribute value was detected. "+
					"A MinimumCommitmentValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MinimumCommitmentValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMinimumCommitmentValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	planCodeAttribute, ok := attributes["plan_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_code is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	planCodeVal, ok := planCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_code expected to be basetypes.StringValue, was: %T`, planCodeAttribute))
	}

	taxesAttribute, ok := attributes["taxes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	taxesVal, ok := taxesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes expected to be basetypes.ListValue, was: %T`, taxesAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewMinimumCommitmentValueUnknown(), diags
	}

	return MinimumCommitmentValue{
		AmountCents:        amountCentsVal,
		CreatedAt:          createdAtVal,
		Interval:           intervalVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		LagoId:             lagoIdVal,
		PlanCode:           planCodeVal,
		Taxes:              taxesVal,
		UpdatedAt:          updatedAtVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewMinimumCommitmentValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MinimumCommitmentValue {
	object, diags := NewMinimumCommitmentValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMinimumCommitmentValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MinimumCommitmentType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMinimumCommitmentValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMinimumCommitmentValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMinimumCommitmentValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMinimumCommitmentValueMust(MinimumCommitmentValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MinimumCommitmentType) ValueType(ctx context.Context) attr.Value {
	return MinimumCommitmentValue{}
}

var _ basetypes.ObjectValuable = MinimumCommitmentValue{}

type MinimumCommitmentValue struct {
	AmountCents        basetypes.Int64Value  `tfsdk:"amount_cents"`
	CreatedAt          basetypes.StringValue `tfsdk:"created_at"`
	Interval           basetypes.StringValue `tfsdk:"interval"`
	InvoiceDisplayName basetypes.StringValue `tfsdk:"invoice_display_name"`
	LagoId             basetypes.StringValue `tfsdk:"lago_id"`
	PlanCode           basetypes.StringValue `tfsdk:"plan_code"`
	Taxes              basetypes.ListValue   `tfsdk:"taxes"`
	UpdatedAt          basetypes.StringValue `tfsdk:"updated_at"`
	state              attr.ValueState
}

func (v MinimumCommitmentValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interval"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["plan_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["taxes"] = basetypes.ListType{
		ElemType: TaxesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Interval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interval"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.PlanCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan_code"] = val

		val, err = v.Taxes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taxes"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MinimumCommitmentValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MinimumCommitmentValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MinimumCommitmentValue) String() string {
	return "MinimumCommitmentValue"
}

func (v MinimumCommitmentValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	taxes := types.ListValueMust(
		TaxesType{
			basetypes.ObjectType{
				AttrTypes: TaxesValue{}.AttributeTypes(ctx),
			},
		},
		v.Taxes.Elements(),
	)

	if v.Taxes.IsNull() {
		taxes = types.ListNull(
			TaxesType{
				basetypes.ObjectType{
					AttrTypes: TaxesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Taxes.IsUnknown() {
		taxes = types.ListUnknown(
			TaxesType{
				basetypes.ObjectType{
					AttrTypes: TaxesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":         basetypes.Int64Type{},
		"created_at":           basetypes.StringType{},
		"interval":             basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"lago_id":              basetypes.StringType{},
		"plan_code":            basetypes.StringType{},
		"taxes": basetypes.ListType{
			ElemType: TaxesValue{}.Type(ctx),
		},
		"updated_at": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":         v.AmountCents,
			"created_at":           v.CreatedAt,
			"interval":             v.Interval,
			"invoice_display_name": v.InvoiceDisplayName,
			"lago_id":              v.LagoId,
			"plan_code":            v.PlanCode,
			"taxes":                taxes,
			"updated_at":           v.UpdatedAt,
		})

	return objVal, diags
}

func (v MinimumCommitmentValue) Equal(o attr.Value) bool {
	other, ok := o.(MinimumCommitmentValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Interval.Equal(other.Interval) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.PlanCode.Equal(other.PlanCode) {
		return false
	}

	if !v.Taxes.Equal(other.Taxes) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v MinimumCommitmentValue) Type(ctx context.Context) attr.Type {
	return MinimumCommitmentType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MinimumCommitmentValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":         basetypes.Int64Type{},
		"created_at":           basetypes.StringType{},
		"interval":             basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"lago_id":              basetypes.StringType{},
		"plan_code":            basetypes.StringType{},
		"taxes": basetypes.ListType{
			ElemType: TaxesValue{}.Type(ctx),
		},
		"updated_at": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TaxesType{}

type TaxesType struct {
	basetypes.ObjectType
}

func (t TaxesType) Equal(o attr.Type) bool {
	other, ok := o.(TaxesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TaxesType) String() string {
	return "TaxesType"
}

func (t TaxesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appliedToOrganizationAttribute, ok := attributes["applied_to_organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applied_to_organization is missing from object`)

		return nil, diags
	}

	appliedToOrganizationVal, ok := appliedToOrganizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applied_to_organization expected to be basetypes.BoolValue, was: %T`, appliedToOrganizationAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.NumberValue, was: %T`, rateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TaxesValue{
		AppliedToOrganization: appliedToOrganizationVal,
		Code:                  codeVal,
		CreatedAt:             createdAtVal,
		Description:           descriptionVal,
		LagoId:                lagoIdVal,
		Name:                  nameVal,
		Rate:                  rateVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewTaxesValueNull() TaxesValue {
	return TaxesValue{
		state: attr.ValueStateNull,
	}
}

func NewTaxesValueUnknown() TaxesValue {
	return TaxesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTaxesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TaxesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TaxesValue Attribute Value",
				"While creating a TaxesValue value, a missing attribute value was detected. "+
					"A TaxesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TaxesValue Attribute Type",
				"While creating a TaxesValue value, an invalid attribute value was detected. "+
					"A TaxesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TaxesValue Attribute Value",
				"While creating a TaxesValue value, an extra attribute value was detected. "+
					"A TaxesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TaxesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTaxesValueUnknown(), diags
	}

	appliedToOrganizationAttribute, ok := attributes["applied_to_organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applied_to_organization is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	appliedToOrganizationVal, ok := appliedToOrganizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applied_to_organization expected to be basetypes.BoolValue, was: %T`, appliedToOrganizationAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.NumberValue, was: %T`, rateAttribute))
	}

	if diags.HasError() {
		return NewTaxesValueUnknown(), diags
	}

	return TaxesValue{
		AppliedToOrganization: appliedToOrganizationVal,
		Code:                  codeVal,
		CreatedAt:             createdAtVal,
		Description:           descriptionVal,
		LagoId:                lagoIdVal,
		Name:                  nameVal,
		Rate:                  rateVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewTaxesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TaxesValue {
	object, diags := NewTaxesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTaxesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TaxesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTaxesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTaxesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTaxesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTaxesValueMust(TaxesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TaxesType) ValueType(ctx context.Context) attr.Value {
	return TaxesValue{}
}

var _ basetypes.ObjectValuable = TaxesValue{}

type TaxesValue struct {
	AppliedToOrganization basetypes.BoolValue   `tfsdk:"applied_to_organization"`
	Code                  basetypes.StringValue `tfsdk:"code"`
	CreatedAt             basetypes.StringValue `tfsdk:"created_at"`
	Description           basetypes.StringValue `tfsdk:"description"`
	LagoId                basetypes.StringValue `tfsdk:"lago_id"`
	Name                  basetypes.StringValue `tfsdk:"name"`
	Rate                  basetypes.NumberValue `tfsdk:"rate"`
	state                 attr.ValueState
}

func (v TaxesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["applied_to_organization"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AppliedToOrganization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["applied_to_organization"] = val

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TaxesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TaxesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TaxesValue) String() string {
	return "TaxesValue"
}

func (v TaxesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"applied_to_organization": basetypes.BoolType{},
		"code":                    basetypes.StringType{},
		"created_at":              basetypes.StringType{},
		"description":             basetypes.StringType{},
		"lago_id":                 basetypes.StringType{},
		"name":                    basetypes.StringType{},
		"rate":                    basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"applied_to_organization": v.AppliedToOrganization,
			"code":                    v.Code,
			"created_at":              v.CreatedAt,
			"description":             v.Description,
			"lago_id":                 v.LagoId,
			"name":                    v.Name,
			"rate":                    v.Rate,
		})

	return objVal, diags
}

func (v TaxesValue) Equal(o attr.Value) bool {
	other, ok := o.(TaxesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AppliedToOrganization.Equal(other.AppliedToOrganization) {
		return false
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	return true
}

func (v TaxesValue) Type(ctx context.Context) attr.Type {
	return TaxesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TaxesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"applied_to_organization": basetypes.BoolType{},
		"code":                    basetypes.StringType{},
		"created_at":              basetypes.StringType{},
		"description":             basetypes.StringType{},
		"lago_id":                 basetypes.StringType{},
		"name":                    basetypes.StringType{},
		"rate":                    basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = UsageThresholdsType{}

type UsageThresholdsType struct {
	basetypes.ObjectType
}

func (t UsageThresholdsType) Equal(o attr.Type) bool {
	other, ok := o.(UsageThresholdsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsageThresholdsType) String() string {
	return "UsageThresholdsType"
}

func (t UsageThresholdsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	recurringAttribute, ok := attributes["recurring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recurring is missing from object`)

		return nil, diags
	}

	recurringVal, ok := recurringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recurring expected to be basetypes.BoolValue, was: %T`, recurringAttribute))
	}

	thresholdDisplayNameAttribute, ok := attributes["threshold_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold_display_name is missing from object`)

		return nil, diags
	}

	thresholdDisplayNameVal, ok := thresholdDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold_display_name expected to be basetypes.StringValue, was: %T`, thresholdDisplayNameAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsageThresholdsValue{
		AmountCents:          amountCentsVal,
		CreatedAt:            createdAtVal,
		LagoId:               lagoIdVal,
		Recurring:            recurringVal,
		ThresholdDisplayName: thresholdDisplayNameVal,
		UpdatedAt:            updatedAtVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewUsageThresholdsValueNull() UsageThresholdsValue {
	return UsageThresholdsValue{
		state: attr.ValueStateNull,
	}
}

func NewUsageThresholdsValueUnknown() UsageThresholdsValue {
	return UsageThresholdsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsageThresholdsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsageThresholdsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsageThresholdsValue Attribute Value",
				"While creating a UsageThresholdsValue value, a missing attribute value was detected. "+
					"A UsageThresholdsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsageThresholdsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsageThresholdsValue Attribute Type",
				"While creating a UsageThresholdsValue value, an invalid attribute value was detected. "+
					"A UsageThresholdsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsageThresholdsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsageThresholdsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsageThresholdsValue Attribute Value",
				"While creating a UsageThresholdsValue value, an extra attribute value was detected. "+
					"A UsageThresholdsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsageThresholdsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsageThresholdsValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	recurringAttribute, ok := attributes["recurring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recurring is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	recurringVal, ok := recurringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recurring expected to be basetypes.BoolValue, was: %T`, recurringAttribute))
	}

	thresholdDisplayNameAttribute, ok := attributes["threshold_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold_display_name is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	thresholdDisplayNameVal, ok := thresholdDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold_display_name expected to be basetypes.StringValue, was: %T`, thresholdDisplayNameAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewUsageThresholdsValueUnknown(), diags
	}

	return UsageThresholdsValue{
		AmountCents:          amountCentsVal,
		CreatedAt:            createdAtVal,
		LagoId:               lagoIdVal,
		Recurring:            recurringVal,
		ThresholdDisplayName: thresholdDisplayNameVal,
		UpdatedAt:            updatedAtVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewUsageThresholdsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsageThresholdsValue {
	object, diags := NewUsageThresholdsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsageThresholdsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsageThresholdsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsageThresholdsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsageThresholdsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsageThresholdsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsageThresholdsValueMust(UsageThresholdsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsageThresholdsType) ValueType(ctx context.Context) attr.Value {
	return UsageThresholdsValue{}
}

var _ basetypes.ObjectValuable = UsageThresholdsValue{}

type UsageThresholdsValue struct {
	AmountCents          basetypes.Int64Value  `tfsdk:"amount_cents"`
	CreatedAt            basetypes.StringValue `tfsdk:"created_at"`
	LagoId               basetypes.StringValue `tfsdk:"lago_id"`
	Recurring            basetypes.BoolValue   `tfsdk:"recurring"`
	ThresholdDisplayName basetypes.StringValue `tfsdk:"threshold_display_name"`
	UpdatedAt            basetypes.StringValue `tfsdk:"updated_at"`
	state                attr.ValueState
}

func (v UsageThresholdsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recurring"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["threshold_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Recurring.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recurring"] = val

		val, err = v.ThresholdDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["threshold_display_name"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsageThresholdsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsageThresholdsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsageThresholdsValue) String() string {
	return "UsageThresholdsValue"
}

func (v UsageThresholdsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"amount_cents":           basetypes.Int64Type{},
		"created_at":             basetypes.StringType{},
		"lago_id":                basetypes.StringType{},
		"recurring":              basetypes.BoolType{},
		"threshold_display_name": basetypes.StringType{},
		"updated_at":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":           v.AmountCents,
			"created_at":             v.CreatedAt,
			"lago_id":                v.LagoId,
			"recurring":              v.Recurring,
			"threshold_display_name": v.ThresholdDisplayName,
			"updated_at":             v.UpdatedAt,
		})

	return objVal, diags
}

func (v UsageThresholdsValue) Equal(o attr.Value) bool {
	other, ok := o.(UsageThresholdsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Recurring.Equal(other.Recurring) {
		return false
	}

	if !v.ThresholdDisplayName.Equal(other.ThresholdDisplayName) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v UsageThresholdsValue) Type(ctx context.Context) attr.Type {
	return UsageThresholdsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsageThresholdsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":           basetypes.Int64Type{},
		"created_at":             basetypes.StringType{},
		"lago_id":                basetypes.StringType{},
		"recurring":              basetypes.BoolType{},
		"threshold_display_name": basetypes.StringType{},
		"updated_at":             basetypes.StringType{},
	}
}
