// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_fees

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func FeesResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"fee": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"amount_cents": schema.Int64Attribute{
						Computed:            true,
						Description:         "The cost of this specific fee, excluding any applicable taxes.",
						MarkdownDescription: "The cost of this specific fee, excluding any applicable taxes.",
					},
					"amount_currency": schema.StringAttribute{
						Computed: true,
					},
					"amount_details": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"fixed_fee_total_amount": schema.StringAttribute{
								Computed:            true,
								Description:         "Total amount to charge for received paid_events for the Percentage charge model.",
								MarkdownDescription: "Total amount to charge for received paid_events for the Percentage charge model.",
							},
							"fixed_fee_unit_amount": schema.StringAttribute{
								Computed:            true,
								Description:         "Fixed fee unit price per received paid_event for the Percentage charge model.",
								MarkdownDescription: "Fixed fee unit price per received paid_event for the Percentage charge model.",
							},
							"free_events": schema.Int64Attribute{
								Computed:            true,
								Description:         "Total number of free events allowed for the Percentage charge model.",
								MarkdownDescription: "Total number of free events allowed for the Percentage charge model.",
							},
							"free_units": schema.StringAttribute{
								Computed:            true,
								Description:         "The quantity of units that are provided free of charge for each billing period in a `package` charge model.",
								MarkdownDescription: "The quantity of units that are provided free of charge for each billing period in a `package` charge model.",
							},
							"graduated_percentage_ranges": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"flat_unit_amount": schema.StringAttribute{
											Computed:            true,
											Description:         "Flat unit amount within a specified tier.",
											MarkdownDescription: "Flat unit amount within a specified tier.",
										},
										"from_value": schema.Int64Attribute{
											Computed:            true,
											Description:         "Lower value of a tier. It is either 0 or the previous range's `to_value + 1`.",
											MarkdownDescription: "Lower value of a tier. It is either 0 or the previous range's `to_value + 1`.",
										},
										"per_unit_total_amount": schema.StringAttribute{
											Computed:            true,
											Description:         "Total amount of received units to be charged within a specified tier.",
											MarkdownDescription: "Total amount of received units to be charged within a specified tier.",
										},
										"rate": schema.StringAttribute{
											Computed:            true,
											Description:         "Percentage rate applied within a specified tier.",
											MarkdownDescription: "Percentage rate applied within a specified tier.",
										},
										"to_value": schema.Int64Attribute{
											Computed:            true,
											Description:         "Highest value of a tier.\n- This value is higher than the from_value of the same tier.\n- This value is null for the last tier.",
											MarkdownDescription: "Highest value of a tier.\n- This value is higher than the from_value of the same tier.\n- This value is null for the last tier.",
										},
										"total_with_flat_amount": schema.StringAttribute{
											Computed:            true,
											Description:         "Total amount to be charged for a specific tier, taking into account the flat_unit_amount and the per_unit_total_amount.",
											MarkdownDescription: "Total amount to be charged for a specific tier, taking into account the flat_unit_amount and the per_unit_total_amount.",
										},
										"units": schema.StringAttribute{
											Computed:            true,
											Description:         "Total units received in Lago.",
											MarkdownDescription: "Total units received in Lago.",
										},
									},
									CustomType: GraduatedPercentageRangesType{
										ObjectType: types.ObjectType{
											AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
										},
									},
								},
								Computed:            true,
								Description:         "Graduated percentage ranges, used for a `graduated_percentage` charge model.",
								MarkdownDescription: "Graduated percentage ranges, used for a `graduated_percentage` charge model.",
							},
							"graduated_ranges": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"flat_unit_amount": schema.StringAttribute{
											Computed:            true,
											Description:         "Flat unit amount within a specified tier.",
											MarkdownDescription: "Flat unit amount within a specified tier.",
										},
										"from_value": schema.Int64Attribute{
											Computed:            true,
											Description:         "Lower value of a tier. It is either 0 or the previous range's `to_value + 1`.",
											MarkdownDescription: "Lower value of a tier. It is either 0 or the previous range's `to_value + 1`.",
										},
										"per_unit_amount": schema.StringAttribute{
											Computed:            true,
											Description:         "Amount per unit within a specified tier.",
											MarkdownDescription: "Amount per unit within a specified tier.",
										},
										"per_unit_total_amount": schema.StringAttribute{
											Computed:            true,
											Description:         "Total amount of received units to be charged within a specified tier.",
											MarkdownDescription: "Total amount of received units to be charged within a specified tier.",
										},
										"to_value": schema.Int64Attribute{
											Computed:            true,
											Description:         "Highest value of a tier.\n- This value is higher than the from_value of the same tier.\n- This value is null for the last tier.",
											MarkdownDescription: "Highest value of a tier.\n- This value is higher than the from_value of the same tier.\n- This value is null for the last tier.",
										},
										"total_with_flat_amount": schema.StringAttribute{
											Computed:            true,
											Description:         "Total amount to be charged for a specific tier, taking into account the flat_unit_amount and the per_unit_total_amount.",
											MarkdownDescription: "Total amount to be charged for a specific tier, taking into account the flat_unit_amount and the per_unit_total_amount.",
										},
										"units": schema.StringAttribute{
											Computed:            true,
											Description:         "Total units received in Lago.",
											MarkdownDescription: "Total units received in Lago.",
										},
									},
									CustomType: GraduatedRangesType{
										ObjectType: types.ObjectType{
											AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
										},
									},
								},
								Computed:            true,
								Description:         "Graduated ranges, used for a `graduated` charge model.",
								MarkdownDescription: "Graduated ranges, used for a `graduated` charge model.",
							},
							"min_max_adjustment_total_amount": schema.StringAttribute{
								Computed:            true,
								Description:         "Total adjustment amount linked to minimum and maximum spending per transaction for the Percentage charge model.",
								MarkdownDescription: "Total adjustment amount linked to minimum and maximum spending per transaction for the Percentage charge model.",
							},
							"paid_events": schema.Int64Attribute{
								Computed:            true,
								Description:         "Total number of paid events for the Percentage charge model.",
								MarkdownDescription: "Total number of paid events for the Percentage charge model.",
							},
							"paid_units": schema.StringAttribute{
								Computed:            true,
								Description:         "The quantity of units that are not provided free of charge for each billing period in a `package` charge model.",
								MarkdownDescription: "The quantity of units that are not provided free of charge for each billing period in a `package` charge model.",
							},
							"per_package_size": schema.Int64Attribute{
								Computed:            true,
								Description:         "The quantity of units included, defined for Package or Percentage charge model.",
								MarkdownDescription: "The quantity of units included, defined for Package or Percentage charge model.",
							},
							"per_package_unit_amount": schema.StringAttribute{
								Computed:            true,
								Description:         "Total amount to charge for received paid_units, defined for Package or Percentage charge model.",
								MarkdownDescription: "Total amount to charge for received paid_units, defined for Package or Percentage charge model.",
							},
							"per_unit_total_amount": schema.StringAttribute{
								Computed:            true,
								Description:         "Total amount of received units to be charged for the Percentage charge model.",
								MarkdownDescription: "Total amount of received units to be charged for the Percentage charge model.",
							},
							"rate": schema.StringAttribute{
								Computed:            true,
								Description:         "Percentage rate applied for the Percentage charge model.",
								MarkdownDescription: "Percentage rate applied for the Percentage charge model.",
							},
							"units": schema.StringAttribute{
								Computed:            true,
								Description:         "The total units received in Lago for the Percentage charge model.",
								MarkdownDescription: "The total units received in Lago for the Percentage charge model.",
							},
							"volume_ranges": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"flat_unit_amount": schema.StringAttribute{
											Computed:            true,
											Description:         "The unit price, excluding tax, for a specific tier of a `volume` charge model.",
											MarkdownDescription: "The unit price, excluding tax, for a specific tier of a `volume` charge model.",
										},
										"per_unit_amount": schema.StringAttribute{
											Computed:            true,
											Description:         "The flat amount for a whole tier, excluding tax, for a `volume` charge model.",
											MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `volume` charge model.",
										},
										"per_unit_total_amount": schema.StringAttribute{
											Computed:            true,
											Description:         "Total amount of received units to be charged.",
											MarkdownDescription: "Total amount of received units to be charged.",
										},
									},
									CustomType: VolumeRangesType{
										ObjectType: types.ObjectType{
											AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
										},
									},
								},
								Computed:            true,
								Description:         "Volume ranges, used for a `volume` charge model.",
								MarkdownDescription: "Volume ranges, used for a `volume` charge model.",
							},
						},
						CustomType: AmountDetailsType{
							ObjectType: types.ObjectType{
								AttrTypes: AmountDetailsValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "List of all unit amount details for calculating the fee.",
						MarkdownDescription: "List of all unit amount details for calculating the fee.",
					},
					"applied_taxes": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "Amount of the tax",
									MarkdownDescription: "Amount of the tax",
								},
								"amount_currency": schema.StringAttribute{
									Computed: true,
								},
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The date and time when the applied tax was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the applied tax was initially created.",
									MarkdownDescription: "The date and time when the applied tax was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the applied tax was initially created.",
								},
								"lago_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique identifier of the applied tax, created by Lago.",
									MarkdownDescription: "Unique identifier of the applied tax, created by Lago.",
								},
								"lago_tax_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique identifier of the tax, created by Lago.",
									MarkdownDescription: "Unique identifier of the tax, created by Lago.",
								},
								"tax_code": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique code used to identify the tax associated with the API request.",
									MarkdownDescription: "Unique code used to identify the tax associated with the API request.",
								},
								"tax_description": schema.StringAttribute{
									Computed:            true,
									Description:         "Internal description of the taxe",
									MarkdownDescription: "Internal description of the taxe",
								},
								"tax_name": schema.StringAttribute{
									Computed:            true,
									Description:         "Name of the tax.",
									MarkdownDescription: "Name of the tax.",
								},
								"tax_rate": schema.NumberAttribute{
									Computed:            true,
									Description:         "The percentage rate of the tax",
									MarkdownDescription: "The percentage rate of the tax",
								},
							},
							CustomType: AppliedTaxesType{
								ObjectType: types.ObjectType{
									AttrTypes: AppliedTaxesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "List of fee applied taxes",
						MarkdownDescription: "List of fee applied taxes",
					},
					"created_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date and time when the fee was created. It is provided in Coordinated Universal Time (UTC) format.",
						MarkdownDescription: "The date and time when the fee was created. It is provided in Coordinated Universal Time (UTC) format.",
					},
					"event_transaction_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the transaction. This field is specifically displayed when the fee type is `charge` and the payment for the fee is made in advance (`pay_in_advance` is set to `true`).",
						MarkdownDescription: "Unique identifier assigned to the transaction. This field is specifically displayed when the fee type is `charge` and the payment for the fee is made in advance (`pay_in_advance` is set to `true`).",
					},
					"events_count": schema.Int64Attribute{
						Computed:            true,
						Description:         "The number of events that have been sent and used to charge the customer. This field indicates the count or quantity of events that have been processed and considered in the charging process.",
						MarkdownDescription: "The number of events that have been sent and used to charge the customer. This field indicates the count or quantity of events that have been processed and considered in the charging process.",
					},
					"external_customer_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the customer in your application. This field is specifically displayed when the fee type is charge or subscription.",
						MarkdownDescription: "Unique identifier assigned to the customer in your application. This field is specifically displayed when the fee type is charge or subscription.",
					},
					"external_subscription_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the subscription in your application. This field is specifically displayed when the fee type is charge or subscription.",
						MarkdownDescription: "Unique identifier assigned to the subscription in your application. This field is specifically displayed when the fee type is charge or subscription.",
					},
					"failed_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date and time when the payment for the fee failed to process. It is provided in Coordinated Universal Time (UTC) format.",
						MarkdownDescription: "The date and time when the payment for the fee failed to process. It is provided in Coordinated Universal Time (UTC) format.",
					},
					"from_date": schema.StringAttribute{
						Computed:            true,
						Description:         "The beginning date of the period that the fee covers. It is applicable only to `subscription` and `charge` fees. This field indicates the start date of the billing period or subscription period associated with the fee.",
						MarkdownDescription: "The beginning date of the period that the fee covers. It is applicable only to `subscription` and `charge` fees. This field indicates the start date of the billing period or subscription period associated with the fee.",
					},
					"invoice_display_name": schema.StringAttribute{
						Computed:            true,
						Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
						MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
					},
					"invoiceable": schema.BoolAttribute{
						Computed:            true,
						Description:         "Flag that indicates whether the fee was included on the invoice. It serves as a boolean value, where `true` represents that the fee was included on the invoice, and `false` indicates that the fee was not included on the invoice.",
						MarkdownDescription: "Flag that indicates whether the fee was included on the invoice. It serves as a boolean value, where `true` represents that the fee was included on the invoice, and `false` indicates that the fee was not included on the invoice.",
					},
					"item": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"code": schema.StringAttribute{
								Computed:            true,
								Description:         "The code of the fee item. It can be the code of the `add-on`, the code of the `charge`, the code of the `credit` or the code of the `subscription`.",
								MarkdownDescription: "The code of the fee item. It can be the code of the `add-on`, the code of the `charge`, the code of the `credit` or the code of the `subscription`.",
							},
							"filter_invoice_display_name": schema.StringAttribute{
								Computed:            true,
								Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the actual charge filter values will be used as the default display name.",
								MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the actual charge filter values will be used as the default display name.",
							},
							"filters": schema.MapAttribute{
								ElementType: types.ListType{
									ElemType: types.StringType,
								},
								Computed:            true,
								Description:         "Key value list of event properties",
								MarkdownDescription: "Key value list of event properties",
							},
							"grouped_by": schema.MapAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "Key value list of event properties aggregated by the charge model",
								MarkdownDescription: "Key value list of event properties aggregated by the charge model",
							},
							"invoice_display_name": schema.StringAttribute{
								Computed:            true,
								Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
								MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
							},
							"item_type": schema.StringAttribute{
								Computed:            true,
								Description:         "The type of the fee item. Possible values are `AddOn`, `BillableMetric`, `WalletTransaction`, `Subscription` or `Commitment`.",
								MarkdownDescription: "The type of the fee item. Possible values are `AddOn`, `BillableMetric`, `WalletTransaction`, `Subscription` or `Commitment`.",
							},
							"lago_item_id": schema.StringAttribute{
								Computed:            true,
								Description:         "Unique identifier of the fee item, created by Lago. It can be the identifier of the `add-on`, the `charge`, the `credit`, the `subscription` or the `commitment`.",
								MarkdownDescription: "Unique identifier of the fee item, created by Lago. It can be the identifier of the `add-on`, the `charge`, the `credit`, the `subscription` or the `commitment`.",
							},
							"name": schema.StringAttribute{
								Computed:            true,
								Description:         "The name of the fee item. It can be the name of the `add-on`, the `charge`, the `credit`, the `subscription` or the `commitment`.",
								MarkdownDescription: "The name of the fee item. It can be the name of the `add-on`, the `charge`, the `credit`, the `subscription` or the `commitment`.",
							},
							"type": schema.StringAttribute{
								Computed:            true,
								Description:         "The fee type. Possible values are `add-on`, `charge`, `credit`, `subscription` or `commitment`.",
								MarkdownDescription: "The fee type. Possible values are `add-on`, `charge`, `credit`, `subscription` or `commitment`.",
							},
						},
						CustomType: ItemType{
							ObjectType: types.ObjectType{
								AttrTypes: ItemValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "Item attached to the fee",
						MarkdownDescription: "Item attached to the fee",
					},
					"lago_charge_filter_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the charge filter that the fee belongs to",
						MarkdownDescription: "Unique identifier assigned to the charge filter that the fee belongs to",
					},
					"lago_charge_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the charge that the fee belongs to",
						MarkdownDescription: "Unique identifier assigned to the charge that the fee belongs to",
					},
					"lago_customer_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the customer, created by Lago. This field is specifically displayed when the fee type is charge or subscription.",
						MarkdownDescription: "Unique identifier assigned to the customer, created by Lago. This field is specifically displayed when the fee type is charge or subscription.",
					},
					"lago_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the fee's record within the Lago system.",
						MarkdownDescription: "Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the fee's record within the Lago system.",
					},
					"lago_invoice_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the invoice that the fee belongs to",
						MarkdownDescription: "Unique identifier assigned to the invoice that the fee belongs to",
					},
					"lago_subscription_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the subscription, created by Lago. This field is specifically displayed when the fee type is charge or subscription.",
						MarkdownDescription: "Unique identifier assigned to the subscription, created by Lago. This field is specifically displayed when the fee type is charge or subscription.",
					},
					"lago_true_up_fee_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the true-up fee when a minimum has been set to the charge. This identifier helps to distinguish and manage the true-up fee associated with the charge, which may be applicable when a minimum threshold or limit is set for the charge amount.",
						MarkdownDescription: "Unique identifier assigned to the true-up fee when a minimum has been set to the charge. This identifier helps to distinguish and manage the true-up fee associated with the charge, which may be applicable when a minimum threshold or limit is set for the charge amount.",
					},
					"lago_true_up_parent_fee_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier assigned to the parent fee on which the true-up fee is assigned. This identifier establishes the relationship between the parent fee and the associated true-up fee.",
						MarkdownDescription: "Unique identifier assigned to the parent fee on which the true-up fee is assigned. This identifier establishes the relationship between the parent fee and the associated true-up fee.",
					},
					"pay_in_advance": schema.BoolAttribute{
						Computed:            true,
						Description:         "Flag that indicates whether the fee was paid in advance. It serves as a boolean value, where `true` represents that the fee was paid in advance (straightaway), and `false` indicates that the fee was not paid in arrears (at the end of the period).",
						MarkdownDescription: "Flag that indicates whether the fee was paid in advance. It serves as a boolean value, where `true` represents that the fee was paid in advance (straightaway), and `false` indicates that the fee was not paid in arrears (at the end of the period).",
					},
					"payment_status": schema.StringAttribute{
						Required:            true,
						Description:         "The payment status of the fee. Possible values are `pending`, `succeeded`, `failed` or `refunded`.",
						MarkdownDescription: "The payment status of the fee. Possible values are `pending`, `succeeded`, `failed` or `refunded`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"pending",
								"succeeded",
								"failed",
								"refunded",
							),
						},
					},
					"precise_amount": schema.StringAttribute{
						Computed:            true,
						Description:         "The cost of this specific fee, excluding any applicable taxes, with precision.",
						MarkdownDescription: "The cost of this specific fee, excluding any applicable taxes, with precision.",
					},
					"precise_total_amount": schema.StringAttribute{
						Computed:            true,
						Description:         "The cost of this specific fee, including any applicable taxes, with precision.",
						MarkdownDescription: "The cost of this specific fee, including any applicable taxes, with precision.",
					},
					"precise_unit_amount": schema.StringAttribute{
						Computed:            true,
						Description:         "The unit amount of the fee per unit, with precision.",
						MarkdownDescription: "The unit amount of the fee per unit, with precision.",
					},
					"refunded_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date and time when the payment for the fee was refunded. It is provided in Coordinated Universal Time (UTC) format",
						MarkdownDescription: "The date and time when the payment for the fee was refunded. It is provided in Coordinated Universal Time (UTC) format",
					},
					"self_billed": schema.BoolAttribute{
						Computed:            true,
						Description:         "Indicates if the fee belongs to self-billed invoice. Self-billing is a process where an organization creates the invoice on behalf of the partner.",
						MarkdownDescription: "Indicates if the fee belongs to self-billed invoice. Self-billing is a process where an organization creates the invoice on behalf of the partner.",
					},
					"succeeded_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date and time when the payment for the fee was successfully processed. It is provided in Coordinated Universal Time (UTC) format.",
						MarkdownDescription: "The date and time when the payment for the fee was successfully processed. It is provided in Coordinated Universal Time (UTC) format.",
					},
					"taxes_amount_cents": schema.Int64Attribute{
						Computed:            true,
						Description:         "The cost of the tax associated with this specific fee.",
						MarkdownDescription: "The cost of the tax associated with this specific fee.",
					},
					"taxes_precise_amount": schema.StringAttribute{
						Computed:            true,
						Description:         "The cost of the tax associated with this specific fee, with precision.",
						MarkdownDescription: "The cost of the tax associated with this specific fee, with precision.",
					},
					"taxes_rate": schema.NumberAttribute{
						Computed:            true,
						Description:         "The tax rate associated with this specific fee.",
						MarkdownDescription: "The tax rate associated with this specific fee.",
					},
					"to_date": schema.StringAttribute{
						Computed:            true,
						Description:         "The ending date of the period that the fee covers. It is applicable only to `subscription` and `charge` fees. This field indicates the end date of the billing period or subscription period associated with the fee.",
						MarkdownDescription: "The ending date of the period that the fee covers. It is applicable only to `subscription` and `charge` fees. This field indicates the end date of the billing period or subscription period associated with the fee.",
					},
					"total_amount_cents": schema.Int64Attribute{
						Computed:            true,
						Description:         "The cost of this specific fee, including any applicable taxes.",
						MarkdownDescription: "The cost of this specific fee, including any applicable taxes.",
					},
					"total_amount_currency": schema.StringAttribute{
						Computed: true,
					},
					"units": schema.StringAttribute{
						Computed:            true,
						Description:         "The number of units used to charge the customer. This field indicates the quantity or count of units consumed or utilized in the context of the charge. It helps in determining the basis for calculating the fee or cost associated with the usage of the service or product provided to the customer.",
						MarkdownDescription: "The number of units used to charge the customer. This field indicates the quantity or count of units consumed or utilized in the context of the charge. It helps in determining the basis for calculating the fee or cost associated with the usage of the service or product provided to the customer.",
					},
				},
				CustomType: FeeType{
					ObjectType: types.ObjectType{
						AttrTypes: FeeValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"lago_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the fee's record within the Lago system.",
				MarkdownDescription: "Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the fee's record within the Lago system.",
			},
		},
	}
}

type FeesModel struct {
	Fee    FeeValue     `tfsdk:"fee"`
	LagoId types.String `tfsdk:"lago_id"`
}

var _ basetypes.ObjectTypable = FeeType{}

type FeeType struct {
	basetypes.ObjectType
}

func (t FeeType) Equal(o attr.Type) bool {
	other, ok := o.(FeeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FeeType) String() string {
	return "FeeType"
}

func (t FeeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return nil, diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	amountDetailsAttribute, ok := attributes["amount_details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_details is missing from object`)

		return nil, diags
	}

	amountDetailsVal, ok := amountDetailsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_details expected to be basetypes.ObjectValue, was: %T`, amountDetailsAttribute))
	}

	appliedTaxesAttribute, ok := attributes["applied_taxes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applied_taxes is missing from object`)

		return nil, diags
	}

	appliedTaxesVal, ok := appliedTaxesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applied_taxes expected to be basetypes.ListValue, was: %T`, appliedTaxesAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	eventTransactionIdAttribute, ok := attributes["event_transaction_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`event_transaction_id is missing from object`)

		return nil, diags
	}

	eventTransactionIdVal, ok := eventTransactionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`event_transaction_id expected to be basetypes.StringValue, was: %T`, eventTransactionIdAttribute))
	}

	eventsCountAttribute, ok := attributes["events_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`events_count is missing from object`)

		return nil, diags
	}

	eventsCountVal, ok := eventsCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`events_count expected to be basetypes.Int64Value, was: %T`, eventsCountAttribute))
	}

	externalCustomerIdAttribute, ok := attributes["external_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_customer_id is missing from object`)

		return nil, diags
	}

	externalCustomerIdVal, ok := externalCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_customer_id expected to be basetypes.StringValue, was: %T`, externalCustomerIdAttribute))
	}

	externalSubscriptionIdAttribute, ok := attributes["external_subscription_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_subscription_id is missing from object`)

		return nil, diags
	}

	externalSubscriptionIdVal, ok := externalSubscriptionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_subscription_id expected to be basetypes.StringValue, was: %T`, externalSubscriptionIdAttribute))
	}

	failedAtAttribute, ok := attributes["failed_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failed_at is missing from object`)

		return nil, diags
	}

	failedAtVal, ok := failedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failed_at expected to be basetypes.StringValue, was: %T`, failedAtAttribute))
	}

	fromDateAttribute, ok := attributes["from_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_date is missing from object`)

		return nil, diags
	}

	fromDateVal, ok := fromDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_date expected to be basetypes.StringValue, was: %T`, fromDateAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	invoiceableAttribute, ok := attributes["invoiceable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoiceable is missing from object`)

		return nil, diags
	}

	invoiceableVal, ok := invoiceableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoiceable expected to be basetypes.BoolValue, was: %T`, invoiceableAttribute))
	}

	itemAttribute, ok := attributes["item"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`item is missing from object`)

		return nil, diags
	}

	itemVal, ok := itemAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`item expected to be basetypes.ObjectValue, was: %T`, itemAttribute))
	}

	lagoChargeFilterIdAttribute, ok := attributes["lago_charge_filter_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_charge_filter_id is missing from object`)

		return nil, diags
	}

	lagoChargeFilterIdVal, ok := lagoChargeFilterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_charge_filter_id expected to be basetypes.StringValue, was: %T`, lagoChargeFilterIdAttribute))
	}

	lagoChargeIdAttribute, ok := attributes["lago_charge_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_charge_id is missing from object`)

		return nil, diags
	}

	lagoChargeIdVal, ok := lagoChargeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_charge_id expected to be basetypes.StringValue, was: %T`, lagoChargeIdAttribute))
	}

	lagoCustomerIdAttribute, ok := attributes["lago_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_customer_id is missing from object`)

		return nil, diags
	}

	lagoCustomerIdVal, ok := lagoCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_customer_id expected to be basetypes.StringValue, was: %T`, lagoCustomerIdAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lagoInvoiceIdAttribute, ok := attributes["lago_invoice_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_invoice_id is missing from object`)

		return nil, diags
	}

	lagoInvoiceIdVal, ok := lagoInvoiceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_invoice_id expected to be basetypes.StringValue, was: %T`, lagoInvoiceIdAttribute))
	}

	lagoSubscriptionIdAttribute, ok := attributes["lago_subscription_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_subscription_id is missing from object`)

		return nil, diags
	}

	lagoSubscriptionIdVal, ok := lagoSubscriptionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_subscription_id expected to be basetypes.StringValue, was: %T`, lagoSubscriptionIdAttribute))
	}

	lagoTrueUpFeeIdAttribute, ok := attributes["lago_true_up_fee_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_true_up_fee_id is missing from object`)

		return nil, diags
	}

	lagoTrueUpFeeIdVal, ok := lagoTrueUpFeeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_true_up_fee_id expected to be basetypes.StringValue, was: %T`, lagoTrueUpFeeIdAttribute))
	}

	lagoTrueUpParentFeeIdAttribute, ok := attributes["lago_true_up_parent_fee_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_true_up_parent_fee_id is missing from object`)

		return nil, diags
	}

	lagoTrueUpParentFeeIdVal, ok := lagoTrueUpParentFeeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_true_up_parent_fee_id expected to be basetypes.StringValue, was: %T`, lagoTrueUpParentFeeIdAttribute))
	}

	payInAdvanceAttribute, ok := attributes["pay_in_advance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pay_in_advance is missing from object`)

		return nil, diags
	}

	payInAdvanceVal, ok := payInAdvanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pay_in_advance expected to be basetypes.BoolValue, was: %T`, payInAdvanceAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return nil, diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	preciseAmountAttribute, ok := attributes["precise_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`precise_amount is missing from object`)

		return nil, diags
	}

	preciseAmountVal, ok := preciseAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`precise_amount expected to be basetypes.StringValue, was: %T`, preciseAmountAttribute))
	}

	preciseTotalAmountAttribute, ok := attributes["precise_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`precise_total_amount is missing from object`)

		return nil, diags
	}

	preciseTotalAmountVal, ok := preciseTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`precise_total_amount expected to be basetypes.StringValue, was: %T`, preciseTotalAmountAttribute))
	}

	preciseUnitAmountAttribute, ok := attributes["precise_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`precise_unit_amount is missing from object`)

		return nil, diags
	}

	preciseUnitAmountVal, ok := preciseUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`precise_unit_amount expected to be basetypes.StringValue, was: %T`, preciseUnitAmountAttribute))
	}

	refundedAtAttribute, ok := attributes["refunded_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`refunded_at is missing from object`)

		return nil, diags
	}

	refundedAtVal, ok := refundedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`refunded_at expected to be basetypes.StringValue, was: %T`, refundedAtAttribute))
	}

	selfBilledAttribute, ok := attributes["self_billed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self_billed is missing from object`)

		return nil, diags
	}

	selfBilledVal, ok := selfBilledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self_billed expected to be basetypes.BoolValue, was: %T`, selfBilledAttribute))
	}

	succeededAtAttribute, ok := attributes["succeeded_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`succeeded_at is missing from object`)

		return nil, diags
	}

	succeededAtVal, ok := succeededAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`succeeded_at expected to be basetypes.StringValue, was: %T`, succeededAtAttribute))
	}

	taxesAmountCentsAttribute, ok := attributes["taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes_amount_cents is missing from object`)

		return nil, diags
	}

	taxesAmountCentsVal, ok := taxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, taxesAmountCentsAttribute))
	}

	taxesPreciseAmountAttribute, ok := attributes["taxes_precise_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes_precise_amount is missing from object`)

		return nil, diags
	}

	taxesPreciseAmountVal, ok := taxesPreciseAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes_precise_amount expected to be basetypes.StringValue, was: %T`, taxesPreciseAmountAttribute))
	}

	taxesRateAttribute, ok := attributes["taxes_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes_rate is missing from object`)

		return nil, diags
	}

	taxesRateVal, ok := taxesRateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes_rate expected to be basetypes.NumberValue, was: %T`, taxesRateAttribute))
	}

	toDateAttribute, ok := attributes["to_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_date is missing from object`)

		return nil, diags
	}

	toDateVal, ok := toDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_date expected to be basetypes.StringValue, was: %T`, toDateAttribute))
	}

	totalAmountCentsAttribute, ok := attributes["total_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_amount_cents is missing from object`)

		return nil, diags
	}

	totalAmountCentsVal, ok := totalAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_amount_cents expected to be basetypes.Int64Value, was: %T`, totalAmountCentsAttribute))
	}

	totalAmountCurrencyAttribute, ok := attributes["total_amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_amount_currency is missing from object`)

		return nil, diags
	}

	totalAmountCurrencyVal, ok := totalAmountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_amount_currency expected to be basetypes.StringValue, was: %T`, totalAmountCurrencyAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return nil, diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FeeValue{
		AmountCents:            amountCentsVal,
		AmountCurrency:         amountCurrencyVal,
		AmountDetails:          amountDetailsVal,
		AppliedTaxes:           appliedTaxesVal,
		CreatedAt:              createdAtVal,
		EventTransactionId:     eventTransactionIdVal,
		EventsCount:            eventsCountVal,
		ExternalCustomerId:     externalCustomerIdVal,
		ExternalSubscriptionId: externalSubscriptionIdVal,
		FailedAt:               failedAtVal,
		FromDate:               fromDateVal,
		InvoiceDisplayName:     invoiceDisplayNameVal,
		Invoiceable:            invoiceableVal,
		Item:                   itemVal,
		LagoChargeFilterId:     lagoChargeFilterIdVal,
		LagoChargeId:           lagoChargeIdVal,
		LagoCustomerId:         lagoCustomerIdVal,
		LagoId:                 lagoIdVal,
		LagoInvoiceId:          lagoInvoiceIdVal,
		LagoSubscriptionId:     lagoSubscriptionIdVal,
		LagoTrueUpFeeId:        lagoTrueUpFeeIdVal,
		LagoTrueUpParentFeeId:  lagoTrueUpParentFeeIdVal,
		PayInAdvance:           payInAdvanceVal,
		PaymentStatus:          paymentStatusVal,
		PreciseAmount:          preciseAmountVal,
		PreciseTotalAmount:     preciseTotalAmountVal,
		PreciseUnitAmount:      preciseUnitAmountVal,
		RefundedAt:             refundedAtVal,
		SelfBilled:             selfBilledVal,
		SucceededAt:            succeededAtVal,
		TaxesAmountCents:       taxesAmountCentsVal,
		TaxesPreciseAmount:     taxesPreciseAmountVal,
		TaxesRate:              taxesRateVal,
		ToDate:                 toDateVal,
		TotalAmountCents:       totalAmountCentsVal,
		TotalAmountCurrency:    totalAmountCurrencyVal,
		Units:                  unitsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewFeeValueNull() FeeValue {
	return FeeValue{
		state: attr.ValueStateNull,
	}
}

func NewFeeValueUnknown() FeeValue {
	return FeeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFeeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FeeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FeeValue Attribute Value",
				"While creating a FeeValue value, a missing attribute value was detected. "+
					"A FeeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FeeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FeeValue Attribute Type",
				"While creating a FeeValue value, an invalid attribute value was detected. "+
					"A FeeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FeeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FeeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FeeValue Attribute Value",
				"While creating a FeeValue value, an extra attribute value was detected. "+
					"A FeeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FeeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFeeValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	amountDetailsAttribute, ok := attributes["amount_details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_details is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	amountDetailsVal, ok := amountDetailsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_details expected to be basetypes.ObjectValue, was: %T`, amountDetailsAttribute))
	}

	appliedTaxesAttribute, ok := attributes["applied_taxes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applied_taxes is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	appliedTaxesVal, ok := appliedTaxesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applied_taxes expected to be basetypes.ListValue, was: %T`, appliedTaxesAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	eventTransactionIdAttribute, ok := attributes["event_transaction_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`event_transaction_id is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	eventTransactionIdVal, ok := eventTransactionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`event_transaction_id expected to be basetypes.StringValue, was: %T`, eventTransactionIdAttribute))
	}

	eventsCountAttribute, ok := attributes["events_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`events_count is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	eventsCountVal, ok := eventsCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`events_count expected to be basetypes.Int64Value, was: %T`, eventsCountAttribute))
	}

	externalCustomerIdAttribute, ok := attributes["external_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_customer_id is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	externalCustomerIdVal, ok := externalCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_customer_id expected to be basetypes.StringValue, was: %T`, externalCustomerIdAttribute))
	}

	externalSubscriptionIdAttribute, ok := attributes["external_subscription_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_subscription_id is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	externalSubscriptionIdVal, ok := externalSubscriptionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_subscription_id expected to be basetypes.StringValue, was: %T`, externalSubscriptionIdAttribute))
	}

	failedAtAttribute, ok := attributes["failed_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failed_at is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	failedAtVal, ok := failedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failed_at expected to be basetypes.StringValue, was: %T`, failedAtAttribute))
	}

	fromDateAttribute, ok := attributes["from_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_date is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	fromDateVal, ok := fromDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_date expected to be basetypes.StringValue, was: %T`, fromDateAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	invoiceableAttribute, ok := attributes["invoiceable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoiceable is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	invoiceableVal, ok := invoiceableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoiceable expected to be basetypes.BoolValue, was: %T`, invoiceableAttribute))
	}

	itemAttribute, ok := attributes["item"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`item is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	itemVal, ok := itemAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`item expected to be basetypes.ObjectValue, was: %T`, itemAttribute))
	}

	lagoChargeFilterIdAttribute, ok := attributes["lago_charge_filter_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_charge_filter_id is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	lagoChargeFilterIdVal, ok := lagoChargeFilterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_charge_filter_id expected to be basetypes.StringValue, was: %T`, lagoChargeFilterIdAttribute))
	}

	lagoChargeIdAttribute, ok := attributes["lago_charge_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_charge_id is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	lagoChargeIdVal, ok := lagoChargeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_charge_id expected to be basetypes.StringValue, was: %T`, lagoChargeIdAttribute))
	}

	lagoCustomerIdAttribute, ok := attributes["lago_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_customer_id is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	lagoCustomerIdVal, ok := lagoCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_customer_id expected to be basetypes.StringValue, was: %T`, lagoCustomerIdAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lagoInvoiceIdAttribute, ok := attributes["lago_invoice_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_invoice_id is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	lagoInvoiceIdVal, ok := lagoInvoiceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_invoice_id expected to be basetypes.StringValue, was: %T`, lagoInvoiceIdAttribute))
	}

	lagoSubscriptionIdAttribute, ok := attributes["lago_subscription_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_subscription_id is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	lagoSubscriptionIdVal, ok := lagoSubscriptionIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_subscription_id expected to be basetypes.StringValue, was: %T`, lagoSubscriptionIdAttribute))
	}

	lagoTrueUpFeeIdAttribute, ok := attributes["lago_true_up_fee_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_true_up_fee_id is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	lagoTrueUpFeeIdVal, ok := lagoTrueUpFeeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_true_up_fee_id expected to be basetypes.StringValue, was: %T`, lagoTrueUpFeeIdAttribute))
	}

	lagoTrueUpParentFeeIdAttribute, ok := attributes["lago_true_up_parent_fee_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_true_up_parent_fee_id is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	lagoTrueUpParentFeeIdVal, ok := lagoTrueUpParentFeeIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_true_up_parent_fee_id expected to be basetypes.StringValue, was: %T`, lagoTrueUpParentFeeIdAttribute))
	}

	payInAdvanceAttribute, ok := attributes["pay_in_advance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pay_in_advance is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	payInAdvanceVal, ok := payInAdvanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pay_in_advance expected to be basetypes.BoolValue, was: %T`, payInAdvanceAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	preciseAmountAttribute, ok := attributes["precise_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`precise_amount is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	preciseAmountVal, ok := preciseAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`precise_amount expected to be basetypes.StringValue, was: %T`, preciseAmountAttribute))
	}

	preciseTotalAmountAttribute, ok := attributes["precise_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`precise_total_amount is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	preciseTotalAmountVal, ok := preciseTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`precise_total_amount expected to be basetypes.StringValue, was: %T`, preciseTotalAmountAttribute))
	}

	preciseUnitAmountAttribute, ok := attributes["precise_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`precise_unit_amount is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	preciseUnitAmountVal, ok := preciseUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`precise_unit_amount expected to be basetypes.StringValue, was: %T`, preciseUnitAmountAttribute))
	}

	refundedAtAttribute, ok := attributes["refunded_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`refunded_at is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	refundedAtVal, ok := refundedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`refunded_at expected to be basetypes.StringValue, was: %T`, refundedAtAttribute))
	}

	selfBilledAttribute, ok := attributes["self_billed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self_billed is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	selfBilledVal, ok := selfBilledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self_billed expected to be basetypes.BoolValue, was: %T`, selfBilledAttribute))
	}

	succeededAtAttribute, ok := attributes["succeeded_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`succeeded_at is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	succeededAtVal, ok := succeededAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`succeeded_at expected to be basetypes.StringValue, was: %T`, succeededAtAttribute))
	}

	taxesAmountCentsAttribute, ok := attributes["taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes_amount_cents is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	taxesAmountCentsVal, ok := taxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, taxesAmountCentsAttribute))
	}

	taxesPreciseAmountAttribute, ok := attributes["taxes_precise_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes_precise_amount is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	taxesPreciseAmountVal, ok := taxesPreciseAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes_precise_amount expected to be basetypes.StringValue, was: %T`, taxesPreciseAmountAttribute))
	}

	taxesRateAttribute, ok := attributes["taxes_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes_rate is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	taxesRateVal, ok := taxesRateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes_rate expected to be basetypes.NumberValue, was: %T`, taxesRateAttribute))
	}

	toDateAttribute, ok := attributes["to_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_date is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	toDateVal, ok := toDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_date expected to be basetypes.StringValue, was: %T`, toDateAttribute))
	}

	totalAmountCentsAttribute, ok := attributes["total_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_amount_cents is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	totalAmountCentsVal, ok := totalAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_amount_cents expected to be basetypes.Int64Value, was: %T`, totalAmountCentsAttribute))
	}

	totalAmountCurrencyAttribute, ok := attributes["total_amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_amount_currency is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	totalAmountCurrencyVal, ok := totalAmountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_amount_currency expected to be basetypes.StringValue, was: %T`, totalAmountCurrencyAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return NewFeeValueUnknown(), diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	if diags.HasError() {
		return NewFeeValueUnknown(), diags
	}

	return FeeValue{
		AmountCents:            amountCentsVal,
		AmountCurrency:         amountCurrencyVal,
		AmountDetails:          amountDetailsVal,
		AppliedTaxes:           appliedTaxesVal,
		CreatedAt:              createdAtVal,
		EventTransactionId:     eventTransactionIdVal,
		EventsCount:            eventsCountVal,
		ExternalCustomerId:     externalCustomerIdVal,
		ExternalSubscriptionId: externalSubscriptionIdVal,
		FailedAt:               failedAtVal,
		FromDate:               fromDateVal,
		InvoiceDisplayName:     invoiceDisplayNameVal,
		Invoiceable:            invoiceableVal,
		Item:                   itemVal,
		LagoChargeFilterId:     lagoChargeFilterIdVal,
		LagoChargeId:           lagoChargeIdVal,
		LagoCustomerId:         lagoCustomerIdVal,
		LagoId:                 lagoIdVal,
		LagoInvoiceId:          lagoInvoiceIdVal,
		LagoSubscriptionId:     lagoSubscriptionIdVal,
		LagoTrueUpFeeId:        lagoTrueUpFeeIdVal,
		LagoTrueUpParentFeeId:  lagoTrueUpParentFeeIdVal,
		PayInAdvance:           payInAdvanceVal,
		PaymentStatus:          paymentStatusVal,
		PreciseAmount:          preciseAmountVal,
		PreciseTotalAmount:     preciseTotalAmountVal,
		PreciseUnitAmount:      preciseUnitAmountVal,
		RefundedAt:             refundedAtVal,
		SelfBilled:             selfBilledVal,
		SucceededAt:            succeededAtVal,
		TaxesAmountCents:       taxesAmountCentsVal,
		TaxesPreciseAmount:     taxesPreciseAmountVal,
		TaxesRate:              taxesRateVal,
		ToDate:                 toDateVal,
		TotalAmountCents:       totalAmountCentsVal,
		TotalAmountCurrency:    totalAmountCurrencyVal,
		Units:                  unitsVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewFeeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FeeValue {
	object, diags := NewFeeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFeeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FeeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFeeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFeeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFeeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFeeValueMust(FeeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FeeType) ValueType(ctx context.Context) attr.Value {
	return FeeValue{}
}

var _ basetypes.ObjectValuable = FeeValue{}

type FeeValue struct {
	AmountCents            basetypes.Int64Value  `tfsdk:"amount_cents"`
	AmountCurrency         basetypes.StringValue `tfsdk:"amount_currency"`
	AmountDetails          basetypes.ObjectValue `tfsdk:"amount_details"`
	AppliedTaxes           basetypes.ListValue   `tfsdk:"applied_taxes"`
	CreatedAt              basetypes.StringValue `tfsdk:"created_at"`
	EventTransactionId     basetypes.StringValue `tfsdk:"event_transaction_id"`
	EventsCount            basetypes.Int64Value  `tfsdk:"events_count"`
	ExternalCustomerId     basetypes.StringValue `tfsdk:"external_customer_id"`
	ExternalSubscriptionId basetypes.StringValue `tfsdk:"external_subscription_id"`
	FailedAt               basetypes.StringValue `tfsdk:"failed_at"`
	FromDate               basetypes.StringValue `tfsdk:"from_date"`
	InvoiceDisplayName     basetypes.StringValue `tfsdk:"invoice_display_name"`
	Invoiceable            basetypes.BoolValue   `tfsdk:"invoiceable"`
	Item                   basetypes.ObjectValue `tfsdk:"item"`
	LagoChargeFilterId     basetypes.StringValue `tfsdk:"lago_charge_filter_id"`
	LagoChargeId           basetypes.StringValue `tfsdk:"lago_charge_id"`
	LagoCustomerId         basetypes.StringValue `tfsdk:"lago_customer_id"`
	LagoId                 basetypes.StringValue `tfsdk:"lago_id"`
	LagoInvoiceId          basetypes.StringValue `tfsdk:"lago_invoice_id"`
	LagoSubscriptionId     basetypes.StringValue `tfsdk:"lago_subscription_id"`
	LagoTrueUpFeeId        basetypes.StringValue `tfsdk:"lago_true_up_fee_id"`
	LagoTrueUpParentFeeId  basetypes.StringValue `tfsdk:"lago_true_up_parent_fee_id"`
	PayInAdvance           basetypes.BoolValue   `tfsdk:"pay_in_advance"`
	PaymentStatus          basetypes.StringValue `tfsdk:"payment_status"`
	PreciseAmount          basetypes.StringValue `tfsdk:"precise_amount"`
	PreciseTotalAmount     basetypes.StringValue `tfsdk:"precise_total_amount"`
	PreciseUnitAmount      basetypes.StringValue `tfsdk:"precise_unit_amount"`
	RefundedAt             basetypes.StringValue `tfsdk:"refunded_at"`
	SelfBilled             basetypes.BoolValue   `tfsdk:"self_billed"`
	SucceededAt            basetypes.StringValue `tfsdk:"succeeded_at"`
	TaxesAmountCents       basetypes.Int64Value  `tfsdk:"taxes_amount_cents"`
	TaxesPreciseAmount     basetypes.StringValue `tfsdk:"taxes_precise_amount"`
	TaxesRate              basetypes.NumberValue `tfsdk:"taxes_rate"`
	ToDate                 basetypes.StringValue `tfsdk:"to_date"`
	TotalAmountCents       basetypes.Int64Value  `tfsdk:"total_amount_cents"`
	TotalAmountCurrency    basetypes.StringValue `tfsdk:"total_amount_currency"`
	Units                  basetypes.StringValue `tfsdk:"units"`
	state                  attr.ValueState
}

func (v FeeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 37)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["amount_currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["amount_details"] = basetypes.ObjectType{
		AttrTypes: AmountDetailsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["applied_taxes"] = basetypes.ListType{
		ElemType: AppliedTaxesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["event_transaction_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["events_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["external_customer_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_subscription_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["failed_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoiceable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["item"] = basetypes.ObjectType{
		AttrTypes: ItemValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["lago_charge_filter_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_charge_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_customer_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_invoice_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_subscription_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_true_up_fee_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_true_up_parent_fee_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pay_in_advance"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["payment_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["precise_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["precise_total_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["precise_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["refunded_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["self_billed"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["succeeded_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["taxes_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["taxes_precise_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["taxes_rate"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["to_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["total_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_amount_currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["units"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 37)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.AmountCurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_currency"] = val

		val, err = v.AmountDetails.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_details"] = val

		val, err = v.AppliedTaxes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["applied_taxes"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.EventTransactionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["event_transaction_id"] = val

		val, err = v.EventsCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["events_count"] = val

		val, err = v.ExternalCustomerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_customer_id"] = val

		val, err = v.ExternalSubscriptionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_subscription_id"] = val

		val, err = v.FailedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["failed_at"] = val

		val, err = v.FromDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_date"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.Invoiceable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoiceable"] = val

		val, err = v.Item.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["item"] = val

		val, err = v.LagoChargeFilterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_charge_filter_id"] = val

		val, err = v.LagoChargeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_charge_id"] = val

		val, err = v.LagoCustomerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_customer_id"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.LagoInvoiceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_invoice_id"] = val

		val, err = v.LagoSubscriptionId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_subscription_id"] = val

		val, err = v.LagoTrueUpFeeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_true_up_fee_id"] = val

		val, err = v.LagoTrueUpParentFeeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_true_up_parent_fee_id"] = val

		val, err = v.PayInAdvance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pay_in_advance"] = val

		val, err = v.PaymentStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_status"] = val

		val, err = v.PreciseAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["precise_amount"] = val

		val, err = v.PreciseTotalAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["precise_total_amount"] = val

		val, err = v.PreciseUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["precise_unit_amount"] = val

		val, err = v.RefundedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["refunded_at"] = val

		val, err = v.SelfBilled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["self_billed"] = val

		val, err = v.SucceededAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["succeeded_at"] = val

		val, err = v.TaxesAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taxes_amount_cents"] = val

		val, err = v.TaxesPreciseAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taxes_precise_amount"] = val

		val, err = v.TaxesRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taxes_rate"] = val

		val, err = v.ToDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_date"] = val

		val, err = v.TotalAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_amount_cents"] = val

		val, err = v.TotalAmountCurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_amount_currency"] = val

		val, err = v.Units.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["units"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FeeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FeeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FeeValue) String() string {
	return "FeeValue"
}

func (v FeeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var amountDetails basetypes.ObjectValue

	if v.AmountDetails.IsNull() {
		amountDetails = types.ObjectNull(
			AmountDetailsValue{}.AttributeTypes(ctx),
		)
	}

	if v.AmountDetails.IsUnknown() {
		amountDetails = types.ObjectUnknown(
			AmountDetailsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AmountDetails.IsNull() && !v.AmountDetails.IsUnknown() {
		amountDetails = types.ObjectValueMust(
			AmountDetailsValue{}.AttributeTypes(ctx),
			v.AmountDetails.Attributes(),
		)
	}

	appliedTaxes := types.ListValueMust(
		AppliedTaxesType{
			basetypes.ObjectType{
				AttrTypes: AppliedTaxesValue{}.AttributeTypes(ctx),
			},
		},
		v.AppliedTaxes.Elements(),
	)

	if v.AppliedTaxes.IsNull() {
		appliedTaxes = types.ListNull(
			AppliedTaxesType{
				basetypes.ObjectType{
					AttrTypes: AppliedTaxesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AppliedTaxes.IsUnknown() {
		appliedTaxes = types.ListUnknown(
			AppliedTaxesType{
				basetypes.ObjectType{
					AttrTypes: AppliedTaxesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var item basetypes.ObjectValue

	if v.Item.IsNull() {
		item = types.ObjectNull(
			ItemValue{}.AttributeTypes(ctx),
		)
	}

	if v.Item.IsUnknown() {
		item = types.ObjectUnknown(
			ItemValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Item.IsNull() && !v.Item.IsUnknown() {
		item = types.ObjectValueMust(
			ItemValue{}.AttributeTypes(ctx),
			v.Item.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"amount_details": basetypes.ObjectType{
			AttrTypes: AmountDetailsValue{}.AttributeTypes(ctx),
		},
		"applied_taxes": basetypes.ListType{
			ElemType: AppliedTaxesValue{}.Type(ctx),
		},
		"created_at":               basetypes.StringType{},
		"event_transaction_id":     basetypes.StringType{},
		"events_count":             basetypes.Int64Type{},
		"external_customer_id":     basetypes.StringType{},
		"external_subscription_id": basetypes.StringType{},
		"failed_at":                basetypes.StringType{},
		"from_date":                basetypes.StringType{},
		"invoice_display_name":     basetypes.StringType{},
		"invoiceable":              basetypes.BoolType{},
		"item": basetypes.ObjectType{
			AttrTypes: ItemValue{}.AttributeTypes(ctx),
		},
		"lago_charge_filter_id":      basetypes.StringType{},
		"lago_charge_id":             basetypes.StringType{},
		"lago_customer_id":           basetypes.StringType{},
		"lago_id":                    basetypes.StringType{},
		"lago_invoice_id":            basetypes.StringType{},
		"lago_subscription_id":       basetypes.StringType{},
		"lago_true_up_fee_id":        basetypes.StringType{},
		"lago_true_up_parent_fee_id": basetypes.StringType{},
		"pay_in_advance":             basetypes.BoolType{},
		"payment_status":             basetypes.StringType{},
		"precise_amount":             basetypes.StringType{},
		"precise_total_amount":       basetypes.StringType{},
		"precise_unit_amount":        basetypes.StringType{},
		"refunded_at":                basetypes.StringType{},
		"self_billed":                basetypes.BoolType{},
		"succeeded_at":               basetypes.StringType{},
		"taxes_amount_cents":         basetypes.Int64Type{},
		"taxes_precise_amount":       basetypes.StringType{},
		"taxes_rate":                 basetypes.NumberType{},
		"to_date":                    basetypes.StringType{},
		"total_amount_cents":         basetypes.Int64Type{},
		"total_amount_currency":      basetypes.StringType{},
		"units":                      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":               v.AmountCents,
			"amount_currency":            v.AmountCurrency,
			"amount_details":             amountDetails,
			"applied_taxes":              appliedTaxes,
			"created_at":                 v.CreatedAt,
			"event_transaction_id":       v.EventTransactionId,
			"events_count":               v.EventsCount,
			"external_customer_id":       v.ExternalCustomerId,
			"external_subscription_id":   v.ExternalSubscriptionId,
			"failed_at":                  v.FailedAt,
			"from_date":                  v.FromDate,
			"invoice_display_name":       v.InvoiceDisplayName,
			"invoiceable":                v.Invoiceable,
			"item":                       item,
			"lago_charge_filter_id":      v.LagoChargeFilterId,
			"lago_charge_id":             v.LagoChargeId,
			"lago_customer_id":           v.LagoCustomerId,
			"lago_id":                    v.LagoId,
			"lago_invoice_id":            v.LagoInvoiceId,
			"lago_subscription_id":       v.LagoSubscriptionId,
			"lago_true_up_fee_id":        v.LagoTrueUpFeeId,
			"lago_true_up_parent_fee_id": v.LagoTrueUpParentFeeId,
			"pay_in_advance":             v.PayInAdvance,
			"payment_status":             v.PaymentStatus,
			"precise_amount":             v.PreciseAmount,
			"precise_total_amount":       v.PreciseTotalAmount,
			"precise_unit_amount":        v.PreciseUnitAmount,
			"refunded_at":                v.RefundedAt,
			"self_billed":                v.SelfBilled,
			"succeeded_at":               v.SucceededAt,
			"taxes_amount_cents":         v.TaxesAmountCents,
			"taxes_precise_amount":       v.TaxesPreciseAmount,
			"taxes_rate":                 v.TaxesRate,
			"to_date":                    v.ToDate,
			"total_amount_cents":         v.TotalAmountCents,
			"total_amount_currency":      v.TotalAmountCurrency,
			"units":                      v.Units,
		})

	return objVal, diags
}

func (v FeeValue) Equal(o attr.Value) bool {
	other, ok := o.(FeeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.AmountCurrency.Equal(other.AmountCurrency) {
		return false
	}

	if !v.AmountDetails.Equal(other.AmountDetails) {
		return false
	}

	if !v.AppliedTaxes.Equal(other.AppliedTaxes) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.EventTransactionId.Equal(other.EventTransactionId) {
		return false
	}

	if !v.EventsCount.Equal(other.EventsCount) {
		return false
	}

	if !v.ExternalCustomerId.Equal(other.ExternalCustomerId) {
		return false
	}

	if !v.ExternalSubscriptionId.Equal(other.ExternalSubscriptionId) {
		return false
	}

	if !v.FailedAt.Equal(other.FailedAt) {
		return false
	}

	if !v.FromDate.Equal(other.FromDate) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.Invoiceable.Equal(other.Invoiceable) {
		return false
	}

	if !v.Item.Equal(other.Item) {
		return false
	}

	if !v.LagoChargeFilterId.Equal(other.LagoChargeFilterId) {
		return false
	}

	if !v.LagoChargeId.Equal(other.LagoChargeId) {
		return false
	}

	if !v.LagoCustomerId.Equal(other.LagoCustomerId) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.LagoInvoiceId.Equal(other.LagoInvoiceId) {
		return false
	}

	if !v.LagoSubscriptionId.Equal(other.LagoSubscriptionId) {
		return false
	}

	if !v.LagoTrueUpFeeId.Equal(other.LagoTrueUpFeeId) {
		return false
	}

	if !v.LagoTrueUpParentFeeId.Equal(other.LagoTrueUpParentFeeId) {
		return false
	}

	if !v.PayInAdvance.Equal(other.PayInAdvance) {
		return false
	}

	if !v.PaymentStatus.Equal(other.PaymentStatus) {
		return false
	}

	if !v.PreciseAmount.Equal(other.PreciseAmount) {
		return false
	}

	if !v.PreciseTotalAmount.Equal(other.PreciseTotalAmount) {
		return false
	}

	if !v.PreciseUnitAmount.Equal(other.PreciseUnitAmount) {
		return false
	}

	if !v.RefundedAt.Equal(other.RefundedAt) {
		return false
	}

	if !v.SelfBilled.Equal(other.SelfBilled) {
		return false
	}

	if !v.SucceededAt.Equal(other.SucceededAt) {
		return false
	}

	if !v.TaxesAmountCents.Equal(other.TaxesAmountCents) {
		return false
	}

	if !v.TaxesPreciseAmount.Equal(other.TaxesPreciseAmount) {
		return false
	}

	if !v.TaxesRate.Equal(other.TaxesRate) {
		return false
	}

	if !v.ToDate.Equal(other.ToDate) {
		return false
	}

	if !v.TotalAmountCents.Equal(other.TotalAmountCents) {
		return false
	}

	if !v.TotalAmountCurrency.Equal(other.TotalAmountCurrency) {
		return false
	}

	if !v.Units.Equal(other.Units) {
		return false
	}

	return true
}

func (v FeeValue) Type(ctx context.Context) attr.Type {
	return FeeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FeeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"amount_details": basetypes.ObjectType{
			AttrTypes: AmountDetailsValue{}.AttributeTypes(ctx),
		},
		"applied_taxes": basetypes.ListType{
			ElemType: AppliedTaxesValue{}.Type(ctx),
		},
		"created_at":               basetypes.StringType{},
		"event_transaction_id":     basetypes.StringType{},
		"events_count":             basetypes.Int64Type{},
		"external_customer_id":     basetypes.StringType{},
		"external_subscription_id": basetypes.StringType{},
		"failed_at":                basetypes.StringType{},
		"from_date":                basetypes.StringType{},
		"invoice_display_name":     basetypes.StringType{},
		"invoiceable":              basetypes.BoolType{},
		"item": basetypes.ObjectType{
			AttrTypes: ItemValue{}.AttributeTypes(ctx),
		},
		"lago_charge_filter_id":      basetypes.StringType{},
		"lago_charge_id":             basetypes.StringType{},
		"lago_customer_id":           basetypes.StringType{},
		"lago_id":                    basetypes.StringType{},
		"lago_invoice_id":            basetypes.StringType{},
		"lago_subscription_id":       basetypes.StringType{},
		"lago_true_up_fee_id":        basetypes.StringType{},
		"lago_true_up_parent_fee_id": basetypes.StringType{},
		"pay_in_advance":             basetypes.BoolType{},
		"payment_status":             basetypes.StringType{},
		"precise_amount":             basetypes.StringType{},
		"precise_total_amount":       basetypes.StringType{},
		"precise_unit_amount":        basetypes.StringType{},
		"refunded_at":                basetypes.StringType{},
		"self_billed":                basetypes.BoolType{},
		"succeeded_at":               basetypes.StringType{},
		"taxes_amount_cents":         basetypes.Int64Type{},
		"taxes_precise_amount":       basetypes.StringType{},
		"taxes_rate":                 basetypes.NumberType{},
		"to_date":                    basetypes.StringType{},
		"total_amount_cents":         basetypes.Int64Type{},
		"total_amount_currency":      basetypes.StringType{},
		"units":                      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AmountDetailsType{}

type AmountDetailsType struct {
	basetypes.ObjectType
}

func (t AmountDetailsType) Equal(o attr.Type) bool {
	other, ok := o.(AmountDetailsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AmountDetailsType) String() string {
	return "AmountDetailsType"
}

func (t AmountDetailsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fixedFeeTotalAmountAttribute, ok := attributes["fixed_fee_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_fee_total_amount is missing from object`)

		return nil, diags
	}

	fixedFeeTotalAmountVal, ok := fixedFeeTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_fee_total_amount expected to be basetypes.StringValue, was: %T`, fixedFeeTotalAmountAttribute))
	}

	fixedFeeUnitAmountAttribute, ok := attributes["fixed_fee_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_fee_unit_amount is missing from object`)

		return nil, diags
	}

	fixedFeeUnitAmountVal, ok := fixedFeeUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_fee_unit_amount expected to be basetypes.StringValue, was: %T`, fixedFeeUnitAmountAttribute))
	}

	freeEventsAttribute, ok := attributes["free_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_events is missing from object`)

		return nil, diags
	}

	freeEventsVal, ok := freeEventsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_events expected to be basetypes.Int64Value, was: %T`, freeEventsAttribute))
	}

	freeUnitsAttribute, ok := attributes["free_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units is missing from object`)

		return nil, diags
	}

	freeUnitsVal, ok := freeUnitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units expected to be basetypes.StringValue, was: %T`, freeUnitsAttribute))
	}

	graduatedPercentageRangesAttribute, ok := attributes["graduated_percentage_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_percentage_ranges is missing from object`)

		return nil, diags
	}

	graduatedPercentageRangesVal, ok := graduatedPercentageRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_percentage_ranges expected to be basetypes.ListValue, was: %T`, graduatedPercentageRangesAttribute))
	}

	graduatedRangesAttribute, ok := attributes["graduated_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_ranges is missing from object`)

		return nil, diags
	}

	graduatedRangesVal, ok := graduatedRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_ranges expected to be basetypes.ListValue, was: %T`, graduatedRangesAttribute))
	}

	minMaxAdjustmentTotalAmountAttribute, ok := attributes["min_max_adjustment_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_max_adjustment_total_amount is missing from object`)

		return nil, diags
	}

	minMaxAdjustmentTotalAmountVal, ok := minMaxAdjustmentTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_max_adjustment_total_amount expected to be basetypes.StringValue, was: %T`, minMaxAdjustmentTotalAmountAttribute))
	}

	paidEventsAttribute, ok := attributes["paid_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paid_events is missing from object`)

		return nil, diags
	}

	paidEventsVal, ok := paidEventsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paid_events expected to be basetypes.Int64Value, was: %T`, paidEventsAttribute))
	}

	paidUnitsAttribute, ok := attributes["paid_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paid_units is missing from object`)

		return nil, diags
	}

	paidUnitsVal, ok := paidUnitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paid_units expected to be basetypes.StringValue, was: %T`, paidUnitsAttribute))
	}

	perPackageSizeAttribute, ok := attributes["per_package_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_package_size is missing from object`)

		return nil, diags
	}

	perPackageSizeVal, ok := perPackageSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_package_size expected to be basetypes.Int64Value, was: %T`, perPackageSizeAttribute))
	}

	perPackageUnitAmountAttribute, ok := attributes["per_package_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_package_unit_amount is missing from object`)

		return nil, diags
	}

	perPackageUnitAmountVal, ok := perPackageUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_package_unit_amount expected to be basetypes.StringValue, was: %T`, perPackageUnitAmountAttribute))
	}

	perUnitTotalAmountAttribute, ok := attributes["per_unit_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_total_amount is missing from object`)

		return nil, diags
	}

	perUnitTotalAmountVal, ok := perUnitTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_total_amount expected to be basetypes.StringValue, was: %T`, perUnitTotalAmountAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return nil, diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	volumeRangesAttribute, ok := attributes["volume_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_ranges is missing from object`)

		return nil, diags
	}

	volumeRangesVal, ok := volumeRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_ranges expected to be basetypes.ListValue, was: %T`, volumeRangesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AmountDetailsValue{
		FixedFeeTotalAmount:         fixedFeeTotalAmountVal,
		FixedFeeUnitAmount:          fixedFeeUnitAmountVal,
		FreeEvents:                  freeEventsVal,
		FreeUnits:                   freeUnitsVal,
		GraduatedPercentageRanges:   graduatedPercentageRangesVal,
		GraduatedRanges:             graduatedRangesVal,
		MinMaxAdjustmentTotalAmount: minMaxAdjustmentTotalAmountVal,
		PaidEvents:                  paidEventsVal,
		PaidUnits:                   paidUnitsVal,
		PerPackageSize:              perPackageSizeVal,
		PerPackageUnitAmount:        perPackageUnitAmountVal,
		PerUnitTotalAmount:          perUnitTotalAmountVal,
		Rate:                        rateVal,
		Units:                       unitsVal,
		VolumeRanges:                volumeRangesVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewAmountDetailsValueNull() AmountDetailsValue {
	return AmountDetailsValue{
		state: attr.ValueStateNull,
	}
}

func NewAmountDetailsValueUnknown() AmountDetailsValue {
	return AmountDetailsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAmountDetailsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AmountDetailsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AmountDetailsValue Attribute Value",
				"While creating a AmountDetailsValue value, a missing attribute value was detected. "+
					"A AmountDetailsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AmountDetailsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AmountDetailsValue Attribute Type",
				"While creating a AmountDetailsValue value, an invalid attribute value was detected. "+
					"A AmountDetailsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AmountDetailsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AmountDetailsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AmountDetailsValue Attribute Value",
				"While creating a AmountDetailsValue value, an extra attribute value was detected. "+
					"A AmountDetailsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AmountDetailsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAmountDetailsValueUnknown(), diags
	}

	fixedFeeTotalAmountAttribute, ok := attributes["fixed_fee_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_fee_total_amount is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	fixedFeeTotalAmountVal, ok := fixedFeeTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_fee_total_amount expected to be basetypes.StringValue, was: %T`, fixedFeeTotalAmountAttribute))
	}

	fixedFeeUnitAmountAttribute, ok := attributes["fixed_fee_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_fee_unit_amount is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	fixedFeeUnitAmountVal, ok := fixedFeeUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_fee_unit_amount expected to be basetypes.StringValue, was: %T`, fixedFeeUnitAmountAttribute))
	}

	freeEventsAttribute, ok := attributes["free_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_events is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	freeEventsVal, ok := freeEventsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_events expected to be basetypes.Int64Value, was: %T`, freeEventsAttribute))
	}

	freeUnitsAttribute, ok := attributes["free_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	freeUnitsVal, ok := freeUnitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units expected to be basetypes.StringValue, was: %T`, freeUnitsAttribute))
	}

	graduatedPercentageRangesAttribute, ok := attributes["graduated_percentage_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_percentage_ranges is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	graduatedPercentageRangesVal, ok := graduatedPercentageRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_percentage_ranges expected to be basetypes.ListValue, was: %T`, graduatedPercentageRangesAttribute))
	}

	graduatedRangesAttribute, ok := attributes["graduated_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_ranges is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	graduatedRangesVal, ok := graduatedRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_ranges expected to be basetypes.ListValue, was: %T`, graduatedRangesAttribute))
	}

	minMaxAdjustmentTotalAmountAttribute, ok := attributes["min_max_adjustment_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_max_adjustment_total_amount is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	minMaxAdjustmentTotalAmountVal, ok := minMaxAdjustmentTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_max_adjustment_total_amount expected to be basetypes.StringValue, was: %T`, minMaxAdjustmentTotalAmountAttribute))
	}

	paidEventsAttribute, ok := attributes["paid_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paid_events is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	paidEventsVal, ok := paidEventsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paid_events expected to be basetypes.Int64Value, was: %T`, paidEventsAttribute))
	}

	paidUnitsAttribute, ok := attributes["paid_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paid_units is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	paidUnitsVal, ok := paidUnitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paid_units expected to be basetypes.StringValue, was: %T`, paidUnitsAttribute))
	}

	perPackageSizeAttribute, ok := attributes["per_package_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_package_size is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	perPackageSizeVal, ok := perPackageSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_package_size expected to be basetypes.Int64Value, was: %T`, perPackageSizeAttribute))
	}

	perPackageUnitAmountAttribute, ok := attributes["per_package_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_package_unit_amount is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	perPackageUnitAmountVal, ok := perPackageUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_package_unit_amount expected to be basetypes.StringValue, was: %T`, perPackageUnitAmountAttribute))
	}

	perUnitTotalAmountAttribute, ok := attributes["per_unit_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_total_amount is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	perUnitTotalAmountVal, ok := perUnitTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_total_amount expected to be basetypes.StringValue, was: %T`, perUnitTotalAmountAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	volumeRangesAttribute, ok := attributes["volume_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_ranges is missing from object`)

		return NewAmountDetailsValueUnknown(), diags
	}

	volumeRangesVal, ok := volumeRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_ranges expected to be basetypes.ListValue, was: %T`, volumeRangesAttribute))
	}

	if diags.HasError() {
		return NewAmountDetailsValueUnknown(), diags
	}

	return AmountDetailsValue{
		FixedFeeTotalAmount:         fixedFeeTotalAmountVal,
		FixedFeeUnitAmount:          fixedFeeUnitAmountVal,
		FreeEvents:                  freeEventsVal,
		FreeUnits:                   freeUnitsVal,
		GraduatedPercentageRanges:   graduatedPercentageRangesVal,
		GraduatedRanges:             graduatedRangesVal,
		MinMaxAdjustmentTotalAmount: minMaxAdjustmentTotalAmountVal,
		PaidEvents:                  paidEventsVal,
		PaidUnits:                   paidUnitsVal,
		PerPackageSize:              perPackageSizeVal,
		PerPackageUnitAmount:        perPackageUnitAmountVal,
		PerUnitTotalAmount:          perUnitTotalAmountVal,
		Rate:                        rateVal,
		Units:                       unitsVal,
		VolumeRanges:                volumeRangesVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewAmountDetailsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AmountDetailsValue {
	object, diags := NewAmountDetailsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAmountDetailsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AmountDetailsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAmountDetailsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAmountDetailsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAmountDetailsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAmountDetailsValueMust(AmountDetailsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AmountDetailsType) ValueType(ctx context.Context) attr.Value {
	return AmountDetailsValue{}
}

var _ basetypes.ObjectValuable = AmountDetailsValue{}

type AmountDetailsValue struct {
	FixedFeeTotalAmount         basetypes.StringValue `tfsdk:"fixed_fee_total_amount"`
	FixedFeeUnitAmount          basetypes.StringValue `tfsdk:"fixed_fee_unit_amount"`
	FreeEvents                  basetypes.Int64Value  `tfsdk:"free_events"`
	FreeUnits                   basetypes.StringValue `tfsdk:"free_units"`
	GraduatedPercentageRanges   basetypes.ListValue   `tfsdk:"graduated_percentage_ranges"`
	GraduatedRanges             basetypes.ListValue   `tfsdk:"graduated_ranges"`
	MinMaxAdjustmentTotalAmount basetypes.StringValue `tfsdk:"min_max_adjustment_total_amount"`
	PaidEvents                  basetypes.Int64Value  `tfsdk:"paid_events"`
	PaidUnits                   basetypes.StringValue `tfsdk:"paid_units"`
	PerPackageSize              basetypes.Int64Value  `tfsdk:"per_package_size"`
	PerPackageUnitAmount        basetypes.StringValue `tfsdk:"per_package_unit_amount"`
	PerUnitTotalAmount          basetypes.StringValue `tfsdk:"per_unit_total_amount"`
	Rate                        basetypes.StringValue `tfsdk:"rate"`
	Units                       basetypes.StringValue `tfsdk:"units"`
	VolumeRanges                basetypes.ListValue   `tfsdk:"volume_ranges"`
	state                       attr.ValueState
}

func (v AmountDetailsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 15)

	var val tftypes.Value
	var err error

	attrTypes["fixed_fee_total_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fixed_fee_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["free_events"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["free_units"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["graduated_percentage_ranges"] = basetypes.ListType{
		ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["graduated_ranges"] = basetypes.ListType{
		ElemType: GraduatedRangesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["min_max_adjustment_total_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["paid_events"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["paid_units"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["per_package_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_package_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["per_unit_total_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["units"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_ranges"] = basetypes.ListType{
		ElemType: VolumeRangesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 15)

		val, err = v.FixedFeeTotalAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_fee_total_amount"] = val

		val, err = v.FixedFeeUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_fee_unit_amount"] = val

		val, err = v.FreeEvents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_events"] = val

		val, err = v.FreeUnits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units"] = val

		val, err = v.GraduatedPercentageRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["graduated_percentage_ranges"] = val

		val, err = v.GraduatedRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["graduated_ranges"] = val

		val, err = v.MinMaxAdjustmentTotalAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_max_adjustment_total_amount"] = val

		val, err = v.PaidEvents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["paid_events"] = val

		val, err = v.PaidUnits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["paid_units"] = val

		val, err = v.PerPackageSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_package_size"] = val

		val, err = v.PerPackageUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_package_unit_amount"] = val

		val, err = v.PerUnitTotalAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_total_amount"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		val, err = v.Units.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["units"] = val

		val, err = v.VolumeRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_ranges"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AmountDetailsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AmountDetailsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AmountDetailsValue) String() string {
	return "AmountDetailsValue"
}

func (v AmountDetailsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	graduatedPercentageRanges := types.ListValueMust(
		GraduatedPercentageRangesType{
			basetypes.ObjectType{
				AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.GraduatedPercentageRanges.Elements(),
	)

	if v.GraduatedPercentageRanges.IsNull() {
		graduatedPercentageRanges = types.ListNull(
			GraduatedPercentageRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.GraduatedPercentageRanges.IsUnknown() {
		graduatedPercentageRanges = types.ListUnknown(
			GraduatedPercentageRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	graduatedRanges := types.ListValueMust(
		GraduatedRangesType{
			basetypes.ObjectType{
				AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.GraduatedRanges.Elements(),
	)

	if v.GraduatedRanges.IsNull() {
		graduatedRanges = types.ListNull(
			GraduatedRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.GraduatedRanges.IsUnknown() {
		graduatedRanges = types.ListUnknown(
			GraduatedRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	volumeRanges := types.ListValueMust(
		VolumeRangesType{
			basetypes.ObjectType{
				AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.VolumeRanges.Elements(),
	)

	if v.VolumeRanges.IsNull() {
		volumeRanges = types.ListNull(
			VolumeRangesType{
				basetypes.ObjectType{
					AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VolumeRanges.IsUnknown() {
		volumeRanges = types.ListUnknown(
			VolumeRangesType{
				basetypes.ObjectType{
					AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"fixed_fee_total_amount": basetypes.StringType{},
		"fixed_fee_unit_amount":  basetypes.StringType{},
		"free_events":            basetypes.Int64Type{},
		"free_units":             basetypes.StringType{},
		"graduated_percentage_ranges": basetypes.ListType{
			ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
		},
		"graduated_ranges": basetypes.ListType{
			ElemType: GraduatedRangesValue{}.Type(ctx),
		},
		"min_max_adjustment_total_amount": basetypes.StringType{},
		"paid_events":                     basetypes.Int64Type{},
		"paid_units":                      basetypes.StringType{},
		"per_package_size":                basetypes.Int64Type{},
		"per_package_unit_amount":         basetypes.StringType{},
		"per_unit_total_amount":           basetypes.StringType{},
		"rate":                            basetypes.StringType{},
		"units":                           basetypes.StringType{},
		"volume_ranges": basetypes.ListType{
			ElemType: VolumeRangesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"fixed_fee_total_amount":          v.FixedFeeTotalAmount,
			"fixed_fee_unit_amount":           v.FixedFeeUnitAmount,
			"free_events":                     v.FreeEvents,
			"free_units":                      v.FreeUnits,
			"graduated_percentage_ranges":     graduatedPercentageRanges,
			"graduated_ranges":                graduatedRanges,
			"min_max_adjustment_total_amount": v.MinMaxAdjustmentTotalAmount,
			"paid_events":                     v.PaidEvents,
			"paid_units":                      v.PaidUnits,
			"per_package_size":                v.PerPackageSize,
			"per_package_unit_amount":         v.PerPackageUnitAmount,
			"per_unit_total_amount":           v.PerUnitTotalAmount,
			"rate":                            v.Rate,
			"units":                           v.Units,
			"volume_ranges":                   volumeRanges,
		})

	return objVal, diags
}

func (v AmountDetailsValue) Equal(o attr.Value) bool {
	other, ok := o.(AmountDetailsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FixedFeeTotalAmount.Equal(other.FixedFeeTotalAmount) {
		return false
	}

	if !v.FixedFeeUnitAmount.Equal(other.FixedFeeUnitAmount) {
		return false
	}

	if !v.FreeEvents.Equal(other.FreeEvents) {
		return false
	}

	if !v.FreeUnits.Equal(other.FreeUnits) {
		return false
	}

	if !v.GraduatedPercentageRanges.Equal(other.GraduatedPercentageRanges) {
		return false
	}

	if !v.GraduatedRanges.Equal(other.GraduatedRanges) {
		return false
	}

	if !v.MinMaxAdjustmentTotalAmount.Equal(other.MinMaxAdjustmentTotalAmount) {
		return false
	}

	if !v.PaidEvents.Equal(other.PaidEvents) {
		return false
	}

	if !v.PaidUnits.Equal(other.PaidUnits) {
		return false
	}

	if !v.PerPackageSize.Equal(other.PerPackageSize) {
		return false
	}

	if !v.PerPackageUnitAmount.Equal(other.PerPackageUnitAmount) {
		return false
	}

	if !v.PerUnitTotalAmount.Equal(other.PerUnitTotalAmount) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	if !v.Units.Equal(other.Units) {
		return false
	}

	if !v.VolumeRanges.Equal(other.VolumeRanges) {
		return false
	}

	return true
}

func (v AmountDetailsValue) Type(ctx context.Context) attr.Type {
	return AmountDetailsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AmountDetailsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"fixed_fee_total_amount": basetypes.StringType{},
		"fixed_fee_unit_amount":  basetypes.StringType{},
		"free_events":            basetypes.Int64Type{},
		"free_units":             basetypes.StringType{},
		"graduated_percentage_ranges": basetypes.ListType{
			ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
		},
		"graduated_ranges": basetypes.ListType{
			ElemType: GraduatedRangesValue{}.Type(ctx),
		},
		"min_max_adjustment_total_amount": basetypes.StringType{},
		"paid_events":                     basetypes.Int64Type{},
		"paid_units":                      basetypes.StringType{},
		"per_package_size":                basetypes.Int64Type{},
		"per_package_unit_amount":         basetypes.StringType{},
		"per_unit_total_amount":           basetypes.StringType{},
		"rate":                            basetypes.StringType{},
		"units":                           basetypes.StringType{},
		"volume_ranges": basetypes.ListType{
			ElemType: VolumeRangesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = GraduatedPercentageRangesType{}

type GraduatedPercentageRangesType struct {
	basetypes.ObjectType
}

func (t GraduatedPercentageRangesType) Equal(o attr.Type) bool {
	other, ok := o.(GraduatedPercentageRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GraduatedPercentageRangesType) String() string {
	return "GraduatedPercentageRangesType"
}

func (t GraduatedPercentageRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatUnitAmountAttribute, ok := attributes["flat_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_unit_amount is missing from object`)

		return nil, diags
	}

	flatUnitAmountVal, ok := flatUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_unit_amount expected to be basetypes.StringValue, was: %T`, flatUnitAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitTotalAmountAttribute, ok := attributes["per_unit_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_total_amount is missing from object`)

		return nil, diags
	}

	perUnitTotalAmountVal, ok := perUnitTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_total_amount expected to be basetypes.StringValue, was: %T`, perUnitTotalAmountAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	totalWithFlatAmountAttribute, ok := attributes["total_with_flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_with_flat_amount is missing from object`)

		return nil, diags
	}

	totalWithFlatAmountVal, ok := totalWithFlatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_with_flat_amount expected to be basetypes.StringValue, was: %T`, totalWithFlatAmountAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return nil, diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GraduatedPercentageRangesValue{
		FlatUnitAmount:      flatUnitAmountVal,
		FromValue:           fromValueVal,
		PerUnitTotalAmount:  perUnitTotalAmountVal,
		Rate:                rateVal,
		ToValue:             toValueVal,
		TotalWithFlatAmount: totalWithFlatAmountVal,
		Units:               unitsVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewGraduatedPercentageRangesValueNull() GraduatedPercentageRangesValue {
	return GraduatedPercentageRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewGraduatedPercentageRangesValueUnknown() GraduatedPercentageRangesValue {
	return GraduatedPercentageRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGraduatedPercentageRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GraduatedPercentageRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GraduatedPercentageRangesValue Attribute Value",
				"While creating a GraduatedPercentageRangesValue value, a missing attribute value was detected. "+
					"A GraduatedPercentageRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GraduatedPercentageRangesValue Attribute Type",
				"While creating a GraduatedPercentageRangesValue value, an invalid attribute value was detected. "+
					"A GraduatedPercentageRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GraduatedPercentageRangesValue Attribute Value",
				"While creating a GraduatedPercentageRangesValue value, an extra attribute value was detected. "+
					"A GraduatedPercentageRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GraduatedPercentageRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	flatUnitAmountAttribute, ok := attributes["flat_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_unit_amount is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	flatUnitAmountVal, ok := flatUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_unit_amount expected to be basetypes.StringValue, was: %T`, flatUnitAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitTotalAmountAttribute, ok := attributes["per_unit_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_total_amount is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	perUnitTotalAmountVal, ok := perUnitTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_total_amount expected to be basetypes.StringValue, was: %T`, perUnitTotalAmountAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	totalWithFlatAmountAttribute, ok := attributes["total_with_flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_with_flat_amount is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	totalWithFlatAmountVal, ok := totalWithFlatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_with_flat_amount expected to be basetypes.StringValue, was: %T`, totalWithFlatAmountAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	if diags.HasError() {
		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	return GraduatedPercentageRangesValue{
		FlatUnitAmount:      flatUnitAmountVal,
		FromValue:           fromValueVal,
		PerUnitTotalAmount:  perUnitTotalAmountVal,
		Rate:                rateVal,
		ToValue:             toValueVal,
		TotalWithFlatAmount: totalWithFlatAmountVal,
		Units:               unitsVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewGraduatedPercentageRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GraduatedPercentageRangesValue {
	object, diags := NewGraduatedPercentageRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGraduatedPercentageRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GraduatedPercentageRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGraduatedPercentageRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGraduatedPercentageRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGraduatedPercentageRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGraduatedPercentageRangesValueMust(GraduatedPercentageRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GraduatedPercentageRangesType) ValueType(ctx context.Context) attr.Value {
	return GraduatedPercentageRangesValue{}
}

var _ basetypes.ObjectValuable = GraduatedPercentageRangesValue{}

type GraduatedPercentageRangesValue struct {
	FlatUnitAmount      basetypes.StringValue `tfsdk:"flat_unit_amount"`
	FromValue           basetypes.Int64Value  `tfsdk:"from_value"`
	PerUnitTotalAmount  basetypes.StringValue `tfsdk:"per_unit_total_amount"`
	Rate                basetypes.StringValue `tfsdk:"rate"`
	ToValue             basetypes.Int64Value  `tfsdk:"to_value"`
	TotalWithFlatAmount basetypes.StringValue `tfsdk:"total_with_flat_amount"`
	Units               basetypes.StringValue `tfsdk:"units"`
	state               attr.ValueState
}

func (v GraduatedPercentageRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["flat_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_unit_total_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_with_flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["units"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.FlatUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_unit_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.PerUnitTotalAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_total_amount"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		val, err = v.TotalWithFlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_with_flat_amount"] = val

		val, err = v.Units.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["units"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GraduatedPercentageRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GraduatedPercentageRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GraduatedPercentageRangesValue) String() string {
	return "GraduatedPercentageRangesValue"
}

func (v GraduatedPercentageRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_unit_amount":       basetypes.StringType{},
		"from_value":             basetypes.Int64Type{},
		"per_unit_total_amount":  basetypes.StringType{},
		"rate":                   basetypes.StringType{},
		"to_value":               basetypes.Int64Type{},
		"total_with_flat_amount": basetypes.StringType{},
		"units":                  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_unit_amount":       v.FlatUnitAmount,
			"from_value":             v.FromValue,
			"per_unit_total_amount":  v.PerUnitTotalAmount,
			"rate":                   v.Rate,
			"to_value":               v.ToValue,
			"total_with_flat_amount": v.TotalWithFlatAmount,
			"units":                  v.Units,
		})

	return objVal, diags
}

func (v GraduatedPercentageRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(GraduatedPercentageRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatUnitAmount.Equal(other.FlatUnitAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.PerUnitTotalAmount.Equal(other.PerUnitTotalAmount) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	if !v.TotalWithFlatAmount.Equal(other.TotalWithFlatAmount) {
		return false
	}

	if !v.Units.Equal(other.Units) {
		return false
	}

	return true
}

func (v GraduatedPercentageRangesValue) Type(ctx context.Context) attr.Type {
	return GraduatedPercentageRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GraduatedPercentageRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_unit_amount":       basetypes.StringType{},
		"from_value":             basetypes.Int64Type{},
		"per_unit_total_amount":  basetypes.StringType{},
		"rate":                   basetypes.StringType{},
		"to_value":               basetypes.Int64Type{},
		"total_with_flat_amount": basetypes.StringType{},
		"units":                  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = GraduatedRangesType{}

type GraduatedRangesType struct {
	basetypes.ObjectType
}

func (t GraduatedRangesType) Equal(o attr.Type) bool {
	other, ok := o.(GraduatedRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GraduatedRangesType) String() string {
	return "GraduatedRangesType"
}

func (t GraduatedRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatUnitAmountAttribute, ok := attributes["flat_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_unit_amount is missing from object`)

		return nil, diags
	}

	flatUnitAmountVal, ok := flatUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_unit_amount expected to be basetypes.StringValue, was: %T`, flatUnitAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return nil, diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	perUnitTotalAmountAttribute, ok := attributes["per_unit_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_total_amount is missing from object`)

		return nil, diags
	}

	perUnitTotalAmountVal, ok := perUnitTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_total_amount expected to be basetypes.StringValue, was: %T`, perUnitTotalAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	totalWithFlatAmountAttribute, ok := attributes["total_with_flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_with_flat_amount is missing from object`)

		return nil, diags
	}

	totalWithFlatAmountVal, ok := totalWithFlatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_with_flat_amount expected to be basetypes.StringValue, was: %T`, totalWithFlatAmountAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return nil, diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GraduatedRangesValue{
		FlatUnitAmount:      flatUnitAmountVal,
		FromValue:           fromValueVal,
		PerUnitAmount:       perUnitAmountVal,
		PerUnitTotalAmount:  perUnitTotalAmountVal,
		ToValue:             toValueVal,
		TotalWithFlatAmount: totalWithFlatAmountVal,
		Units:               unitsVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewGraduatedRangesValueNull() GraduatedRangesValue {
	return GraduatedRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewGraduatedRangesValueUnknown() GraduatedRangesValue {
	return GraduatedRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGraduatedRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GraduatedRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GraduatedRangesValue Attribute Value",
				"While creating a GraduatedRangesValue value, a missing attribute value was detected. "+
					"A GraduatedRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GraduatedRangesValue Attribute Type",
				"While creating a GraduatedRangesValue value, an invalid attribute value was detected. "+
					"A GraduatedRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GraduatedRangesValue Attribute Value",
				"While creating a GraduatedRangesValue value, an extra attribute value was detected. "+
					"A GraduatedRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GraduatedRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGraduatedRangesValueUnknown(), diags
	}

	flatUnitAmountAttribute, ok := attributes["flat_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_unit_amount is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	flatUnitAmountVal, ok := flatUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_unit_amount expected to be basetypes.StringValue, was: %T`, flatUnitAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	perUnitTotalAmountAttribute, ok := attributes["per_unit_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_total_amount is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	perUnitTotalAmountVal, ok := perUnitTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_total_amount expected to be basetypes.StringValue, was: %T`, perUnitTotalAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	totalWithFlatAmountAttribute, ok := attributes["total_with_flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_with_flat_amount is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	totalWithFlatAmountVal, ok := totalWithFlatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_with_flat_amount expected to be basetypes.StringValue, was: %T`, totalWithFlatAmountAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	if diags.HasError() {
		return NewGraduatedRangesValueUnknown(), diags
	}

	return GraduatedRangesValue{
		FlatUnitAmount:      flatUnitAmountVal,
		FromValue:           fromValueVal,
		PerUnitAmount:       perUnitAmountVal,
		PerUnitTotalAmount:  perUnitTotalAmountVal,
		ToValue:             toValueVal,
		TotalWithFlatAmount: totalWithFlatAmountVal,
		Units:               unitsVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewGraduatedRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GraduatedRangesValue {
	object, diags := NewGraduatedRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGraduatedRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GraduatedRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGraduatedRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGraduatedRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGraduatedRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGraduatedRangesValueMust(GraduatedRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GraduatedRangesType) ValueType(ctx context.Context) attr.Value {
	return GraduatedRangesValue{}
}

var _ basetypes.ObjectValuable = GraduatedRangesValue{}

type GraduatedRangesValue struct {
	FlatUnitAmount      basetypes.StringValue `tfsdk:"flat_unit_amount"`
	FromValue           basetypes.Int64Value  `tfsdk:"from_value"`
	PerUnitAmount       basetypes.StringValue `tfsdk:"per_unit_amount"`
	PerUnitTotalAmount  basetypes.StringValue `tfsdk:"per_unit_total_amount"`
	ToValue             basetypes.Int64Value  `tfsdk:"to_value"`
	TotalWithFlatAmount basetypes.StringValue `tfsdk:"total_with_flat_amount"`
	Units               basetypes.StringValue `tfsdk:"units"`
	state               attr.ValueState
}

func (v GraduatedRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["flat_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["per_unit_total_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_with_flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["units"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.FlatUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_unit_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.PerUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_amount"] = val

		val, err = v.PerUnitTotalAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_total_amount"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		val, err = v.TotalWithFlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_with_flat_amount"] = val

		val, err = v.Units.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["units"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GraduatedRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GraduatedRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GraduatedRangesValue) String() string {
	return "GraduatedRangesValue"
}

func (v GraduatedRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_unit_amount":       basetypes.StringType{},
		"from_value":             basetypes.Int64Type{},
		"per_unit_amount":        basetypes.StringType{},
		"per_unit_total_amount":  basetypes.StringType{},
		"to_value":               basetypes.Int64Type{},
		"total_with_flat_amount": basetypes.StringType{},
		"units":                  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_unit_amount":       v.FlatUnitAmount,
			"from_value":             v.FromValue,
			"per_unit_amount":        v.PerUnitAmount,
			"per_unit_total_amount":  v.PerUnitTotalAmount,
			"to_value":               v.ToValue,
			"total_with_flat_amount": v.TotalWithFlatAmount,
			"units":                  v.Units,
		})

	return objVal, diags
}

func (v GraduatedRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(GraduatedRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatUnitAmount.Equal(other.FlatUnitAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.PerUnitAmount.Equal(other.PerUnitAmount) {
		return false
	}

	if !v.PerUnitTotalAmount.Equal(other.PerUnitTotalAmount) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	if !v.TotalWithFlatAmount.Equal(other.TotalWithFlatAmount) {
		return false
	}

	if !v.Units.Equal(other.Units) {
		return false
	}

	return true
}

func (v GraduatedRangesValue) Type(ctx context.Context) attr.Type {
	return GraduatedRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GraduatedRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_unit_amount":       basetypes.StringType{},
		"from_value":             basetypes.Int64Type{},
		"per_unit_amount":        basetypes.StringType{},
		"per_unit_total_amount":  basetypes.StringType{},
		"to_value":               basetypes.Int64Type{},
		"total_with_flat_amount": basetypes.StringType{},
		"units":                  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VolumeRangesType{}

type VolumeRangesType struct {
	basetypes.ObjectType
}

func (t VolumeRangesType) Equal(o attr.Type) bool {
	other, ok := o.(VolumeRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumeRangesType) String() string {
	return "VolumeRangesType"
}

func (t VolumeRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatUnitAmountAttribute, ok := attributes["flat_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_unit_amount is missing from object`)

		return nil, diags
	}

	flatUnitAmountVal, ok := flatUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_unit_amount expected to be basetypes.StringValue, was: %T`, flatUnitAmountAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return nil, diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	perUnitTotalAmountAttribute, ok := attributes["per_unit_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_total_amount is missing from object`)

		return nil, diags
	}

	perUnitTotalAmountVal, ok := perUnitTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_total_amount expected to be basetypes.StringValue, was: %T`, perUnitTotalAmountAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumeRangesValue{
		FlatUnitAmount:     flatUnitAmountVal,
		PerUnitAmount:      perUnitAmountVal,
		PerUnitTotalAmount: perUnitTotalAmountVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewVolumeRangesValueNull() VolumeRangesValue {
	return VolumeRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumeRangesValueUnknown() VolumeRangesValue {
	return VolumeRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumeRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumeRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumeRangesValue Attribute Value",
				"While creating a VolumeRangesValue value, a missing attribute value was detected. "+
					"A VolumeRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumeRangesValue Attribute Type",
				"While creating a VolumeRangesValue value, an invalid attribute value was detected. "+
					"A VolumeRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumeRangesValue Attribute Value",
				"While creating a VolumeRangesValue value, an extra attribute value was detected. "+
					"A VolumeRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumeRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumeRangesValueUnknown(), diags
	}

	flatUnitAmountAttribute, ok := attributes["flat_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_unit_amount is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	flatUnitAmountVal, ok := flatUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_unit_amount expected to be basetypes.StringValue, was: %T`, flatUnitAmountAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	perUnitTotalAmountAttribute, ok := attributes["per_unit_total_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_total_amount is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	perUnitTotalAmountVal, ok := perUnitTotalAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_total_amount expected to be basetypes.StringValue, was: %T`, perUnitTotalAmountAttribute))
	}

	if diags.HasError() {
		return NewVolumeRangesValueUnknown(), diags
	}

	return VolumeRangesValue{
		FlatUnitAmount:     flatUnitAmountVal,
		PerUnitAmount:      perUnitAmountVal,
		PerUnitTotalAmount: perUnitTotalAmountVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewVolumeRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumeRangesValue {
	object, diags := NewVolumeRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumeRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumeRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumeRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumeRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumeRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumeRangesValueMust(VolumeRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumeRangesType) ValueType(ctx context.Context) attr.Value {
	return VolumeRangesValue{}
}

var _ basetypes.ObjectValuable = VolumeRangesValue{}

type VolumeRangesValue struct {
	FlatUnitAmount     basetypes.StringValue `tfsdk:"flat_unit_amount"`
	PerUnitAmount      basetypes.StringValue `tfsdk:"per_unit_amount"`
	PerUnitTotalAmount basetypes.StringValue `tfsdk:"per_unit_total_amount"`
	state              attr.ValueState
}

func (v VolumeRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["flat_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["per_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["per_unit_total_amount"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.FlatUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_unit_amount"] = val

		val, err = v.PerUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_amount"] = val

		val, err = v.PerUnitTotalAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_total_amount"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumeRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumeRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumeRangesValue) String() string {
	return "VolumeRangesValue"
}

func (v VolumeRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_unit_amount":      basetypes.StringType{},
		"per_unit_amount":       basetypes.StringType{},
		"per_unit_total_amount": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_unit_amount":      v.FlatUnitAmount,
			"per_unit_amount":       v.PerUnitAmount,
			"per_unit_total_amount": v.PerUnitTotalAmount,
		})

	return objVal, diags
}

func (v VolumeRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumeRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatUnitAmount.Equal(other.FlatUnitAmount) {
		return false
	}

	if !v.PerUnitAmount.Equal(other.PerUnitAmount) {
		return false
	}

	if !v.PerUnitTotalAmount.Equal(other.PerUnitTotalAmount) {
		return false
	}

	return true
}

func (v VolumeRangesValue) Type(ctx context.Context) attr.Type {
	return VolumeRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumeRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_unit_amount":      basetypes.StringType{},
		"per_unit_amount":       basetypes.StringType{},
		"per_unit_total_amount": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AppliedTaxesType{}

type AppliedTaxesType struct {
	basetypes.ObjectType
}

func (t AppliedTaxesType) Equal(o attr.Type) bool {
	other, ok := o.(AppliedTaxesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AppliedTaxesType) String() string {
	return "AppliedTaxesType"
}

func (t AppliedTaxesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return nil, diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lagoTaxIdAttribute, ok := attributes["lago_tax_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_tax_id is missing from object`)

		return nil, diags
	}

	lagoTaxIdVal, ok := lagoTaxIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_tax_id expected to be basetypes.StringValue, was: %T`, lagoTaxIdAttribute))
	}

	taxCodeAttribute, ok := attributes["tax_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_code is missing from object`)

		return nil, diags
	}

	taxCodeVal, ok := taxCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_code expected to be basetypes.StringValue, was: %T`, taxCodeAttribute))
	}

	taxDescriptionAttribute, ok := attributes["tax_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_description is missing from object`)

		return nil, diags
	}

	taxDescriptionVal, ok := taxDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_description expected to be basetypes.StringValue, was: %T`, taxDescriptionAttribute))
	}

	taxNameAttribute, ok := attributes["tax_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_name is missing from object`)

		return nil, diags
	}

	taxNameVal, ok := taxNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_name expected to be basetypes.StringValue, was: %T`, taxNameAttribute))
	}

	taxRateAttribute, ok := attributes["tax_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_rate is missing from object`)

		return nil, diags
	}

	taxRateVal, ok := taxRateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_rate expected to be basetypes.NumberValue, was: %T`, taxRateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AppliedTaxesValue{
		AmountCents:    amountCentsVal,
		AmountCurrency: amountCurrencyVal,
		CreatedAt:      createdAtVal,
		LagoId:         lagoIdVal,
		LagoTaxId:      lagoTaxIdVal,
		TaxCode:        taxCodeVal,
		TaxDescription: taxDescriptionVal,
		TaxName:        taxNameVal,
		TaxRate:        taxRateVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAppliedTaxesValueNull() AppliedTaxesValue {
	return AppliedTaxesValue{
		state: attr.ValueStateNull,
	}
}

func NewAppliedTaxesValueUnknown() AppliedTaxesValue {
	return AppliedTaxesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAppliedTaxesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AppliedTaxesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AppliedTaxesValue Attribute Value",
				"While creating a AppliedTaxesValue value, a missing attribute value was detected. "+
					"A AppliedTaxesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppliedTaxesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AppliedTaxesValue Attribute Type",
				"While creating a AppliedTaxesValue value, an invalid attribute value was detected. "+
					"A AppliedTaxesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppliedTaxesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AppliedTaxesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AppliedTaxesValue Attribute Value",
				"While creating a AppliedTaxesValue value, an extra attribute value was detected. "+
					"A AppliedTaxesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AppliedTaxesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAppliedTaxesValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewAppliedTaxesValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return NewAppliedTaxesValueUnknown(), diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewAppliedTaxesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewAppliedTaxesValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lagoTaxIdAttribute, ok := attributes["lago_tax_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_tax_id is missing from object`)

		return NewAppliedTaxesValueUnknown(), diags
	}

	lagoTaxIdVal, ok := lagoTaxIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_tax_id expected to be basetypes.StringValue, was: %T`, lagoTaxIdAttribute))
	}

	taxCodeAttribute, ok := attributes["tax_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_code is missing from object`)

		return NewAppliedTaxesValueUnknown(), diags
	}

	taxCodeVal, ok := taxCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_code expected to be basetypes.StringValue, was: %T`, taxCodeAttribute))
	}

	taxDescriptionAttribute, ok := attributes["tax_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_description is missing from object`)

		return NewAppliedTaxesValueUnknown(), diags
	}

	taxDescriptionVal, ok := taxDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_description expected to be basetypes.StringValue, was: %T`, taxDescriptionAttribute))
	}

	taxNameAttribute, ok := attributes["tax_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_name is missing from object`)

		return NewAppliedTaxesValueUnknown(), diags
	}

	taxNameVal, ok := taxNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_name expected to be basetypes.StringValue, was: %T`, taxNameAttribute))
	}

	taxRateAttribute, ok := attributes["tax_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_rate is missing from object`)

		return NewAppliedTaxesValueUnknown(), diags
	}

	taxRateVal, ok := taxRateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_rate expected to be basetypes.NumberValue, was: %T`, taxRateAttribute))
	}

	if diags.HasError() {
		return NewAppliedTaxesValueUnknown(), diags
	}

	return AppliedTaxesValue{
		AmountCents:    amountCentsVal,
		AmountCurrency: amountCurrencyVal,
		CreatedAt:      createdAtVal,
		LagoId:         lagoIdVal,
		LagoTaxId:      lagoTaxIdVal,
		TaxCode:        taxCodeVal,
		TaxDescription: taxDescriptionVal,
		TaxName:        taxNameVal,
		TaxRate:        taxRateVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAppliedTaxesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AppliedTaxesValue {
	object, diags := NewAppliedTaxesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAppliedTaxesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AppliedTaxesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAppliedTaxesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAppliedTaxesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAppliedTaxesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAppliedTaxesValueMust(AppliedTaxesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AppliedTaxesType) ValueType(ctx context.Context) attr.Value {
	return AppliedTaxesValue{}
}

var _ basetypes.ObjectValuable = AppliedTaxesValue{}

type AppliedTaxesValue struct {
	AmountCents    basetypes.Int64Value  `tfsdk:"amount_cents"`
	AmountCurrency basetypes.StringValue `tfsdk:"amount_currency"`
	CreatedAt      basetypes.StringValue `tfsdk:"created_at"`
	LagoId         basetypes.StringValue `tfsdk:"lago_id"`
	LagoTaxId      basetypes.StringValue `tfsdk:"lago_tax_id"`
	TaxCode        basetypes.StringValue `tfsdk:"tax_code"`
	TaxDescription basetypes.StringValue `tfsdk:"tax_description"`
	TaxName        basetypes.StringValue `tfsdk:"tax_name"`
	TaxRate        basetypes.NumberValue `tfsdk:"tax_rate"`
	state          attr.ValueState
}

func (v AppliedTaxesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["amount_currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_tax_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tax_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tax_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tax_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tax_rate"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.AmountCurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_currency"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.LagoTaxId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_tax_id"] = val

		val, err = v.TaxCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_code"] = val

		val, err = v.TaxDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_description"] = val

		val, err = v.TaxName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_name"] = val

		val, err = v.TaxRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_rate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AppliedTaxesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AppliedTaxesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AppliedTaxesValue) String() string {
	return "AppliedTaxesValue"
}

func (v AppliedTaxesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"created_at":      basetypes.StringType{},
		"lago_id":         basetypes.StringType{},
		"lago_tax_id":     basetypes.StringType{},
		"tax_code":        basetypes.StringType{},
		"tax_description": basetypes.StringType{},
		"tax_name":        basetypes.StringType{},
		"tax_rate":        basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":    v.AmountCents,
			"amount_currency": v.AmountCurrency,
			"created_at":      v.CreatedAt,
			"lago_id":         v.LagoId,
			"lago_tax_id":     v.LagoTaxId,
			"tax_code":        v.TaxCode,
			"tax_description": v.TaxDescription,
			"tax_name":        v.TaxName,
			"tax_rate":        v.TaxRate,
		})

	return objVal, diags
}

func (v AppliedTaxesValue) Equal(o attr.Value) bool {
	other, ok := o.(AppliedTaxesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.AmountCurrency.Equal(other.AmountCurrency) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.LagoTaxId.Equal(other.LagoTaxId) {
		return false
	}

	if !v.TaxCode.Equal(other.TaxCode) {
		return false
	}

	if !v.TaxDescription.Equal(other.TaxDescription) {
		return false
	}

	if !v.TaxName.Equal(other.TaxName) {
		return false
	}

	if !v.TaxRate.Equal(other.TaxRate) {
		return false
	}

	return true
}

func (v AppliedTaxesValue) Type(ctx context.Context) attr.Type {
	return AppliedTaxesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AppliedTaxesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"created_at":      basetypes.StringType{},
		"lago_id":         basetypes.StringType{},
		"lago_tax_id":     basetypes.StringType{},
		"tax_code":        basetypes.StringType{},
		"tax_description": basetypes.StringType{},
		"tax_name":        basetypes.StringType{},
		"tax_rate":        basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = ItemType{}

type ItemType struct {
	basetypes.ObjectType
}

func (t ItemType) Equal(o attr.Type) bool {
	other, ok := o.(ItemType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ItemType) String() string {
	return "ItemType"
}

func (t ItemType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	filterInvoiceDisplayNameAttribute, ok := attributes["filter_invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filter_invoice_display_name is missing from object`)

		return nil, diags
	}

	filterInvoiceDisplayNameVal, ok := filterInvoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filter_invoice_display_name expected to be basetypes.StringValue, was: %T`, filterInvoiceDisplayNameAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.MapValue, was: %T`, filtersAttribute))
	}

	groupedByAttribute, ok := attributes["grouped_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_by is missing from object`)

		return nil, diags
	}

	groupedByVal, ok := groupedByAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_by expected to be basetypes.MapValue, was: %T`, groupedByAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	itemTypeAttribute, ok := attributes["item_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`item_type is missing from object`)

		return nil, diags
	}

	itemTypeVal, ok := itemTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`item_type expected to be basetypes.StringValue, was: %T`, itemTypeAttribute))
	}

	lagoItemIdAttribute, ok := attributes["lago_item_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_item_id is missing from object`)

		return nil, diags
	}

	lagoItemIdVal, ok := lagoItemIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_item_id expected to be basetypes.StringValue, was: %T`, lagoItemIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ItemValue{
		Code:                     codeVal,
		FilterInvoiceDisplayName: filterInvoiceDisplayNameVal,
		Filters:                  filtersVal,
		GroupedBy:                groupedByVal,
		InvoiceDisplayName:       invoiceDisplayNameVal,
		ItemType:                 itemTypeVal,
		LagoItemId:               lagoItemIdVal,
		Name:                     nameVal,
		ItemType:                 typeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewItemValueNull() ItemValue {
	return ItemValue{
		state: attr.ValueStateNull,
	}
}

func NewItemValueUnknown() ItemValue {
	return ItemValue{
		state: attr.ValueStateUnknown,
	}
}

func NewItemValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ItemValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ItemValue Attribute Value",
				"While creating a ItemValue value, a missing attribute value was detected. "+
					"A ItemValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ItemValue Attribute Type",
				"While creating a ItemValue value, an invalid attribute value was detected. "+
					"A ItemValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ItemValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ItemValue Attribute Value",
				"While creating a ItemValue value, an extra attribute value was detected. "+
					"A ItemValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ItemValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewItemValueUnknown(), diags
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewItemValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	filterInvoiceDisplayNameAttribute, ok := attributes["filter_invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filter_invoice_display_name is missing from object`)

		return NewItemValueUnknown(), diags
	}

	filterInvoiceDisplayNameVal, ok := filterInvoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filter_invoice_display_name expected to be basetypes.StringValue, was: %T`, filterInvoiceDisplayNameAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewItemValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.MapValue, was: %T`, filtersAttribute))
	}

	groupedByAttribute, ok := attributes["grouped_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_by is missing from object`)

		return NewItemValueUnknown(), diags
	}

	groupedByVal, ok := groupedByAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_by expected to be basetypes.MapValue, was: %T`, groupedByAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewItemValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	itemTypeAttribute, ok := attributes["item_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`item_type is missing from object`)

		return NewItemValueUnknown(), diags
	}

	itemTypeVal, ok := itemTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`item_type expected to be basetypes.StringValue, was: %T`, itemTypeAttribute))
	}

	lagoItemIdAttribute, ok := attributes["lago_item_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_item_id is missing from object`)

		return NewItemValueUnknown(), diags
	}

	lagoItemIdVal, ok := lagoItemIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_item_id expected to be basetypes.StringValue, was: %T`, lagoItemIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewItemValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewItemValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewItemValueUnknown(), diags
	}

	return ItemValue{
		Code:                     codeVal,
		FilterInvoiceDisplayName: filterInvoiceDisplayNameVal,
		Filters:                  filtersVal,
		GroupedBy:                groupedByVal,
		InvoiceDisplayName:       invoiceDisplayNameVal,
		ItemType:                 itemTypeVal,
		LagoItemId:               lagoItemIdVal,
		Name:                     nameVal,
		ItemType:                 typeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewItemValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ItemValue {
	object, diags := NewItemValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewItemValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ItemType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewItemValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewItemValueUnknown(), nil
	}

	if in.IsNull() {
		return NewItemValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewItemValueMust(ItemValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ItemType) ValueType(ctx context.Context) attr.Value {
	return ItemValue{}
}

var _ basetypes.ObjectValuable = ItemValue{}

type ItemValue struct {
	Code                     basetypes.StringValue `tfsdk:"code"`
	FilterInvoiceDisplayName basetypes.StringValue `tfsdk:"filter_invoice_display_name"`
	Filters                  basetypes.MapValue    `tfsdk:"filters"`
	GroupedBy                basetypes.MapValue    `tfsdk:"grouped_by"`
	InvoiceDisplayName       basetypes.StringValue `tfsdk:"invoice_display_name"`
	ItemType                 basetypes.StringValue `tfsdk:"item_type"`
	LagoItemId               basetypes.StringValue `tfsdk:"lago_item_id"`
	Name                     basetypes.StringValue `tfsdk:"name"`
	ItemType                 basetypes.StringValue `tfsdk:"type"`
	state                    attr.ValueState
}

func (v ItemValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["filter_invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["filters"] = basetypes.MapType{
		ElemType: types.ListType{
			ElemType: types.StringType,
		},
	}.TerraformType(ctx)
	attrTypes["grouped_by"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["item_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_item_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.FilterInvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filter_invoice_display_name"] = val

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.GroupedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["grouped_by"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.ItemType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["item_type"] = val

		val, err = v.LagoItemId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_item_id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ItemType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ItemValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ItemValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ItemValue) String() string {
	return "ItemValue"
}

func (v ItemValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.MapValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.MapUnknown(types.ListType{
			ElemType: types.StringType,
		})
	case v.Filters.IsNull():
		filtersVal = types.MapNull(types.ListType{
			ElemType: types.StringType,
		})
	default:
		var d diag.Diagnostics
		filtersVal, d = types.MapValue(types.ListType{
			ElemType: types.StringType,
		}, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"code":                        basetypes.StringType{},
			"filter_invoice_display_name": basetypes.StringType{},
			"filters": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"grouped_by": basetypes.MapType{
				ElemType: types.StringType,
			},
			"invoice_display_name": basetypes.StringType{},
			"item_type":            basetypes.StringType{},
			"lago_item_id":         basetypes.StringType{},
			"name":                 basetypes.StringType{},
			"type":                 basetypes.StringType{},
		}), diags
	}

	var groupedByVal basetypes.MapValue
	switch {
	case v.GroupedBy.IsUnknown():
		groupedByVal = types.MapUnknown(types.StringType)
	case v.GroupedBy.IsNull():
		groupedByVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		groupedByVal, d = types.MapValue(types.StringType, v.GroupedBy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"code":                        basetypes.StringType{},
			"filter_invoice_display_name": basetypes.StringType{},
			"filters": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
			"grouped_by": basetypes.MapType{
				ElemType: types.StringType,
			},
			"invoice_display_name": basetypes.StringType{},
			"item_type":            basetypes.StringType{},
			"lago_item_id":         basetypes.StringType{},
			"name":                 basetypes.StringType{},
			"type":                 basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"code":                        basetypes.StringType{},
		"filter_invoice_display_name": basetypes.StringType{},
		"filters": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
		"grouped_by": basetypes.MapType{
			ElemType: types.StringType,
		},
		"invoice_display_name": basetypes.StringType{},
		"item_type":            basetypes.StringType{},
		"lago_item_id":         basetypes.StringType{},
		"name":                 basetypes.StringType{},
		"type":                 basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"code":                        v.Code,
			"filter_invoice_display_name": v.FilterInvoiceDisplayName,
			"filters":                     filtersVal,
			"grouped_by":                  groupedByVal,
			"invoice_display_name":        v.InvoiceDisplayName,
			"item_type":                   v.ItemType,
			"lago_item_id":                v.LagoItemId,
			"name":                        v.Name,
			"type":                        v.ItemType,
		})

	return objVal, diags
}

func (v ItemValue) Equal(o attr.Value) bool {
	other, ok := o.(ItemValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.FilterInvoiceDisplayName.Equal(other.FilterInvoiceDisplayName) {
		return false
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.GroupedBy.Equal(other.GroupedBy) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.ItemType.Equal(other.ItemType) {
		return false
	}

	if !v.LagoItemId.Equal(other.LagoItemId) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ItemType.Equal(other.ItemType) {
		return false
	}

	return true
}

func (v ItemValue) Type(ctx context.Context) attr.Type {
	return ItemType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ItemValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"code":                        basetypes.StringType{},
		"filter_invoice_display_name": basetypes.StringType{},
		"filters": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
		"grouped_by": basetypes.MapType{
			ElemType: types.StringType,
		},
		"invoice_display_name": basetypes.StringType{},
		"item_type":            basetypes.StringType{},
		"lago_item_id":         basetypes.StringType{},
		"name":                 basetypes.StringType{},
		"type":                 basetypes.StringType{},
	}
}
