// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_coupons

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func CouponsResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"code": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Unique code used to identify the coupon.",
				MarkdownDescription: "Unique code used to identify the coupon.",
			},
			"coupon": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"amount_cents": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "The amount of the coupon in cents. This field is required only for coupon with `fixed_amount` type.",
						MarkdownDescription: "The amount of the coupon in cents. This field is required only for coupon with `fixed_amount` type.",
					},
					"amount_currency": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AED",
								"AFN",
								"ALL",
								"AMD",
								"ANG",
								"AOA",
								"ARS",
								"AUD",
								"AWG",
								"AZN",
								"BAM",
								"BBD",
								"BDT",
								"BGN",
								"BIF",
								"BMD",
								"BND",
								"BOB",
								"BRL",
								"BSD",
								"BWP",
								"BYN",
								"BZD",
								"CAD",
								"CDF",
								"CHF",
								"CLF",
								"CLP",
								"CNY",
								"COP",
								"CRC",
								"CVE",
								"CZK",
								"DJF",
								"DKK",
								"DOP",
								"DZD",
								"EGP",
								"ETB",
								"EUR",
								"FJD",
								"FKP",
								"GBP",
								"GEL",
								"GIP",
								"GMD",
								"GNF",
								"GTQ",
								"GYD",
								"HKD",
								"HNL",
								"HRK",
								"HTG",
								"HUF",
								"IDR",
								"ILS",
								"INR",
								"ISK",
								"JMD",
								"JPY",
								"KES",
								"KGS",
								"KHR",
								"KMF",
								"KRW",
								"KYD",
								"KZT",
								"LAK",
								"LBP",
								"LKR",
								"LRD",
								"LSL",
								"MAD",
								"MDL",
								"MGA",
								"MKD",
								"MMK",
								"MNT",
								"MOP",
								"MRO",
								"MUR",
								"MVR",
								"MWK",
								"MXN",
								"MYR",
								"MZN",
								"NAD",
								"NGN",
								"NIO",
								"NOK",
								"NPR",
								"NZD",
								"PAB",
								"PEN",
								"PGK",
								"PHP",
								"PKR",
								"PLN",
								"PYG",
								"QAR",
								"RON",
								"RSD",
								"RUB",
								"RWF",
								"SAR",
								"SBD",
								"SCR",
								"SEK",
								"SGD",
								"SHP",
								"SLL",
								"SOS",
								"SRD",
								"STD",
								"SZL",
								"THB",
								"TJS",
								"TOP",
								"TRY",
								"TTD",
								"TWD",
								"TZS",
								"UAH",
								"UGX",
								"USD",
								"UYU",
								"UZS",
								"VND",
								"VUV",
								"WST",
								"XAF",
								"XCD",
								"XOF",
								"XPF",
								"YER",
								"ZAR",
								"ZMW",
							),
						},
					},
					"applies_to": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"billable_metric_codes": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "An array of billable metric codes to which the coupon is applicable. By specifying the billable metric codes in this field, you can restrict the coupon's usage to specific metrics only.",
								MarkdownDescription: "An array of billable metric codes to which the coupon is applicable. By specifying the billable metric codes in this field, you can restrict the coupon's usage to specific metrics only.",
							},
							"plan_codes": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "An array of plan codes to which the coupon is applicable. By specifying the plan codes in this field, you can restrict the coupon's usage to specific plans only.",
								MarkdownDescription: "An array of plan codes to which the coupon is applicable. By specifying the plan codes in this field, you can restrict the coupon's usage to specific plans only.",
							},
						},
						CustomType: AppliesToType{
							ObjectType: types.ObjectType{
								AttrTypes: AppliesToValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Set coupon limitations to plans or specific metrics.",
						MarkdownDescription: "Set coupon limitations to plans or specific metrics.",
					},
					"billable_metric_codes": schema.ListAttribute{
						ElementType:         types.StringType,
						Computed:            true,
						Description:         "An array of billable metric codes to which the coupon is applicable. By specifying the billable metric codes in this field, you can restrict the coupon's usage to specific metrics only.",
						MarkdownDescription: "An array of billable metric codes to which the coupon is applicable. By specifying the billable metric codes in this field, you can restrict the coupon's usage to specific metrics only.",
					},
					"code": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Unique code used to identify the coupon.",
						MarkdownDescription: "Unique code used to identify the coupon.",
					},
					"coupon_type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The type of the coupon. It can have two possible values: `fixed_amount` or `percentage`.\n\n- If set to `fixed_amount`, the coupon represents a fixed amount discount.\n- If set to `percentage`, the coupon represents a percentage-based discount.",
						MarkdownDescription: "The type of the coupon. It can have two possible values: `fixed_amount` or `percentage`.\n\n- If set to `fixed_amount`, the coupon represents a fixed amount discount.\n- If set to `percentage`, the coupon represents a percentage-based discount.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"fixed_amount",
								"percentage",
							),
						},
					},
					"created_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date and time when the coupon was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the coupon was initially created.",
						MarkdownDescription: "The date and time when the coupon was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the coupon was initially created.",
					},
					"description": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Description of the coupon.",
						MarkdownDescription: "Description of the coupon.",
					},
					"expiration": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Specifies the type of expiration for the coupon. It can have two possible values: `time_limit` or `no_expiration`.\n\n- If set to `time_limit`, the coupon has an expiration based on a specified time limit.\n- If set to `no_expiration`, the coupon does not have an expiration date and remains valid indefinitely.",
						MarkdownDescription: "Specifies the type of expiration for the coupon. It can have two possible values: `time_limit` or `no_expiration`.\n\n- If set to `time_limit`, the coupon has an expiration based on a specified time limit.\n- If set to `no_expiration`, the coupon does not have an expiration date and remains valid indefinitely.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"no_expiration",
								"time_limit",
							),
						},
					},
					"expiration_at": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The expiration date and time of the coupon. This field is required only for coupons with `expiration` set to `time_limit`. The expiration date and time should be specified in UTC format according to the ISO 8601 datetime standard. It indicates the exact moment when the coupon will expire and is no longer valid.",
						MarkdownDescription: "The expiration date and time of the coupon. This field is required only for coupons with `expiration` set to `time_limit`. The expiration date and time should be specified in UTC format according to the ISO 8601 datetime standard. It indicates the exact moment when the coupon will expire and is no longer valid.",
					},
					"frequency": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The type of frequency for the coupon. It can have three possible values: `once`, `recurring` or `forever`.\n\n- If set to `once`, the coupon is applicable only for a single use.\n- If set to `recurring`, the coupon can be used multiple times for recurring billing periods.\n- If set to `forever`, the coupon has unlimited usage and can be applied indefinitely.",
						MarkdownDescription: "The type of frequency for the coupon. It can have three possible values: `once`, `recurring` or `forever`.\n\n- If set to `once`, the coupon is applicable only for a single use.\n- If set to `recurring`, the coupon can be used multiple times for recurring billing periods.\n- If set to `forever`, the coupon has unlimited usage and can be applied indefinitely.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"once",
								"recurring",
								"forever",
							),
						},
					},
					"frequency_duration": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Specifies the number of billing periods to which the coupon applies. This field is required only for coupons with a `recurring` frequency type",
						MarkdownDescription: "Specifies the number of billing periods to which the coupon applies. This field is required only for coupons with a `recurring` frequency type",
					},
					"lago_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier of the coupon, created by Lago.",
						MarkdownDescription: "Unique identifier of the coupon, created by Lago.",
					},
					"limited_billable_metrics": schema.BoolAttribute{
						Computed:            true,
						Description:         "The coupon is limited to specific billable metrics. The possible values can be `true` or `false`.",
						MarkdownDescription: "The coupon is limited to specific billable metrics. The possible values can be `true` or `false`.",
					},
					"limited_plans": schema.BoolAttribute{
						Computed:            true,
						Description:         "The coupon is limited to specific plans. The possible values can be `true` or `false`.",
						MarkdownDescription: "The coupon is limited to specific plans. The possible values can be `true` or `false`.",
					},
					"name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The name of the coupon.",
						MarkdownDescription: "The name of the coupon.",
					},
					"percentage_rate": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The percentage rate of the coupon. This field is required only for coupons with a `percentage` coupon type.",
						MarkdownDescription: "The percentage rate of the coupon. This field is required only for coupons with a `percentage` coupon type.",
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
						},
					},
					"plan_codes": schema.ListAttribute{
						ElementType:         types.StringType,
						Computed:            true,
						Description:         "An array of plan codes to which the coupon is applicable. By specifying the plan codes in this field, you can restrict the coupon's usage to specific plans only.",
						MarkdownDescription: "An array of plan codes to which the coupon is applicable. By specifying the plan codes in this field, you can restrict the coupon's usage to specific plans only.",
					},
					"reusable": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Indicates whether the coupon can be reused or not. If set to `true`, the coupon is reusable, meaning it can be applied multiple times to the same customer. If set to `false`, the coupon can only be used once and is not reusable. If not specified, this field is set to `true` by default.",
						MarkdownDescription: "Indicates whether the coupon can be reused or not. If set to `true`, the coupon is reusable, meaning it can be applied multiple times to the same customer. If set to `false`, the coupon can only be used once and is not reusable. If not specified, this field is set to `true` by default.",
					},
					"terminated_at": schema.StringAttribute{
						Computed:            true,
						Description:         "This field indicates if the coupon has been terminated and is no longer usable. If it's not null, it won't be removed for existing customers using it, but it prevents the coupon from being applied in the future.",
						MarkdownDescription: "This field indicates if the coupon has been terminated and is no longer usable. If it's not null, it won't be removed for existing customers using it, but it prevents the coupon from being applied in the future.",
					},
				},
				CustomType: CouponType{
					ObjectType: types.ObjectType{
						AttrTypes: CouponValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
		},
	}
}

type CouponsModel struct {
	Code   types.String `tfsdk:"code"`
	Coupon CouponValue  `tfsdk:"coupon"`
}

var _ basetypes.ObjectTypable = CouponType{}

type CouponType struct {
	basetypes.ObjectType
}

func (t CouponType) Equal(o attr.Type) bool {
	other, ok := o.(CouponType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CouponType) String() string {
	return "CouponType"
}

func (t CouponType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return nil, diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	appliesToAttribute, ok := attributes["applies_to"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applies_to is missing from object`)

		return nil, diags
	}

	appliesToVal, ok := appliesToAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applies_to expected to be basetypes.ObjectValue, was: %T`, appliesToAttribute))
	}

	billableMetricCodesAttribute, ok := attributes["billable_metric_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable_metric_codes is missing from object`)

		return nil, diags
	}

	billableMetricCodesVal, ok := billableMetricCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable_metric_codes expected to be basetypes.ListValue, was: %T`, billableMetricCodesAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	couponTypeAttribute, ok := attributes["coupon_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coupon_type is missing from object`)

		return nil, diags
	}

	couponTypeVal, ok := couponTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coupon_type expected to be basetypes.StringValue, was: %T`, couponTypeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	expirationAttribute, ok := attributes["expiration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expiration is missing from object`)

		return nil, diags
	}

	expirationVal, ok := expirationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expiration expected to be basetypes.StringValue, was: %T`, expirationAttribute))
	}

	expirationAtAttribute, ok := attributes["expiration_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expiration_at is missing from object`)

		return nil, diags
	}

	expirationAtVal, ok := expirationAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expiration_at expected to be basetypes.StringValue, was: %T`, expirationAtAttribute))
	}

	frequencyAttribute, ok := attributes["frequency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`frequency is missing from object`)

		return nil, diags
	}

	frequencyVal, ok := frequencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`frequency expected to be basetypes.StringValue, was: %T`, frequencyAttribute))
	}

	frequencyDurationAttribute, ok := attributes["frequency_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`frequency_duration is missing from object`)

		return nil, diags
	}

	frequencyDurationVal, ok := frequencyDurationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`frequency_duration expected to be basetypes.Int64Value, was: %T`, frequencyDurationAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	limitedBillableMetricsAttribute, ok := attributes["limited_billable_metrics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limited_billable_metrics is missing from object`)

		return nil, diags
	}

	limitedBillableMetricsVal, ok := limitedBillableMetricsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limited_billable_metrics expected to be basetypes.BoolValue, was: %T`, limitedBillableMetricsAttribute))
	}

	limitedPlansAttribute, ok := attributes["limited_plans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limited_plans is missing from object`)

		return nil, diags
	}

	limitedPlansVal, ok := limitedPlansAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limited_plans expected to be basetypes.BoolValue, was: %T`, limitedPlansAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	percentageRateAttribute, ok := attributes["percentage_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentage_rate is missing from object`)

		return nil, diags
	}

	percentageRateVal, ok := percentageRateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentage_rate expected to be basetypes.StringValue, was: %T`, percentageRateAttribute))
	}

	planCodesAttribute, ok := attributes["plan_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_codes is missing from object`)

		return nil, diags
	}

	planCodesVal, ok := planCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_codes expected to be basetypes.ListValue, was: %T`, planCodesAttribute))
	}

	reusableAttribute, ok := attributes["reusable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reusable is missing from object`)

		return nil, diags
	}

	reusableVal, ok := reusableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reusable expected to be basetypes.BoolValue, was: %T`, reusableAttribute))
	}

	terminatedAtAttribute, ok := attributes["terminated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`terminated_at is missing from object`)

		return nil, diags
	}

	terminatedAtVal, ok := terminatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`terminated_at expected to be basetypes.StringValue, was: %T`, terminatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CouponValue{
		AmountCents:            amountCentsVal,
		AmountCurrency:         amountCurrencyVal,
		AppliesTo:              appliesToVal,
		BillableMetricCodes:    billableMetricCodesVal,
		Code:                   codeVal,
		CouponType:             couponTypeVal,
		CreatedAt:              createdAtVal,
		Description:            descriptionVal,
		Expiration:             expirationVal,
		ExpirationAt:           expirationAtVal,
		Frequency:              frequencyVal,
		FrequencyDuration:      frequencyDurationVal,
		LagoId:                 lagoIdVal,
		LimitedBillableMetrics: limitedBillableMetricsVal,
		LimitedPlans:           limitedPlansVal,
		Name:                   nameVal,
		PercentageRate:         percentageRateVal,
		PlanCodes:              planCodesVal,
		Reusable:               reusableVal,
		TerminatedAt:           terminatedAtVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewCouponValueNull() CouponValue {
	return CouponValue{
		state: attr.ValueStateNull,
	}
}

func NewCouponValueUnknown() CouponValue {
	return CouponValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCouponValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CouponValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CouponValue Attribute Value",
				"While creating a CouponValue value, a missing attribute value was detected. "+
					"A CouponValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CouponValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CouponValue Attribute Type",
				"While creating a CouponValue value, an invalid attribute value was detected. "+
					"A CouponValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CouponValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CouponValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CouponValue Attribute Value",
				"While creating a CouponValue value, an extra attribute value was detected. "+
					"A CouponValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CouponValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCouponValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	appliesToAttribute, ok := attributes["applies_to"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applies_to is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	appliesToVal, ok := appliesToAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applies_to expected to be basetypes.ObjectValue, was: %T`, appliesToAttribute))
	}

	billableMetricCodesAttribute, ok := attributes["billable_metric_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable_metric_codes is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	billableMetricCodesVal, ok := billableMetricCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable_metric_codes expected to be basetypes.ListValue, was: %T`, billableMetricCodesAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	couponTypeAttribute, ok := attributes["coupon_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coupon_type is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	couponTypeVal, ok := couponTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coupon_type expected to be basetypes.StringValue, was: %T`, couponTypeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	expirationAttribute, ok := attributes["expiration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expiration is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	expirationVal, ok := expirationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expiration expected to be basetypes.StringValue, was: %T`, expirationAttribute))
	}

	expirationAtAttribute, ok := attributes["expiration_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expiration_at is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	expirationAtVal, ok := expirationAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expiration_at expected to be basetypes.StringValue, was: %T`, expirationAtAttribute))
	}

	frequencyAttribute, ok := attributes["frequency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`frequency is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	frequencyVal, ok := frequencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`frequency expected to be basetypes.StringValue, was: %T`, frequencyAttribute))
	}

	frequencyDurationAttribute, ok := attributes["frequency_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`frequency_duration is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	frequencyDurationVal, ok := frequencyDurationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`frequency_duration expected to be basetypes.Int64Value, was: %T`, frequencyDurationAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	limitedBillableMetricsAttribute, ok := attributes["limited_billable_metrics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limited_billable_metrics is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	limitedBillableMetricsVal, ok := limitedBillableMetricsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limited_billable_metrics expected to be basetypes.BoolValue, was: %T`, limitedBillableMetricsAttribute))
	}

	limitedPlansAttribute, ok := attributes["limited_plans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limited_plans is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	limitedPlansVal, ok := limitedPlansAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limited_plans expected to be basetypes.BoolValue, was: %T`, limitedPlansAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	percentageRateAttribute, ok := attributes["percentage_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentage_rate is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	percentageRateVal, ok := percentageRateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentage_rate expected to be basetypes.StringValue, was: %T`, percentageRateAttribute))
	}

	planCodesAttribute, ok := attributes["plan_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_codes is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	planCodesVal, ok := planCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_codes expected to be basetypes.ListValue, was: %T`, planCodesAttribute))
	}

	reusableAttribute, ok := attributes["reusable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reusable is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	reusableVal, ok := reusableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reusable expected to be basetypes.BoolValue, was: %T`, reusableAttribute))
	}

	terminatedAtAttribute, ok := attributes["terminated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`terminated_at is missing from object`)

		return NewCouponValueUnknown(), diags
	}

	terminatedAtVal, ok := terminatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`terminated_at expected to be basetypes.StringValue, was: %T`, terminatedAtAttribute))
	}

	if diags.HasError() {
		return NewCouponValueUnknown(), diags
	}

	return CouponValue{
		AmountCents:            amountCentsVal,
		AmountCurrency:         amountCurrencyVal,
		AppliesTo:              appliesToVal,
		BillableMetricCodes:    billableMetricCodesVal,
		Code:                   codeVal,
		CouponType:             couponTypeVal,
		CreatedAt:              createdAtVal,
		Description:            descriptionVal,
		Expiration:             expirationVal,
		ExpirationAt:           expirationAtVal,
		Frequency:              frequencyVal,
		FrequencyDuration:      frequencyDurationVal,
		LagoId:                 lagoIdVal,
		LimitedBillableMetrics: limitedBillableMetricsVal,
		LimitedPlans:           limitedPlansVal,
		Name:                   nameVal,
		PercentageRate:         percentageRateVal,
		PlanCodes:              planCodesVal,
		Reusable:               reusableVal,
		TerminatedAt:           terminatedAtVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewCouponValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CouponValue {
	object, diags := NewCouponValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCouponValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CouponType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCouponValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCouponValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCouponValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCouponValueMust(CouponValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CouponType) ValueType(ctx context.Context) attr.Value {
	return CouponValue{}
}

var _ basetypes.ObjectValuable = CouponValue{}

type CouponValue struct {
	AmountCents            basetypes.Int64Value  `tfsdk:"amount_cents"`
	AmountCurrency         basetypes.StringValue `tfsdk:"amount_currency"`
	AppliesTo              basetypes.ObjectValue `tfsdk:"applies_to"`
	BillableMetricCodes    basetypes.ListValue   `tfsdk:"billable_metric_codes"`
	Code                   basetypes.StringValue `tfsdk:"code"`
	CouponType             basetypes.StringValue `tfsdk:"coupon_type"`
	CreatedAt              basetypes.StringValue `tfsdk:"created_at"`
	Description            basetypes.StringValue `tfsdk:"description"`
	Expiration             basetypes.StringValue `tfsdk:"expiration"`
	ExpirationAt           basetypes.StringValue `tfsdk:"expiration_at"`
	Frequency              basetypes.StringValue `tfsdk:"frequency"`
	FrequencyDuration      basetypes.Int64Value  `tfsdk:"frequency_duration"`
	LagoId                 basetypes.StringValue `tfsdk:"lago_id"`
	LimitedBillableMetrics basetypes.BoolValue   `tfsdk:"limited_billable_metrics"`
	LimitedPlans           basetypes.BoolValue   `tfsdk:"limited_plans"`
	Name                   basetypes.StringValue `tfsdk:"name"`
	PercentageRate         basetypes.StringValue `tfsdk:"percentage_rate"`
	PlanCodes              basetypes.ListValue   `tfsdk:"plan_codes"`
	Reusable               basetypes.BoolValue   `tfsdk:"reusable"`
	TerminatedAt           basetypes.StringValue `tfsdk:"terminated_at"`
	state                  attr.ValueState
}

func (v CouponValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 20)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["amount_currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["applies_to"] = basetypes.ObjectType{
		AttrTypes: AppliesToValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["billable_metric_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["coupon_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["expiration"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["expiration_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["frequency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["frequency_duration"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["limited_billable_metrics"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["limited_plans"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["percentage_rate"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["plan_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["reusable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["terminated_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 20)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.AmountCurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_currency"] = val

		val, err = v.AppliesTo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["applies_to"] = val

		val, err = v.BillableMetricCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billable_metric_codes"] = val

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.CouponType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coupon_type"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Expiration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expiration"] = val

		val, err = v.ExpirationAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expiration_at"] = val

		val, err = v.Frequency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["frequency"] = val

		val, err = v.FrequencyDuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["frequency_duration"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.LimitedBillableMetrics.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limited_billable_metrics"] = val

		val, err = v.LimitedPlans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limited_plans"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PercentageRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["percentage_rate"] = val

		val, err = v.PlanCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan_codes"] = val

		val, err = v.Reusable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reusable"] = val

		val, err = v.TerminatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["terminated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CouponValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CouponValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CouponValue) String() string {
	return "CouponValue"
}

func (v CouponValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var appliesTo basetypes.ObjectValue

	if v.AppliesTo.IsNull() {
		appliesTo = types.ObjectNull(
			AppliesToValue{}.AttributeTypes(ctx),
		)
	}

	if v.AppliesTo.IsUnknown() {
		appliesTo = types.ObjectUnknown(
			AppliesToValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AppliesTo.IsNull() && !v.AppliesTo.IsUnknown() {
		appliesTo = types.ObjectValueMust(
			AppliesToValue{}.AttributeTypes(ctx),
			v.AppliesTo.Attributes(),
		)
	}

	var billableMetricCodesVal basetypes.ListValue
	switch {
	case v.BillableMetricCodes.IsUnknown():
		billableMetricCodesVal = types.ListUnknown(types.StringType)
	case v.BillableMetricCodes.IsNull():
		billableMetricCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		billableMetricCodesVal, d = types.ListValue(types.StringType, v.BillableMetricCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount_cents":    basetypes.Int64Type{},
			"amount_currency": basetypes.StringType{},
			"applies_to": basetypes.ObjectType{
				AttrTypes: AppliesToValue{}.AttributeTypes(ctx),
			},
			"billable_metric_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"code":                     basetypes.StringType{},
			"coupon_type":              basetypes.StringType{},
			"created_at":               basetypes.StringType{},
			"description":              basetypes.StringType{},
			"expiration":               basetypes.StringType{},
			"expiration_at":            basetypes.StringType{},
			"frequency":                basetypes.StringType{},
			"frequency_duration":       basetypes.Int64Type{},
			"lago_id":                  basetypes.StringType{},
			"limited_billable_metrics": basetypes.BoolType{},
			"limited_plans":            basetypes.BoolType{},
			"name":                     basetypes.StringType{},
			"percentage_rate":          basetypes.StringType{},
			"plan_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"reusable":      basetypes.BoolType{},
			"terminated_at": basetypes.StringType{},
		}), diags
	}

	var planCodesVal basetypes.ListValue
	switch {
	case v.PlanCodes.IsUnknown():
		planCodesVal = types.ListUnknown(types.StringType)
	case v.PlanCodes.IsNull():
		planCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		planCodesVal, d = types.ListValue(types.StringType, v.PlanCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount_cents":    basetypes.Int64Type{},
			"amount_currency": basetypes.StringType{},
			"applies_to": basetypes.ObjectType{
				AttrTypes: AppliesToValue{}.AttributeTypes(ctx),
			},
			"billable_metric_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"code":                     basetypes.StringType{},
			"coupon_type":              basetypes.StringType{},
			"created_at":               basetypes.StringType{},
			"description":              basetypes.StringType{},
			"expiration":               basetypes.StringType{},
			"expiration_at":            basetypes.StringType{},
			"frequency":                basetypes.StringType{},
			"frequency_duration":       basetypes.Int64Type{},
			"lago_id":                  basetypes.StringType{},
			"limited_billable_metrics": basetypes.BoolType{},
			"limited_plans":            basetypes.BoolType{},
			"name":                     basetypes.StringType{},
			"percentage_rate":          basetypes.StringType{},
			"plan_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"reusable":      basetypes.BoolType{},
			"terminated_at": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"applies_to": basetypes.ObjectType{
			AttrTypes: AppliesToValue{}.AttributeTypes(ctx),
		},
		"billable_metric_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"code":                     basetypes.StringType{},
		"coupon_type":              basetypes.StringType{},
		"created_at":               basetypes.StringType{},
		"description":              basetypes.StringType{},
		"expiration":               basetypes.StringType{},
		"expiration_at":            basetypes.StringType{},
		"frequency":                basetypes.StringType{},
		"frequency_duration":       basetypes.Int64Type{},
		"lago_id":                  basetypes.StringType{},
		"limited_billable_metrics": basetypes.BoolType{},
		"limited_plans":            basetypes.BoolType{},
		"name":                     basetypes.StringType{},
		"percentage_rate":          basetypes.StringType{},
		"plan_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"reusable":      basetypes.BoolType{},
		"terminated_at": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":             v.AmountCents,
			"amount_currency":          v.AmountCurrency,
			"applies_to":               appliesTo,
			"billable_metric_codes":    billableMetricCodesVal,
			"code":                     v.Code,
			"coupon_type":              v.CouponType,
			"created_at":               v.CreatedAt,
			"description":              v.Description,
			"expiration":               v.Expiration,
			"expiration_at":            v.ExpirationAt,
			"frequency":                v.Frequency,
			"frequency_duration":       v.FrequencyDuration,
			"lago_id":                  v.LagoId,
			"limited_billable_metrics": v.LimitedBillableMetrics,
			"limited_plans":            v.LimitedPlans,
			"name":                     v.Name,
			"percentage_rate":          v.PercentageRate,
			"plan_codes":               planCodesVal,
			"reusable":                 v.Reusable,
			"terminated_at":            v.TerminatedAt,
		})

	return objVal, diags
}

func (v CouponValue) Equal(o attr.Value) bool {
	other, ok := o.(CouponValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.AmountCurrency.Equal(other.AmountCurrency) {
		return false
	}

	if !v.AppliesTo.Equal(other.AppliesTo) {
		return false
	}

	if !v.BillableMetricCodes.Equal(other.BillableMetricCodes) {
		return false
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.CouponType.Equal(other.CouponType) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Expiration.Equal(other.Expiration) {
		return false
	}

	if !v.ExpirationAt.Equal(other.ExpirationAt) {
		return false
	}

	if !v.Frequency.Equal(other.Frequency) {
		return false
	}

	if !v.FrequencyDuration.Equal(other.FrequencyDuration) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.LimitedBillableMetrics.Equal(other.LimitedBillableMetrics) {
		return false
	}

	if !v.LimitedPlans.Equal(other.LimitedPlans) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PercentageRate.Equal(other.PercentageRate) {
		return false
	}

	if !v.PlanCodes.Equal(other.PlanCodes) {
		return false
	}

	if !v.Reusable.Equal(other.Reusable) {
		return false
	}

	if !v.TerminatedAt.Equal(other.TerminatedAt) {
		return false
	}

	return true
}

func (v CouponValue) Type(ctx context.Context) attr.Type {
	return CouponType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CouponValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"applies_to": basetypes.ObjectType{
			AttrTypes: AppliesToValue{}.AttributeTypes(ctx),
		},
		"billable_metric_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"code":                     basetypes.StringType{},
		"coupon_type":              basetypes.StringType{},
		"created_at":               basetypes.StringType{},
		"description":              basetypes.StringType{},
		"expiration":               basetypes.StringType{},
		"expiration_at":            basetypes.StringType{},
		"frequency":                basetypes.StringType{},
		"frequency_duration":       basetypes.Int64Type{},
		"lago_id":                  basetypes.StringType{},
		"limited_billable_metrics": basetypes.BoolType{},
		"limited_plans":            basetypes.BoolType{},
		"name":                     basetypes.StringType{},
		"percentage_rate":          basetypes.StringType{},
		"plan_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"reusable":      basetypes.BoolType{},
		"terminated_at": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AppliesToType{}

type AppliesToType struct {
	basetypes.ObjectType
}

func (t AppliesToType) Equal(o attr.Type) bool {
	other, ok := o.(AppliesToType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AppliesToType) String() string {
	return "AppliesToType"
}

func (t AppliesToType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	billableMetricCodesAttribute, ok := attributes["billable_metric_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable_metric_codes is missing from object`)

		return nil, diags
	}

	billableMetricCodesVal, ok := billableMetricCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable_metric_codes expected to be basetypes.ListValue, was: %T`, billableMetricCodesAttribute))
	}

	planCodesAttribute, ok := attributes["plan_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_codes is missing from object`)

		return nil, diags
	}

	planCodesVal, ok := planCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_codes expected to be basetypes.ListValue, was: %T`, planCodesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AppliesToValue{
		BillableMetricCodes: billableMetricCodesVal,
		PlanCodes:           planCodesVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewAppliesToValueNull() AppliesToValue {
	return AppliesToValue{
		state: attr.ValueStateNull,
	}
}

func NewAppliesToValueUnknown() AppliesToValue {
	return AppliesToValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAppliesToValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AppliesToValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AppliesToValue Attribute Value",
				"While creating a AppliesToValue value, a missing attribute value was detected. "+
					"A AppliesToValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppliesToValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AppliesToValue Attribute Type",
				"While creating a AppliesToValue value, an invalid attribute value was detected. "+
					"A AppliesToValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppliesToValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AppliesToValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AppliesToValue Attribute Value",
				"While creating a AppliesToValue value, an extra attribute value was detected. "+
					"A AppliesToValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AppliesToValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAppliesToValueUnknown(), diags
	}

	billableMetricCodesAttribute, ok := attributes["billable_metric_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable_metric_codes is missing from object`)

		return NewAppliesToValueUnknown(), diags
	}

	billableMetricCodesVal, ok := billableMetricCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable_metric_codes expected to be basetypes.ListValue, was: %T`, billableMetricCodesAttribute))
	}

	planCodesAttribute, ok := attributes["plan_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_codes is missing from object`)

		return NewAppliesToValueUnknown(), diags
	}

	planCodesVal, ok := planCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_codes expected to be basetypes.ListValue, was: %T`, planCodesAttribute))
	}

	if diags.HasError() {
		return NewAppliesToValueUnknown(), diags
	}

	return AppliesToValue{
		BillableMetricCodes: billableMetricCodesVal,
		PlanCodes:           planCodesVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewAppliesToValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AppliesToValue {
	object, diags := NewAppliesToValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAppliesToValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AppliesToType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAppliesToValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAppliesToValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAppliesToValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAppliesToValueMust(AppliesToValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AppliesToType) ValueType(ctx context.Context) attr.Value {
	return AppliesToValue{}
}

var _ basetypes.ObjectValuable = AppliesToValue{}

type AppliesToValue struct {
	BillableMetricCodes basetypes.ListValue `tfsdk:"billable_metric_codes"`
	PlanCodes           basetypes.ListValue `tfsdk:"plan_codes"`
	state               attr.ValueState
}

func (v AppliesToValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["billable_metric_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["plan_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.BillableMetricCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billable_metric_codes"] = val

		val, err = v.PlanCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan_codes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AppliesToValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AppliesToValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AppliesToValue) String() string {
	return "AppliesToValue"
}

func (v AppliesToValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var billableMetricCodesVal basetypes.ListValue
	switch {
	case v.BillableMetricCodes.IsUnknown():
		billableMetricCodesVal = types.ListUnknown(types.StringType)
	case v.BillableMetricCodes.IsNull():
		billableMetricCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		billableMetricCodesVal, d = types.ListValue(types.StringType, v.BillableMetricCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"billable_metric_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"plan_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var planCodesVal basetypes.ListValue
	switch {
	case v.PlanCodes.IsUnknown():
		planCodesVal = types.ListUnknown(types.StringType)
	case v.PlanCodes.IsNull():
		planCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		planCodesVal, d = types.ListValue(types.StringType, v.PlanCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"billable_metric_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"plan_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"billable_metric_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"plan_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"billable_metric_codes": billableMetricCodesVal,
			"plan_codes":            planCodesVal,
		})

	return objVal, diags
}

func (v AppliesToValue) Equal(o attr.Value) bool {
	other, ok := o.(AppliesToValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BillableMetricCodes.Equal(other.BillableMetricCodes) {
		return false
	}

	if !v.PlanCodes.Equal(other.PlanCodes) {
		return false
	}

	return true
}

func (v AppliesToValue) Type(ctx context.Context) attr.Type {
	return AppliesToType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AppliesToValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"billable_metric_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"plan_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}
