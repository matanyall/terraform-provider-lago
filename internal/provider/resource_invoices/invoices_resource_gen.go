// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_invoices

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func InvoicesResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"invoice": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"currency": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AED",
								"AFN",
								"ALL",
								"AMD",
								"ANG",
								"AOA",
								"ARS",
								"AUD",
								"AWG",
								"AZN",
								"BAM",
								"BBD",
								"BDT",
								"BGN",
								"BIF",
								"BMD",
								"BND",
								"BOB",
								"BRL",
								"BSD",
								"BWP",
								"BYN",
								"BZD",
								"CAD",
								"CDF",
								"CHF",
								"CLF",
								"CLP",
								"CNY",
								"COP",
								"CRC",
								"CVE",
								"CZK",
								"DJF",
								"DKK",
								"DOP",
								"DZD",
								"EGP",
								"ETB",
								"EUR",
								"FJD",
								"FKP",
								"GBP",
								"GEL",
								"GIP",
								"GMD",
								"GNF",
								"GTQ",
								"GYD",
								"HKD",
								"HNL",
								"HRK",
								"HTG",
								"HUF",
								"IDR",
								"ILS",
								"INR",
								"ISK",
								"JMD",
								"JPY",
								"KES",
								"KGS",
								"KHR",
								"KMF",
								"KRW",
								"KYD",
								"KZT",
								"LAK",
								"LBP",
								"LKR",
								"LRD",
								"LSL",
								"MAD",
								"MDL",
								"MGA",
								"MKD",
								"MMK",
								"MNT",
								"MOP",
								"MRO",
								"MUR",
								"MVR",
								"MWK",
								"MXN",
								"MYR",
								"MZN",
								"NAD",
								"NGN",
								"NIO",
								"NOK",
								"NPR",
								"NZD",
								"PAB",
								"PEN",
								"PGK",
								"PHP",
								"PKR",
								"PLN",
								"PYG",
								"QAR",
								"RON",
								"RSD",
								"RUB",
								"RWF",
								"SAR",
								"SBD",
								"SCR",
								"SEK",
								"SGD",
								"SHP",
								"SLL",
								"SOS",
								"SRD",
								"STD",
								"SZL",
								"THB",
								"TJS",
								"TOP",
								"TRY",
								"TTD",
								"TWD",
								"TZS",
								"UAH",
								"UGX",
								"USD",
								"UYU",
								"UZS",
								"VND",
								"VUV",
								"WST",
								"XAF",
								"XCD",
								"XOF",
								"XPF",
								"YER",
								"ZAR",
								"ZMW",
							),
						},
					},
					"external_customer_id": schema.StringAttribute{
						Required:            true,
						Description:         "Unique identifier assigned to the customer in your application.",
						MarkdownDescription: "Unique identifier assigned to the customer in your application.",
					},
					"fees": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"add_on_code": schema.StringAttribute{
									Required:            true,
									Description:         "The code of the add-on used as invoice item.",
									MarkdownDescription: "The code of the add-on used as invoice item.",
								},
								"description": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "This is a description",
									MarkdownDescription: "This is a description",
								},
								"invoice_display_name": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
									MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
								},
								"tax_codes": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "List of unique code used to identify the taxes.",
									MarkdownDescription: "List of unique code used to identify the taxes.",
								},
								"unit_amount_cents": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "The amount of the fee per unit, expressed in cents. By default, the amount of the add-on is used.",
									MarkdownDescription: "The amount of the fee per unit, expressed in cents. By default, the amount of the add-on is used.",
								},
								"units": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The quantity of units associated with the fee. By default, only 1 unit is added to the invoice.",
									MarkdownDescription: "The quantity of units associated with the fee. By default, only 1 unit is added to the invoice.",
									Validators: []validator.String{
										stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
									},
								},
							},
							CustomType: FeesType{
								ObjectType: types.ObjectType{
									AttrTypes: FeesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Required: true,
					},
				},
				CustomType: InvoiceType{
					ObjectType: types.ObjectType{
						AttrTypes: InvoiceValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"lago_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Unique identifier assigned to the invoice within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the invoice's record within the Lago system.",
				MarkdownDescription: "Unique identifier assigned to the invoice within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the invoice's record within the Lago system.",
			},
		},
	}
}

type InvoicesModel struct {
	Invoice InvoiceValue `tfsdk:"invoice"`
	LagoId  types.String `tfsdk:"lago_id"`
}

var _ basetypes.ObjectTypable = InvoiceType{}

type InvoiceType struct {
	basetypes.ObjectType
}

func (t InvoiceType) Equal(o attr.Type) bool {
	other, ok := o.(InvoiceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InvoiceType) String() string {
	return "InvoiceType"
}

func (t InvoiceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return nil, diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	externalCustomerIdAttribute, ok := attributes["external_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_customer_id is missing from object`)

		return nil, diags
	}

	externalCustomerIdVal, ok := externalCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_customer_id expected to be basetypes.StringValue, was: %T`, externalCustomerIdAttribute))
	}

	feesAttribute, ok := attributes["fees"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fees is missing from object`)

		return nil, diags
	}

	feesVal, ok := feesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fees expected to be basetypes.ListValue, was: %T`, feesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InvoiceValue{
		Currency:           currencyVal,
		ExternalCustomerId: externalCustomerIdVal,
		Fees:               feesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewInvoiceValueNull() InvoiceValue {
	return InvoiceValue{
		state: attr.ValueStateNull,
	}
}

func NewInvoiceValueUnknown() InvoiceValue {
	return InvoiceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInvoiceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InvoiceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InvoiceValue Attribute Value",
				"While creating a InvoiceValue value, a missing attribute value was detected. "+
					"A InvoiceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InvoiceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InvoiceValue Attribute Type",
				"While creating a InvoiceValue value, an invalid attribute value was detected. "+
					"A InvoiceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InvoiceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InvoiceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InvoiceValue Attribute Value",
				"While creating a InvoiceValue value, an extra attribute value was detected. "+
					"A InvoiceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InvoiceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInvoiceValueUnknown(), diags
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return NewInvoiceValueUnknown(), diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	externalCustomerIdAttribute, ok := attributes["external_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_customer_id is missing from object`)

		return NewInvoiceValueUnknown(), diags
	}

	externalCustomerIdVal, ok := externalCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_customer_id expected to be basetypes.StringValue, was: %T`, externalCustomerIdAttribute))
	}

	feesAttribute, ok := attributes["fees"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fees is missing from object`)

		return NewInvoiceValueUnknown(), diags
	}

	feesVal, ok := feesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fees expected to be basetypes.ListValue, was: %T`, feesAttribute))
	}

	if diags.HasError() {
		return NewInvoiceValueUnknown(), diags
	}

	return InvoiceValue{
		Currency:           currencyVal,
		ExternalCustomerId: externalCustomerIdVal,
		Fees:               feesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewInvoiceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InvoiceValue {
	object, diags := NewInvoiceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInvoiceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InvoiceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInvoiceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInvoiceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInvoiceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInvoiceValueMust(InvoiceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InvoiceType) ValueType(ctx context.Context) attr.Value {
	return InvoiceValue{}
}

var _ basetypes.ObjectValuable = InvoiceValue{}

type InvoiceValue struct {
	Currency           basetypes.StringValue `tfsdk:"currency"`
	ExternalCustomerId basetypes.StringValue `tfsdk:"external_customer_id"`
	Fees               basetypes.ListValue   `tfsdk:"fees"`
	state              attr.ValueState
}

func (v InvoiceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_customer_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fees"] = basetypes.ListType{
		ElemType: FeesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Currency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["currency"] = val

		val, err = v.ExternalCustomerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_customer_id"] = val

		val, err = v.Fees.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fees"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InvoiceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InvoiceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InvoiceValue) String() string {
	return "InvoiceValue"
}

func (v InvoiceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	fees := types.ListValueMust(
		FeesType{
			basetypes.ObjectType{
				AttrTypes: FeesValue{}.AttributeTypes(ctx),
			},
		},
		v.Fees.Elements(),
	)

	if v.Fees.IsNull() {
		fees = types.ListNull(
			FeesType{
				basetypes.ObjectType{
					AttrTypes: FeesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Fees.IsUnknown() {
		fees = types.ListUnknown(
			FeesType{
				basetypes.ObjectType{
					AttrTypes: FeesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"currency":             basetypes.StringType{},
		"external_customer_id": basetypes.StringType{},
		"fees": basetypes.ListType{
			ElemType: FeesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"currency":             v.Currency,
			"external_customer_id": v.ExternalCustomerId,
			"fees":                 fees,
		})

	return objVal, diags
}

func (v InvoiceValue) Equal(o attr.Value) bool {
	other, ok := o.(InvoiceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Currency.Equal(other.Currency) {
		return false
	}

	if !v.ExternalCustomerId.Equal(other.ExternalCustomerId) {
		return false
	}

	if !v.Fees.Equal(other.Fees) {
		return false
	}

	return true
}

func (v InvoiceValue) Type(ctx context.Context) attr.Type {
	return InvoiceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InvoiceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"currency":             basetypes.StringType{},
		"external_customer_id": basetypes.StringType{},
		"fees": basetypes.ListType{
			ElemType: FeesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = FeesType{}

type FeesType struct {
	basetypes.ObjectType
}

func (t FeesType) Equal(o attr.Type) bool {
	other, ok := o.(FeesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FeesType) String() string {
	return "FeesType"
}

func (t FeesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addOnCodeAttribute, ok := attributes["add_on_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_on_code is missing from object`)

		return nil, diags
	}

	addOnCodeVal, ok := addOnCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_on_code expected to be basetypes.StringValue, was: %T`, addOnCodeAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return nil, diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	unitAmountCentsAttribute, ok := attributes["unit_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit_amount_cents is missing from object`)

		return nil, diags
	}

	unitAmountCentsVal, ok := unitAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit_amount_cents expected to be basetypes.Int64Value, was: %T`, unitAmountCentsAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return nil, diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FeesValue{
		AddOnCode:          addOnCodeVal,
		Description:        descriptionVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		TaxCodes:           taxCodesVal,
		UnitAmountCents:    unitAmountCentsVal,
		Units:              unitsVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewFeesValueNull() FeesValue {
	return FeesValue{
		state: attr.ValueStateNull,
	}
}

func NewFeesValueUnknown() FeesValue {
	return FeesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFeesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FeesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FeesValue Attribute Value",
				"While creating a FeesValue value, a missing attribute value was detected. "+
					"A FeesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FeesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FeesValue Attribute Type",
				"While creating a FeesValue value, an invalid attribute value was detected. "+
					"A FeesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FeesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FeesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FeesValue Attribute Value",
				"While creating a FeesValue value, an extra attribute value was detected. "+
					"A FeesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FeesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFeesValueUnknown(), diags
	}

	addOnCodeAttribute, ok := attributes["add_on_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_on_code is missing from object`)

		return NewFeesValueUnknown(), diags
	}

	addOnCodeVal, ok := addOnCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_on_code expected to be basetypes.StringValue, was: %T`, addOnCodeAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewFeesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewFeesValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return NewFeesValueUnknown(), diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	unitAmountCentsAttribute, ok := attributes["unit_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit_amount_cents is missing from object`)

		return NewFeesValueUnknown(), diags
	}

	unitAmountCentsVal, ok := unitAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit_amount_cents expected to be basetypes.Int64Value, was: %T`, unitAmountCentsAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return NewFeesValueUnknown(), diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	if diags.HasError() {
		return NewFeesValueUnknown(), diags
	}

	return FeesValue{
		AddOnCode:          addOnCodeVal,
		Description:        descriptionVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		TaxCodes:           taxCodesVal,
		UnitAmountCents:    unitAmountCentsVal,
		Units:              unitsVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewFeesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FeesValue {
	object, diags := NewFeesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFeesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FeesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFeesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFeesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFeesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFeesValueMust(FeesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FeesType) ValueType(ctx context.Context) attr.Value {
	return FeesValue{}
}

var _ basetypes.ObjectValuable = FeesValue{}

type FeesValue struct {
	AddOnCode          basetypes.StringValue `tfsdk:"add_on_code"`
	Description        basetypes.StringValue `tfsdk:"description"`
	InvoiceDisplayName basetypes.StringValue `tfsdk:"invoice_display_name"`
	TaxCodes           basetypes.ListValue   `tfsdk:"tax_codes"`
	UnitAmountCents    basetypes.Int64Value  `tfsdk:"unit_amount_cents"`
	Units              basetypes.StringValue `tfsdk:"units"`
	state              attr.ValueState
}

func (v FeesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["add_on_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tax_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["unit_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["units"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.AddOnCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["add_on_code"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.TaxCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_codes"] = val

		val, err = v.UnitAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit_amount_cents"] = val

		val, err = v.Units.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["units"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FeesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FeesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FeesValue) String() string {
	return "FeesValue"
}

func (v FeesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var taxCodesVal basetypes.ListValue
	switch {
	case v.TaxCodes.IsUnknown():
		taxCodesVal = types.ListUnknown(types.StringType)
	case v.TaxCodes.IsNull():
		taxCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		taxCodesVal, d = types.ListValue(types.StringType, v.TaxCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add_on_code":          basetypes.StringType{},
			"description":          basetypes.StringType{},
			"invoice_display_name": basetypes.StringType{},
			"tax_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"unit_amount_cents": basetypes.Int64Type{},
			"units":             basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"add_on_code":          basetypes.StringType{},
		"description":          basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"unit_amount_cents": basetypes.Int64Type{},
		"units":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"add_on_code":          v.AddOnCode,
			"description":          v.Description,
			"invoice_display_name": v.InvoiceDisplayName,
			"tax_codes":            taxCodesVal,
			"unit_amount_cents":    v.UnitAmountCents,
			"units":                v.Units,
		})

	return objVal, diags
}

func (v FeesValue) Equal(o attr.Value) bool {
	other, ok := o.(FeesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddOnCode.Equal(other.AddOnCode) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.TaxCodes.Equal(other.TaxCodes) {
		return false
	}

	if !v.UnitAmountCents.Equal(other.UnitAmountCents) {
		return false
	}

	if !v.Units.Equal(other.Units) {
		return false
	}

	return true
}

func (v FeesValue) Type(ctx context.Context) attr.Type {
	return FeesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FeesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"add_on_code":          basetypes.StringType{},
		"description":          basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"unit_amount_cents": basetypes.Int64Type{},
		"units":             basetypes.StringType{},
	}
}
