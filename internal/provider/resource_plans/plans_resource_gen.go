// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_plans

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func PlansResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"code": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The code of the plan. It serves as a unique identifier associated with a particular plan. The code is typically used for internal or system-level identification purposes, like assigning a subscription, for instance.",
				MarkdownDescription: "The code of the plan. It serves as a unique identifier associated with a particular plan. The code is typically used for internal or system-level identification purposes, like assigning a subscription, for instance.",
			},
			"plan": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"amount_cents": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "The base cost of the plan, excluding any applicable taxes, that is billed on a recurring basis. This value is defined at 0 if your plan is a pay-as-you-go plan.",
						MarkdownDescription: "The base cost of the plan, excluding any applicable taxes, that is billed on a recurring basis. This value is defined at 0 if your plan is a pay-as-you-go plan.",
					},
					"amount_currency": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AED",
								"AFN",
								"ALL",
								"AMD",
								"ANG",
								"AOA",
								"ARS",
								"AUD",
								"AWG",
								"AZN",
								"BAM",
								"BBD",
								"BDT",
								"BGN",
								"BIF",
								"BMD",
								"BND",
								"BOB",
								"BRL",
								"BSD",
								"BWP",
								"BYN",
								"BZD",
								"CAD",
								"CDF",
								"CHF",
								"CLF",
								"CLP",
								"CNY",
								"COP",
								"CRC",
								"CVE",
								"CZK",
								"DJF",
								"DKK",
								"DOP",
								"DZD",
								"EGP",
								"ETB",
								"EUR",
								"FJD",
								"FKP",
								"GBP",
								"GEL",
								"GIP",
								"GMD",
								"GNF",
								"GTQ",
								"GYD",
								"HKD",
								"HNL",
								"HRK",
								"HTG",
								"HUF",
								"IDR",
								"ILS",
								"INR",
								"ISK",
								"JMD",
								"JPY",
								"KES",
								"KGS",
								"KHR",
								"KMF",
								"KRW",
								"KYD",
								"KZT",
								"LAK",
								"LBP",
								"LKR",
								"LRD",
								"LSL",
								"MAD",
								"MDL",
								"MGA",
								"MKD",
								"MMK",
								"MNT",
								"MOP",
								"MRO",
								"MUR",
								"MVR",
								"MWK",
								"MXN",
								"MYR",
								"MZN",
								"NAD",
								"NGN",
								"NIO",
								"NOK",
								"NPR",
								"NZD",
								"PAB",
								"PEN",
								"PGK",
								"PHP",
								"PKR",
								"PLN",
								"PYG",
								"QAR",
								"RON",
								"RSD",
								"RUB",
								"RWF",
								"SAR",
								"SBD",
								"SCR",
								"SEK",
								"SGD",
								"SHP",
								"SLL",
								"SOS",
								"SRD",
								"STD",
								"SZL",
								"THB",
								"TJS",
								"TOP",
								"TRY",
								"TTD",
								"TWD",
								"TZS",
								"UAH",
								"UGX",
								"USD",
								"UYU",
								"UZS",
								"VND",
								"VUV",
								"WST",
								"XAF",
								"XCD",
								"XOF",
								"XPF",
								"YER",
								"ZAR",
								"ZMW",
							),
						},
					},
					"bill_charges_monthly": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "This field, when set to `true`, enables to invoice usage-based charges on monthly basis, even if the cadence of the plan is yearly. This allows customers to pay charges overage on a monthly basis. This can be set to true only if the plan's interval is `yearly`.",
						MarkdownDescription: "This field, when set to `true`, enables to invoice usage-based charges on monthly basis, even if the cadence of the plan is yearly. This allows customers to pay charges overage on a monthly basis. This can be set to true only if the plan's interval is `yearly`.",
					},
					"charges": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"billable_metric_code": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique code identifying a billable metric.",
									MarkdownDescription: "Unique code identifying a billable metric.",
								},
								"billable_metric_id": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Unique identifier of the billable metric created by Lago.",
									MarkdownDescription: "Unique identifier of the billable metric created by Lago.",
								},
								"charge_model": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Specifies the pricing model used for the calculation of the final fee. It can be `standard`, `graduated`, `graduated_percentage` `package`, `percentage`, `volume` or `dynamic`.",
									MarkdownDescription: "Specifies the pricing model used for the calculation of the final fee. It can be `standard`, `graduated`, `graduated_percentage` `package`, `percentage`, `volume` or `dynamic`.",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"standard",
											"graduated",
											"graduated_percentage",
											"package",
											"percentage",
											"volume",
											"dynamic",
										),
									},
								},
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The date and time when the charge was created. It is expressed in UTC format according to the ISO 8601 datetime standard.",
									MarkdownDescription: "The date and time when the charge was created. It is expressed in UTC format according to the ISO 8601 datetime standard.",
								},
								"filters": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"invoice_display_name": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the values of the filter will be used as the default display name.",
												MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the values of the filter will be used as the default display name.",
											},
											"properties": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"amount": schema.StringAttribute{
														Optional:            true,
														Computed:            true,
														Description:         "- The unit price, excluding tax, for a `standard` charge model. It is expressed as a decimal value.\n- The amount, excluding tax, for a complete set of units in a `package` charge model. It is expressed as a decimal value.",
														MarkdownDescription: "- The unit price, excluding tax, for a `standard` charge model. It is expressed as a decimal value.\n- The amount, excluding tax, for a complete set of units in a `package` charge model. It is expressed as a decimal value.",
														Validators: []validator.String{
															stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
														},
													},
													"fixed_amount": schema.StringAttribute{
														Optional:            true,
														Computed:            true,
														Description:         "The fixed fee that is applied to each transaction for a `percentage` charge model. It is expressed as a decimal value.",
														MarkdownDescription: "The fixed fee that is applied to each transaction for a `percentage` charge model. It is expressed as a decimal value.",
														Validators: []validator.String{
															stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
														},
													},
													"free_units": schema.Int64Attribute{
														Optional:            true,
														Computed:            true,
														Description:         "The quantity of units that are provided free of charge for each billing period in a `package` charge model. This field specifies the number of units that customers can use without incurring any additional cost during each billing cycle.",
														MarkdownDescription: "The quantity of units that are provided free of charge for each billing period in a `package` charge model. This field specifies the number of units that customers can use without incurring any additional cost during each billing cycle.",
													},
													"free_units_per_events": schema.Int64Attribute{
														Optional:            true,
														Computed:            true,
														Description:         "The count of transactions that are not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the number of transactions that are exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
														MarkdownDescription: "The count of transactions that are not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the number of transactions that are exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
													},
													"free_units_per_total_aggregation": schema.StringAttribute{
														Optional:            true,
														Computed:            true,
														Description:         "The transaction amount that is not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the portion of the transaction amount that is exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
														MarkdownDescription: "The transaction amount that is not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the portion of the transaction amount that is exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
														Validators: []validator.String{
															stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
														},
													},
													"graduated_percentage_ranges": schema.ListNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"flat_amount": schema.StringAttribute{
																	Required:            true,
																	Description:         "The flat amount for a whole tier, excluding tax, for a `graduated_percentage` charge model. It is expressed as a decimal value.",
																	MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `graduated_percentage` charge model. It is expressed as a decimal value.",
																},
																"from_value": schema.Int64Attribute{
																	Required:            true,
																	Description:         "Specifies the lower value of a tier for a `graduated_percentage` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																	MarkdownDescription: "Specifies the lower value of a tier for a `graduated_percentage` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																},
																"rate": schema.StringAttribute{
																	Required:            true,
																	Description:         "The percentage rate that is applied to the amount of each transaction in the tier for a `graduated_percentage` charge model. It is expressed as a decimal value.",
																	MarkdownDescription: "The percentage rate that is applied to the amount of each transaction in the tier for a `graduated_percentage` charge model. It is expressed as a decimal value.",
																},
																"to_value": schema.Int64Attribute{
																	Required:            true,
																	Description:         "Specifies the highest value of a tier for a `graduated_percentage` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
																	MarkdownDescription: "Specifies the highest value of a tier for a `graduated_percentage` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
																},
															},
															CustomType: GraduatedPercentageRangesType{
																ObjectType: types.ObjectType{
																	AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
																},
															},
														},
														Optional:            true,
														Computed:            true,
														Description:         "Graduated percentage ranges, sorted from bottom to top tiers, used for a `graduated_percentage` charge model.",
														MarkdownDescription: "Graduated percentage ranges, sorted from bottom to top tiers, used for a `graduated_percentage` charge model.",
													},
													"graduated_ranges": schema.ListNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"flat_amount": schema.StringAttribute{
																	Required:            true,
																	Description:         "The flat amount for a whole tier, excluding tax, for a `graduated` charge model. It is expressed as a decimal value.",
																	MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `graduated` charge model. It is expressed as a decimal value.",
																	Validators: []validator.String{
																		stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																	},
																},
																"from_value": schema.Int64Attribute{
																	Required:            true,
																	Description:         "Specifies the lower value of a tier for a `graduated` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																	MarkdownDescription: "Specifies the lower value of a tier for a `graduated` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																},
																"per_unit_amount": schema.StringAttribute{
																	Required:            true,
																	Description:         "The unit price, excluding tax, for a specific tier of a `graduated` charge model. It is expressed as a decimal value.",
																	MarkdownDescription: "The unit price, excluding tax, for a specific tier of a `graduated` charge model. It is expressed as a decimal value.",
																	Validators: []validator.String{
																		stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																	},
																},
																"to_value": schema.Int64Attribute{
																	Required:            true,
																	Description:         "Specifies the highest value of a tier for a `graduated` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
																	MarkdownDescription: "Specifies the highest value of a tier for a `graduated` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
																},
															},
															CustomType: GraduatedRangesType{
																ObjectType: types.ObjectType{
																	AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
																},
															},
														},
														Optional:            true,
														Computed:            true,
														Description:         "Graduated ranges, sorted from bottom to top tiers, used for a `graduated` charge model.",
														MarkdownDescription: "Graduated ranges, sorted from bottom to top tiers, used for a `graduated` charge model.",
													},
													"grouped_by": schema.ListAttribute{
														ElementType:         types.StringType,
														Optional:            true,
														Computed:            true,
														Description:         "The list of event properties that are used to group the events on the invoice for a `standard` charge model.",
														MarkdownDescription: "The list of event properties that are used to group the events on the invoice for a `standard` charge model.",
													},
													"package_size": schema.Int64Attribute{
														Optional:            true,
														Computed:            true,
														Description:         "The quantity of units included in each pack or set for a `package` charge model. It indicates the number of units that are bundled together as a single package or set within the pricing structure.",
														MarkdownDescription: "The quantity of units included in each pack or set for a `package` charge model. It indicates the number of units that are bundled together as a single package or set within the pricing structure.",
													},
													"per_transaction_max_amount": schema.StringAttribute{
														Optional:            true,
														Computed:            true,
														Description:         "Specifies the maximum allowable spending for a single transaction. Working as a transaction cap.",
														MarkdownDescription: "Specifies the maximum allowable spending for a single transaction. Working as a transaction cap.",
													},
													"per_transaction_min_amount": schema.StringAttribute{
														Optional:            true,
														Computed:            true,
														Description:         "Specifies the minimum allowable spending for a single transaction. Working as a transaction floor.",
														MarkdownDescription: "Specifies the minimum allowable spending for a single transaction. Working as a transaction floor.",
													},
													"rate": schema.StringAttribute{
														Optional:            true,
														Computed:            true,
														Description:         "The percentage rate that is applied to the amount of each transaction for a `percentage` charge model. It is expressed as a decimal value.",
														MarkdownDescription: "The percentage rate that is applied to the amount of each transaction for a `percentage` charge model. It is expressed as a decimal value.",
														Validators: []validator.String{
															stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
														},
													},
													"volume_ranges": schema.ListNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"flat_amount": schema.StringAttribute{
																	Required:            true,
																	Description:         "The unit price, excluding tax, for a specific tier of a `volume` charge model. It is expressed as a decimal value.",
																	MarkdownDescription: "The unit price, excluding tax, for a specific tier of a `volume` charge model. It is expressed as a decimal value.",
																	Validators: []validator.String{
																		stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																	},
																},
																"from_value": schema.Int64Attribute{
																	Required:            true,
																	Description:         "Specifies the lower value of a tier for a `volume` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																	MarkdownDescription: "Specifies the lower value of a tier for a `volume` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
																},
																"per_unit_amount": schema.StringAttribute{
																	Required:            true,
																	Description:         "The flat amount for a whole tier, excluding tax, for a `volume` charge model. It is expressed as a decimal value.",
																	MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `volume` charge model. It is expressed as a decimal value.",
																	Validators: []validator.String{
																		stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
																	},
																},
																"to_value": schema.Int64Attribute{
																	Required:            true,
																	Description:         "Specifies the highest value of a tier for a `volume` charge model.\n- This value must be higher than the `from_value` of the same tier.\n- This value must be `null` for the last tier.",
																	MarkdownDescription: "Specifies the highest value of a tier for a `volume` charge model.\n- This value must be higher than the `from_value` of the same tier.\n- This value must be `null` for the last tier.",
																},
															},
															CustomType: VolumeRangesType{
																ObjectType: types.ObjectType{
																	AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
																},
															},
														},
														Optional:            true,
														Computed:            true,
														Description:         "Volume ranges, sorted from bottom to top tiers, used for a `volume` charge model.",
														MarkdownDescription: "Volume ranges, sorted from bottom to top tiers, used for a `volume` charge model.",
													},
												},
												CustomType: PropertiesType{
													ObjectType: types.ObjectType{
														AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
													},
												},
												Optional: true,
												Computed: true,
											},
											"values": schema.MapAttribute{
												ElementType: types.ListType{
													ElemType: types.StringType,
												},
												Optional:            true,
												Computed:            true,
												Description:         "List of possible filter values. The key and values must match one of the billable metric filters.",
												MarkdownDescription: "List of possible filter values. The key and values must match one of the billable metric filters.",
											},
										},
										CustomType: FiltersType{
											ObjectType: types.ObjectType{
												AttrTypes: FiltersValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "List of filters used to apply differentiated pricing based on additional event properties.",
									MarkdownDescription: "List of filters used to apply differentiated pricing based on additional event properties.",
								},
								"invoice_display_name": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
									MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
								},
								"invoiceable": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "This field specifies whether the charge should be included in a proper invoice. If set to false, no invoice will be issued for this charge. You can only set it to `false` when `pay_in_advance` is `true`.",
									MarkdownDescription: "This field specifies whether the charge should be included in a proper invoice. If set to false, no invoice will be issued for this charge. You can only set it to `false` when `pay_in_advance` is `true`.",
								},
								"lago_billable_metric_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique identifier of the billable metric created by Lago.",
									MarkdownDescription: "Unique identifier of the billable metric created by Lago.",
								},
								"lago_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique identifier of charge, created by Lago.",
									MarkdownDescription: "Unique identifier of charge, created by Lago.",
								},
								"min_amount_cents": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "The minimum spending amount required for the charge, measured in cents and excluding any applicable taxes. It indicates the minimum amount that needs to be charged for each billing period.",
									MarkdownDescription: "The minimum spending amount required for the charge, measured in cents and excluding any applicable taxes. It indicates the minimum amount that needs to be charged for each billing period.",
								},
								"pay_in_advance": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "This field determines the billing timing for this specific usage-based charge. When set to `true`, the charge is due and invoiced immediately. Conversely, when set to false, the charge is due and invoiced at the end of each billing period.",
									MarkdownDescription: "This field determines the billing timing for this specific usage-based charge. When set to `true`, the charge is due and invoiced immediately. Conversely, when set to false, the charge is due and invoiced at the end of each billing period.",
								},
								"properties": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"amount": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "- The unit price, excluding tax, for a `standard` charge model. It is expressed as a decimal value.\n- The amount, excluding tax, for a complete set of units in a `package` charge model. It is expressed as a decimal value.",
											MarkdownDescription: "- The unit price, excluding tax, for a `standard` charge model. It is expressed as a decimal value.\n- The amount, excluding tax, for a complete set of units in a `package` charge model. It is expressed as a decimal value.",
											Validators: []validator.String{
												stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
											},
										},
										"fixed_amount": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "The fixed fee that is applied to each transaction for a `percentage` charge model. It is expressed as a decimal value.",
											MarkdownDescription: "The fixed fee that is applied to each transaction for a `percentage` charge model. It is expressed as a decimal value.",
											Validators: []validator.String{
												stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
											},
										},
										"free_units": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "The quantity of units that are provided free of charge for each billing period in a `package` charge model. This field specifies the number of units that customers can use without incurring any additional cost during each billing cycle.",
											MarkdownDescription: "The quantity of units that are provided free of charge for each billing period in a `package` charge model. This field specifies the number of units that customers can use without incurring any additional cost during each billing cycle.",
										},
										"free_units_per_events": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "The count of transactions that are not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the number of transactions that are exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
											MarkdownDescription: "The count of transactions that are not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the number of transactions that are exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
										},
										"free_units_per_total_aggregation": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "The transaction amount that is not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the portion of the transaction amount that is exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
											MarkdownDescription: "The transaction amount that is not impacted by the `percentage` rate and fixed fee in a percentage charge model. This field indicates the portion of the transaction amount that is exempt from the calculation of charges based on the specified percentage rate and fixed fee.",
											Validators: []validator.String{
												stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
											},
										},
										"graduated_percentage_ranges": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"flat_amount": schema.StringAttribute{
														Required:            true,
														Description:         "The flat amount for a whole tier, excluding tax, for a `graduated_percentage` charge model. It is expressed as a decimal value.",
														MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `graduated_percentage` charge model. It is expressed as a decimal value.",
													},
													"from_value": schema.Int64Attribute{
														Required:            true,
														Description:         "Specifies the lower value of a tier for a `graduated_percentage` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
														MarkdownDescription: "Specifies the lower value of a tier for a `graduated_percentage` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
													},
													"rate": schema.StringAttribute{
														Required:            true,
														Description:         "The percentage rate that is applied to the amount of each transaction in the tier for a `graduated_percentage` charge model. It is expressed as a decimal value.",
														MarkdownDescription: "The percentage rate that is applied to the amount of each transaction in the tier for a `graduated_percentage` charge model. It is expressed as a decimal value.",
													},
													"to_value": schema.Int64Attribute{
														Required:            true,
														Description:         "Specifies the highest value of a tier for a `graduated_percentage` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
														MarkdownDescription: "Specifies the highest value of a tier for a `graduated_percentage` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
													},
												},
												CustomType: GraduatedPercentageRangesType{
													ObjectType: types.ObjectType{
														AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Computed:            true,
											Description:         "Graduated percentage ranges, sorted from bottom to top tiers, used for a `graduated_percentage` charge model.",
											MarkdownDescription: "Graduated percentage ranges, sorted from bottom to top tiers, used for a `graduated_percentage` charge model.",
										},
										"graduated_ranges": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"flat_amount": schema.StringAttribute{
														Required:            true,
														Description:         "The flat amount for a whole tier, excluding tax, for a `graduated` charge model. It is expressed as a decimal value.",
														MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `graduated` charge model. It is expressed as a decimal value.",
														Validators: []validator.String{
															stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
														},
													},
													"from_value": schema.Int64Attribute{
														Required:            true,
														Description:         "Specifies the lower value of a tier for a `graduated` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
														MarkdownDescription: "Specifies the lower value of a tier for a `graduated` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
													},
													"per_unit_amount": schema.StringAttribute{
														Required:            true,
														Description:         "The unit price, excluding tax, for a specific tier of a `graduated` charge model. It is expressed as a decimal value.",
														MarkdownDescription: "The unit price, excluding tax, for a specific tier of a `graduated` charge model. It is expressed as a decimal value.",
														Validators: []validator.String{
															stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
														},
													},
													"to_value": schema.Int64Attribute{
														Required:            true,
														Description:         "Specifies the highest value of a tier for a `graduated` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
														MarkdownDescription: "Specifies the highest value of a tier for a `graduated` charge model.\n- This value must be higher than the from_value of the same tier.\n- This value must be null for the last tier.",
													},
												},
												CustomType: GraduatedRangesType{
													ObjectType: types.ObjectType{
														AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Computed:            true,
											Description:         "Graduated ranges, sorted from bottom to top tiers, used for a `graduated` charge model.",
											MarkdownDescription: "Graduated ranges, sorted from bottom to top tiers, used for a `graduated` charge model.",
										},
										"grouped_by": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Computed:            true,
											Description:         "The list of event properties that are used to group the events on the invoice for a `standard` charge model.",
											MarkdownDescription: "The list of event properties that are used to group the events on the invoice for a `standard` charge model.",
										},
										"package_size": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "The quantity of units included in each pack or set for a `package` charge model. It indicates the number of units that are bundled together as a single package or set within the pricing structure.",
											MarkdownDescription: "The quantity of units included in each pack or set for a `package` charge model. It indicates the number of units that are bundled together as a single package or set within the pricing structure.",
										},
										"per_transaction_max_amount": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "Specifies the maximum allowable spending for a single transaction. Working as a transaction cap.",
											MarkdownDescription: "Specifies the maximum allowable spending for a single transaction. Working as a transaction cap.",
										},
										"per_transaction_min_amount": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "Specifies the minimum allowable spending for a single transaction. Working as a transaction floor.",
											MarkdownDescription: "Specifies the minimum allowable spending for a single transaction. Working as a transaction floor.",
										},
										"rate": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "The percentage rate that is applied to the amount of each transaction for a `percentage` charge model. It is expressed as a decimal value.",
											MarkdownDescription: "The percentage rate that is applied to the amount of each transaction for a `percentage` charge model. It is expressed as a decimal value.",
											Validators: []validator.String{
												stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
											},
										},
										"volume_ranges": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"flat_amount": schema.StringAttribute{
														Required:            true,
														Description:         "The unit price, excluding tax, for a specific tier of a `volume` charge model. It is expressed as a decimal value.",
														MarkdownDescription: "The unit price, excluding tax, for a specific tier of a `volume` charge model. It is expressed as a decimal value.",
														Validators: []validator.String{
															stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
														},
													},
													"from_value": schema.Int64Attribute{
														Required:            true,
														Description:         "Specifies the lower value of a tier for a `volume` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
														MarkdownDescription: "Specifies the lower value of a tier for a `volume` charge model. It must be either 0 or the previous range's `to_value + 1` to maintain the proper sequence of values.",
													},
													"per_unit_amount": schema.StringAttribute{
														Required:            true,
														Description:         "The flat amount for a whole tier, excluding tax, for a `volume` charge model. It is expressed as a decimal value.",
														MarkdownDescription: "The flat amount for a whole tier, excluding tax, for a `volume` charge model. It is expressed as a decimal value.",
														Validators: []validator.String{
															stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]+.?[0-9]*$"), ""),
														},
													},
													"to_value": schema.Int64Attribute{
														Required:            true,
														Description:         "Specifies the highest value of a tier for a `volume` charge model.\n- This value must be higher than the `from_value` of the same tier.\n- This value must be `null` for the last tier.",
														MarkdownDescription: "Specifies the highest value of a tier for a `volume` charge model.\n- This value must be higher than the `from_value` of the same tier.\n- This value must be `null` for the last tier.",
													},
												},
												CustomType: VolumeRangesType{
													ObjectType: types.ObjectType{
														AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Computed:            true,
											Description:         "Volume ranges, sorted from bottom to top tiers, used for a `volume` charge model.",
											MarkdownDescription: "Volume ranges, sorted from bottom to top tiers, used for a `volume` charge model.",
										},
									},
									CustomType: PropertiesType{
										ObjectType: types.ObjectType{
											AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
									Computed: true,
								},
								"prorated": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Specifies whether a charge is prorated based on the remaining number of days in the billing period or billed fully.\n\n- If set to `true`, the charge is prorated based on the remaining days in the current billing period.\n- If set to `false`, the charge is billed in full.\n- If not defined in the request, default value is `false`.",
									MarkdownDescription: "Specifies whether a charge is prorated based on the remaining number of days in the billing period or billed fully.\n\n- If set to `true`, the charge is prorated based on the remaining days in the current billing period.\n- If set to `false`, the charge is billed in full.\n- If not defined in the request, default value is `false`.",
								},
								"regroup_paid_fees": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "This setting can only be configured if `pay_in_advance` is `true` and `invoiceable` is `false`.\nThis field determines whether and when the charge fee should be included in\nthe invoice. If `null`, no invoice will be issued for this charge fee.\nIf `invoice`, an invoice will be generated at the end of the period,\nconsolidating all charge fees with a succeeded payment status.",
									MarkdownDescription: "This setting can only be configured if `pay_in_advance` is `true` and `invoiceable` is `false`.\nThis field determines whether and when the charge fee should be included in\nthe invoice. If `null`, no invoice will be issued for this charge fee.\nIf `invoice`, an invoice will be generated at the end of the period,\nconsolidating all charge fees with a succeeded payment status.",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"invoice",
										),
									},
								},
								"tax_codes": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "List of unique code used to identify the taxes.",
									MarkdownDescription: "List of unique code used to identify the taxes.",
								},
								"taxes": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"applied_to_organization": schema.BoolAttribute{
												Computed:            true,
												Description:         "Set to `true` if the tax is used as one of the organization's default",
												MarkdownDescription: "Set to `true` if the tax is used as one of the organization's default",
											},
											"code": schema.StringAttribute{
												Computed:            true,
												Description:         "Unique code used to identify the tax associated with the API request.",
												MarkdownDescription: "Unique code used to identify the tax associated with the API request.",
											},
											"created_at": schema.StringAttribute{
												Computed:            true,
												Description:         "Creation date of the tax.",
												MarkdownDescription: "Creation date of the tax.",
											},
											"description": schema.StringAttribute{
												Computed:            true,
												Description:         "Internal description of the taxe",
												MarkdownDescription: "Internal description of the taxe",
											},
											"lago_id": schema.StringAttribute{
												Computed:            true,
												Description:         "Unique identifier of the tax, created by Lago.",
												MarkdownDescription: "Unique identifier of the tax, created by Lago.",
											},
											"name": schema.StringAttribute{
												Computed:            true,
												Description:         "Name of the tax.",
												MarkdownDescription: "Name of the tax.",
											},
											"rate": schema.NumberAttribute{
												Computed:            true,
												Description:         "The percentage rate of the tax",
												MarkdownDescription: "The percentage rate of the tax",
											},
										},
										CustomType: TaxesType{
											ObjectType: types.ObjectType{
												AttrTypes: TaxesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "All taxes applied to the charge.",
									MarkdownDescription: "All taxes applied to the charge.",
								},
							},
							CustomType: ChargesType{
								ObjectType: types.ObjectType{
									AttrTypes: ChargesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Additional usage-based charges for this plan.",
						MarkdownDescription: "Additional usage-based charges for this plan.",
					},
					"code": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The code of the plan. It serves as a unique identifier associated with a particular plan. The code is typically used for internal or system-level identification purposes, like assigning a subscription, for instance.",
						MarkdownDescription: "The code of the plan. It serves as a unique identifier associated with a particular plan. The code is typically used for internal or system-level identification purposes, like assigning a subscription, for instance.",
					},
					"created_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date and time when the plan was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the plan was initially created.",
						MarkdownDescription: "The date and time when the plan was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the plan was initially created.",
					},
					"description": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The description on the plan.",
						MarkdownDescription: "The description on the plan.",
					},
					"interval": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The interval used for recurring billing. It represents the frequency at which subscription billing occurs. The interval can be one of the following values: `yearly`, `quarterly`, `monthly`, or `weekly`.",
						MarkdownDescription: "The interval used for recurring billing. It represents the frequency at which subscription billing occurs. The interval can be one of the following values: `yearly`, `quarterly`, `monthly`, or `weekly`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"weekly",
								"monthly",
								"quarterly",
								"yearly",
							),
						},
					},
					"invoice_display_name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the plan will be used as the default display name.",
						MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the plan will be used as the default display name.",
					},
					"lago_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier of the plan created by Lago.",
						MarkdownDescription: "Unique identifier of the plan created by Lago.",
					},
					"minimum_commitment": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"amount_cents": schema.Int64Attribute{
								Required:            true,
								Description:         "The amount of the minimum commitment in cents.",
								MarkdownDescription: "The amount of the minimum commitment in cents.",
							},
							"created_at": schema.StringAttribute{
								Computed:            true,
								Description:         "The date and time when the minimum commitment was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the minimum commitment was initially created.",
								MarkdownDescription: "The date and time when the minimum commitment was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the minimum commitment was initially created.",
							},
							"interval": schema.StringAttribute{
								Computed:            true,
								Description:         "The interval used for recurring billing. It represents the frequency at which subscription billing occurs. The interval can be one of the following values: `yearly`, `quarterly`, `monthly` or `weekly`.",
								MarkdownDescription: "The interval used for recurring billing. It represents the frequency at which subscription billing occurs. The interval can be one of the following values: `yearly`, `quarterly`, `monthly` or `weekly`.",
							},
							"invoice_display_name": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the default name will be used as the display name.",
								MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the default name will be used as the display name.",
							},
							"lago_id": schema.StringAttribute{
								Computed:            true,
								Description:         "Unique identifier of the minimum commitment, created by Lago.",
								MarkdownDescription: "Unique identifier of the minimum commitment, created by Lago.",
							},
							"plan_code": schema.StringAttribute{
								Computed:            true,
								Description:         "The unique code representing the plan to be attached to the customer.",
								MarkdownDescription: "The unique code representing the plan to be attached to the customer.",
							},
							"tax_codes": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "List of unique code used to identify the taxes.",
								MarkdownDescription: "List of unique code used to identify the taxes.",
							},
							"taxes": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"applied_to_organization": schema.BoolAttribute{
											Computed:            true,
											Description:         "Set to `true` if the tax is used as one of the organization's default",
											MarkdownDescription: "Set to `true` if the tax is used as one of the organization's default",
										},
										"code": schema.StringAttribute{
											Computed:            true,
											Description:         "Unique code used to identify the tax associated with the API request.",
											MarkdownDescription: "Unique code used to identify the tax associated with the API request.",
										},
										"created_at": schema.StringAttribute{
											Computed:            true,
											Description:         "Creation date of the tax.",
											MarkdownDescription: "Creation date of the tax.",
										},
										"description": schema.StringAttribute{
											Computed:            true,
											Description:         "Internal description of the taxe",
											MarkdownDescription: "Internal description of the taxe",
										},
										"lago_id": schema.StringAttribute{
											Computed:            true,
											Description:         "Unique identifier of the tax, created by Lago.",
											MarkdownDescription: "Unique identifier of the tax, created by Lago.",
										},
										"name": schema.StringAttribute{
											Computed:            true,
											Description:         "Name of the tax.",
											MarkdownDescription: "Name of the tax.",
										},
										"rate": schema.NumberAttribute{
											Computed:            true,
											Description:         "The percentage rate of the tax",
											MarkdownDescription: "The percentage rate of the tax",
										},
									},
									CustomType: TaxesType{
										ObjectType: types.ObjectType{
											AttrTypes: TaxesValue{}.AttributeTypes(ctx),
										},
									},
								},
								Computed:            true,
								Description:         "All taxes applied to the minimum commitment.",
								MarkdownDescription: "All taxes applied to the minimum commitment.",
							},
							"updated_at": schema.StringAttribute{
								Computed:            true,
								Description:         "The date and time when the minimum commitment was updated. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the minimum commitment was initially created.",
								MarkdownDescription: "The date and time when the minimum commitment was updated. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the minimum commitment was initially created.",
							},
						},
						CustomType: MinimumCommitmentType{
							ObjectType: types.ObjectType{
								AttrTypes: MinimumCommitmentValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Minimum commitment for this plan.",
						MarkdownDescription: "Minimum commitment for this plan.",
					},
					"name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The name of the plan.",
						MarkdownDescription: "The name of the plan.",
					},
					"pay_in_advance": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "This field determines the billing timing for the plan. When set to `true`, the base cost of the plan is due at the beginning of each billing period. Conversely, when set to `false`, the base cost of the plan is due at the end of each billing period.",
						MarkdownDescription: "This field determines the billing timing for the plan. When set to `true`, the base cost of the plan is due at the beginning of each billing period. Conversely, when set to `false`, the base cost of the plan is due at the end of each billing period.",
					},
					"tax_codes": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "List of unique code used to identify the taxes.",
						MarkdownDescription: "List of unique code used to identify the taxes.",
					},
					"taxes": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"applied_to_organization": schema.BoolAttribute{
									Computed:            true,
									Description:         "Set to `true` if the tax is used as one of the organization's default",
									MarkdownDescription: "Set to `true` if the tax is used as one of the organization's default",
								},
								"code": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique code used to identify the tax associated with the API request.",
									MarkdownDescription: "Unique code used to identify the tax associated with the API request.",
								},
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "Creation date of the tax.",
									MarkdownDescription: "Creation date of the tax.",
								},
								"description": schema.StringAttribute{
									Computed:            true,
									Description:         "Internal description of the taxe",
									MarkdownDescription: "Internal description of the taxe",
								},
								"lago_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique identifier of the tax, created by Lago.",
									MarkdownDescription: "Unique identifier of the tax, created by Lago.",
								},
								"name": schema.StringAttribute{
									Computed:            true,
									Description:         "Name of the tax.",
									MarkdownDescription: "Name of the tax.",
								},
								"rate": schema.NumberAttribute{
									Computed:            true,
									Description:         "The percentage rate of the tax",
									MarkdownDescription: "The percentage rate of the tax",
								},
							},
							CustomType: TaxesType{
								ObjectType: types.ObjectType{
									AttrTypes: TaxesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "All taxes applied to the plan.",
						MarkdownDescription: "All taxes applied to the plan.",
					},
					"trial_period": schema.NumberAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The duration in days during which the base cost of the plan is offered for free.",
						MarkdownDescription: "The duration in days during which the base cost of the plan is offered for free.",
					},
					"usage_thresholds": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"amount_cents": schema.Int64Attribute{
									Required:            true,
									Description:         "The amount to reach to trigger a `progressive_billing` invoice.",
									MarkdownDescription: "The amount to reach to trigger a `progressive_billing` invoice.",
								},
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The date and time when the usage threshold was created. It is expressed in UTC format according to the ISO 8601 datetime standard.",
									MarkdownDescription: "The date and time when the usage threshold was created. It is expressed in UTC format according to the ISO 8601 datetime standard.",
								},
								"id": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Unique identifier of the usage threshold created by Lago.",
									MarkdownDescription: "Unique identifier of the usage threshold created by Lago.",
								},
								"lago_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique identifier of the usage threshold created by Lago.",
									MarkdownDescription: "Unique identifier of the usage threshold created by Lago.",
								},
								"recurring": schema.BoolAttribute{
									Required:            true,
									Description:         "This field when set to `true` indicates that a `progressive_billing` invoice will be created every time the lifetime usage increases by the specified amount.",
									MarkdownDescription: "This field when set to `true` indicates that a `progressive_billing` invoice will be created every time the lifetime usage increases by the specified amount.",
								},
								"threshold_display_name": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The display name of the usage threshold.",
									MarkdownDescription: "The display name of the usage threshold.",
								},
								"updated_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The date and time when the usage threshold was last updated. It is expressed in UTC format according to the ISO 8601 datetime standard.",
									MarkdownDescription: "The date and time when the usage threshold was last updated. It is expressed in UTC format according to the ISO 8601 datetime standard.",
								},
							},
							CustomType: UsageThresholdsType{
								ObjectType: types.ObjectType{
									AttrTypes: UsageThresholdsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "List of usage thresholds to apply to the plan.",
						MarkdownDescription: "List of usage thresholds to apply to the plan.",
					},
				},
				CustomType: PlanType{
					ObjectType: types.ObjectType{
						AttrTypes: PlanValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
		},
	}
}

type PlansModel struct {
	Code types.String `tfsdk:"code"`
	Plan PlanValue    `tfsdk:"plan"`
}

var _ basetypes.ObjectTypable = PlanType{}

type PlanType struct {
	basetypes.ObjectType
}

func (t PlanType) Equal(o attr.Type) bool {
	other, ok := o.(PlanType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PlanType) String() string {
	return "PlanType"
}

func (t PlanType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return nil, diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	billChargesMonthlyAttribute, ok := attributes["bill_charges_monthly"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bill_charges_monthly is missing from object`)

		return nil, diags
	}

	billChargesMonthlyVal, ok := billChargesMonthlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bill_charges_monthly expected to be basetypes.BoolValue, was: %T`, billChargesMonthlyAttribute))
	}

	chargesAttribute, ok := attributes["charges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`charges is missing from object`)

		return nil, diags
	}

	chargesVal, ok := chargesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`charges expected to be basetypes.ListValue, was: %T`, chargesAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return nil, diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	minimumCommitmentAttribute, ok := attributes["minimum_commitment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_commitment is missing from object`)

		return nil, diags
	}

	minimumCommitmentVal, ok := minimumCommitmentAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_commitment expected to be basetypes.ObjectValue, was: %T`, minimumCommitmentAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	payInAdvanceAttribute, ok := attributes["pay_in_advance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pay_in_advance is missing from object`)

		return nil, diags
	}

	payInAdvanceVal, ok := payInAdvanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pay_in_advance expected to be basetypes.BoolValue, was: %T`, payInAdvanceAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return nil, diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	taxesAttribute, ok := attributes["taxes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes is missing from object`)

		return nil, diags
	}

	taxesVal, ok := taxesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes expected to be basetypes.ListValue, was: %T`, taxesAttribute))
	}

	trialPeriodAttribute, ok := attributes["trial_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trial_period is missing from object`)

		return nil, diags
	}

	trialPeriodVal, ok := trialPeriodAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trial_period expected to be basetypes.NumberValue, was: %T`, trialPeriodAttribute))
	}

	usageThresholdsAttribute, ok := attributes["usage_thresholds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage_thresholds is missing from object`)

		return nil, diags
	}

	usageThresholdsVal, ok := usageThresholdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage_thresholds expected to be basetypes.ListValue, was: %T`, usageThresholdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PlanValue{
		AmountCents:        amountCentsVal,
		AmountCurrency:     amountCurrencyVal,
		BillChargesMonthly: billChargesMonthlyVal,
		Charges:            chargesVal,
		Code:               codeVal,
		CreatedAt:          createdAtVal,
		Description:        descriptionVal,
		Interval:           intervalVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		LagoId:             lagoIdVal,
		MinimumCommitment:  minimumCommitmentVal,
		Name:               nameVal,
		PayInAdvance:       payInAdvanceVal,
		TaxCodes:           taxCodesVal,
		Taxes:              taxesVal,
		TrialPeriod:        trialPeriodVal,
		UsageThresholds:    usageThresholdsVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPlanValueNull() PlanValue {
	return PlanValue{
		state: attr.ValueStateNull,
	}
}

func NewPlanValueUnknown() PlanValue {
	return PlanValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPlanValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PlanValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PlanValue Attribute Value",
				"While creating a PlanValue value, a missing attribute value was detected. "+
					"A PlanValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PlanValue Attribute Type",
				"While creating a PlanValue value, an invalid attribute value was detected. "+
					"A PlanValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlanValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PlanValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PlanValue Attribute Value",
				"While creating a PlanValue value, an extra attribute value was detected. "+
					"A PlanValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PlanValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlanValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	billChargesMonthlyAttribute, ok := attributes["bill_charges_monthly"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bill_charges_monthly is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	billChargesMonthlyVal, ok := billChargesMonthlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bill_charges_monthly expected to be basetypes.BoolValue, was: %T`, billChargesMonthlyAttribute))
	}

	chargesAttribute, ok := attributes["charges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`charges is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	chargesVal, ok := chargesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`charges expected to be basetypes.ListValue, was: %T`, chargesAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	minimumCommitmentAttribute, ok := attributes["minimum_commitment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_commitment is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	minimumCommitmentVal, ok := minimumCommitmentAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_commitment expected to be basetypes.ObjectValue, was: %T`, minimumCommitmentAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	payInAdvanceAttribute, ok := attributes["pay_in_advance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pay_in_advance is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	payInAdvanceVal, ok := payInAdvanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pay_in_advance expected to be basetypes.BoolValue, was: %T`, payInAdvanceAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	taxesAttribute, ok := attributes["taxes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	taxesVal, ok := taxesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes expected to be basetypes.ListValue, was: %T`, taxesAttribute))
	}

	trialPeriodAttribute, ok := attributes["trial_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trial_period is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	trialPeriodVal, ok := trialPeriodAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trial_period expected to be basetypes.NumberValue, was: %T`, trialPeriodAttribute))
	}

	usageThresholdsAttribute, ok := attributes["usage_thresholds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage_thresholds is missing from object`)

		return NewPlanValueUnknown(), diags
	}

	usageThresholdsVal, ok := usageThresholdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage_thresholds expected to be basetypes.ListValue, was: %T`, usageThresholdsAttribute))
	}

	if diags.HasError() {
		return NewPlanValueUnknown(), diags
	}

	return PlanValue{
		AmountCents:        amountCentsVal,
		AmountCurrency:     amountCurrencyVal,
		BillChargesMonthly: billChargesMonthlyVal,
		Charges:            chargesVal,
		Code:               codeVal,
		CreatedAt:          createdAtVal,
		Description:        descriptionVal,
		Interval:           intervalVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		LagoId:             lagoIdVal,
		MinimumCommitment:  minimumCommitmentVal,
		Name:               nameVal,
		PayInAdvance:       payInAdvanceVal,
		TaxCodes:           taxCodesVal,
		Taxes:              taxesVal,
		TrialPeriod:        trialPeriodVal,
		UsageThresholds:    usageThresholdsVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPlanValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PlanValue {
	object, diags := NewPlanValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlanValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PlanType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlanValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlanValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlanValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlanValueMust(PlanValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PlanType) ValueType(ctx context.Context) attr.Value {
	return PlanValue{}
}

var _ basetypes.ObjectValuable = PlanValue{}

type PlanValue struct {
	AmountCents        basetypes.Int64Value  `tfsdk:"amount_cents"`
	AmountCurrency     basetypes.StringValue `tfsdk:"amount_currency"`
	BillChargesMonthly basetypes.BoolValue   `tfsdk:"bill_charges_monthly"`
	Charges            basetypes.ListValue   `tfsdk:"charges"`
	Code               basetypes.StringValue `tfsdk:"code"`
	CreatedAt          basetypes.StringValue `tfsdk:"created_at"`
	Description        basetypes.StringValue `tfsdk:"description"`
	Interval           basetypes.StringValue `tfsdk:"interval"`
	InvoiceDisplayName basetypes.StringValue `tfsdk:"invoice_display_name"`
	LagoId             basetypes.StringValue `tfsdk:"lago_id"`
	MinimumCommitment  basetypes.ObjectValue `tfsdk:"minimum_commitment"`
	Name               basetypes.StringValue `tfsdk:"name"`
	PayInAdvance       basetypes.BoolValue   `tfsdk:"pay_in_advance"`
	TaxCodes           basetypes.ListValue   `tfsdk:"tax_codes"`
	Taxes              basetypes.ListValue   `tfsdk:"taxes"`
	TrialPeriod        basetypes.NumberValue `tfsdk:"trial_period"`
	UsageThresholds    basetypes.ListValue   `tfsdk:"usage_thresholds"`
	state              attr.ValueState
}

func (v PlanValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["amount_currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bill_charges_monthly"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["charges"] = basetypes.ListType{
		ElemType: ChargesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interval"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["minimum_commitment"] = basetypes.ObjectType{
		AttrTypes: MinimumCommitmentValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pay_in_advance"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["tax_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["taxes"] = basetypes.ListType{
		ElemType: TaxesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["trial_period"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["usage_thresholds"] = basetypes.ListType{
		ElemType: UsageThresholdsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.AmountCurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_currency"] = val

		val, err = v.BillChargesMonthly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bill_charges_monthly"] = val

		val, err = v.Charges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["charges"] = val

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Interval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interval"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.MinimumCommitment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimum_commitment"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PayInAdvance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pay_in_advance"] = val

		val, err = v.TaxCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_codes"] = val

		val, err = v.Taxes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taxes"] = val

		val, err = v.TrialPeriod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trial_period"] = val

		val, err = v.UsageThresholds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage_thresholds"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PlanValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PlanValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PlanValue) String() string {
	return "PlanValue"
}

func (v PlanValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	charges := types.ListValueMust(
		ChargesType{
			basetypes.ObjectType{
				AttrTypes: ChargesValue{}.AttributeTypes(ctx),
			},
		},
		v.Charges.Elements(),
	)

	if v.Charges.IsNull() {
		charges = types.ListNull(
			ChargesType{
				basetypes.ObjectType{
					AttrTypes: ChargesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Charges.IsUnknown() {
		charges = types.ListUnknown(
			ChargesType{
				basetypes.ObjectType{
					AttrTypes: ChargesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var minimumCommitment basetypes.ObjectValue

	if v.MinimumCommitment.IsNull() {
		minimumCommitment = types.ObjectNull(
			MinimumCommitmentValue{}.AttributeTypes(ctx),
		)
	}

	if v.MinimumCommitment.IsUnknown() {
		minimumCommitment = types.ObjectUnknown(
			MinimumCommitmentValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MinimumCommitment.IsNull() && !v.MinimumCommitment.IsUnknown() {
		minimumCommitment = types.ObjectValueMust(
			MinimumCommitmentValue{}.AttributeTypes(ctx),
			v.MinimumCommitment.Attributes(),
		)
	}

	taxes := types.ListValueMust(
		TaxesType{
			basetypes.ObjectType{
				AttrTypes: TaxesValue{}.AttributeTypes(ctx),
			},
		},
		v.Taxes.Elements(),
	)

	if v.Taxes.IsNull() {
		taxes = types.ListNull(
			TaxesType{
				basetypes.ObjectType{
					AttrTypes: TaxesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Taxes.IsUnknown() {
		taxes = types.ListUnknown(
			TaxesType{
				basetypes.ObjectType{
					AttrTypes: TaxesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	usageThresholds := types.ListValueMust(
		UsageThresholdsType{
			basetypes.ObjectType{
				AttrTypes: UsageThresholdsValue{}.AttributeTypes(ctx),
			},
		},
		v.UsageThresholds.Elements(),
	)

	if v.UsageThresholds.IsNull() {
		usageThresholds = types.ListNull(
			UsageThresholdsType{
				basetypes.ObjectType{
					AttrTypes: UsageThresholdsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.UsageThresholds.IsUnknown() {
		usageThresholds = types.ListUnknown(
			UsageThresholdsType{
				basetypes.ObjectType{
					AttrTypes: UsageThresholdsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var taxCodesVal basetypes.ListValue
	switch {
	case v.TaxCodes.IsUnknown():
		taxCodesVal = types.ListUnknown(types.StringType)
	case v.TaxCodes.IsNull():
		taxCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		taxCodesVal, d = types.ListValue(types.StringType, v.TaxCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount_cents":         basetypes.Int64Type{},
			"amount_currency":      basetypes.StringType{},
			"bill_charges_monthly": basetypes.BoolType{},
			"charges": basetypes.ListType{
				ElemType: ChargesValue{}.Type(ctx),
			},
			"code":                 basetypes.StringType{},
			"created_at":           basetypes.StringType{},
			"description":          basetypes.StringType{},
			"interval":             basetypes.StringType{},
			"invoice_display_name": basetypes.StringType{},
			"lago_id":              basetypes.StringType{},
			"minimum_commitment": basetypes.ObjectType{
				AttrTypes: MinimumCommitmentValue{}.AttributeTypes(ctx),
			},
			"name":           basetypes.StringType{},
			"pay_in_advance": basetypes.BoolType{},
			"tax_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"taxes": basetypes.ListType{
				ElemType: TaxesValue{}.Type(ctx),
			},
			"trial_period": basetypes.NumberType{},
			"usage_thresholds": basetypes.ListType{
				ElemType: UsageThresholdsValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":         basetypes.Int64Type{},
		"amount_currency":      basetypes.StringType{},
		"bill_charges_monthly": basetypes.BoolType{},
		"charges": basetypes.ListType{
			ElemType: ChargesValue{}.Type(ctx),
		},
		"code":                 basetypes.StringType{},
		"created_at":           basetypes.StringType{},
		"description":          basetypes.StringType{},
		"interval":             basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"lago_id":              basetypes.StringType{},
		"minimum_commitment": basetypes.ObjectType{
			AttrTypes: MinimumCommitmentValue{}.AttributeTypes(ctx),
		},
		"name":           basetypes.StringType{},
		"pay_in_advance": basetypes.BoolType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"taxes": basetypes.ListType{
			ElemType: TaxesValue{}.Type(ctx),
		},
		"trial_period": basetypes.NumberType{},
		"usage_thresholds": basetypes.ListType{
			ElemType: UsageThresholdsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":         v.AmountCents,
			"amount_currency":      v.AmountCurrency,
			"bill_charges_monthly": v.BillChargesMonthly,
			"charges":              charges,
			"code":                 v.Code,
			"created_at":           v.CreatedAt,
			"description":          v.Description,
			"interval":             v.Interval,
			"invoice_display_name": v.InvoiceDisplayName,
			"lago_id":              v.LagoId,
			"minimum_commitment":   minimumCommitment,
			"name":                 v.Name,
			"pay_in_advance":       v.PayInAdvance,
			"tax_codes":            taxCodesVal,
			"taxes":                taxes,
			"trial_period":         v.TrialPeriod,
			"usage_thresholds":     usageThresholds,
		})

	return objVal, diags
}

func (v PlanValue) Equal(o attr.Value) bool {
	other, ok := o.(PlanValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.AmountCurrency.Equal(other.AmountCurrency) {
		return false
	}

	if !v.BillChargesMonthly.Equal(other.BillChargesMonthly) {
		return false
	}

	if !v.Charges.Equal(other.Charges) {
		return false
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Interval.Equal(other.Interval) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.MinimumCommitment.Equal(other.MinimumCommitment) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PayInAdvance.Equal(other.PayInAdvance) {
		return false
	}

	if !v.TaxCodes.Equal(other.TaxCodes) {
		return false
	}

	if !v.Taxes.Equal(other.Taxes) {
		return false
	}

	if !v.TrialPeriod.Equal(other.TrialPeriod) {
		return false
	}

	if !v.UsageThresholds.Equal(other.UsageThresholds) {
		return false
	}

	return true
}

func (v PlanValue) Type(ctx context.Context) attr.Type {
	return PlanType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PlanValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":         basetypes.Int64Type{},
		"amount_currency":      basetypes.StringType{},
		"bill_charges_monthly": basetypes.BoolType{},
		"charges": basetypes.ListType{
			ElemType: ChargesValue{}.Type(ctx),
		},
		"code":                 basetypes.StringType{},
		"created_at":           basetypes.StringType{},
		"description":          basetypes.StringType{},
		"interval":             basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"lago_id":              basetypes.StringType{},
		"minimum_commitment": basetypes.ObjectType{
			AttrTypes: MinimumCommitmentValue{}.AttributeTypes(ctx),
		},
		"name":           basetypes.StringType{},
		"pay_in_advance": basetypes.BoolType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"taxes": basetypes.ListType{
			ElemType: TaxesValue{}.Type(ctx),
		},
		"trial_period": basetypes.NumberType{},
		"usage_thresholds": basetypes.ListType{
			ElemType: UsageThresholdsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ChargesType{}

type ChargesType struct {
	basetypes.ObjectType
}

func (t ChargesType) Equal(o attr.Type) bool {
	other, ok := o.(ChargesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ChargesType) String() string {
	return "ChargesType"
}

func (t ChargesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	billableMetricCodeAttribute, ok := attributes["billable_metric_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable_metric_code is missing from object`)

		return nil, diags
	}

	billableMetricCodeVal, ok := billableMetricCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable_metric_code expected to be basetypes.StringValue, was: %T`, billableMetricCodeAttribute))
	}

	billableMetricIdAttribute, ok := attributes["billable_metric_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable_metric_id is missing from object`)

		return nil, diags
	}

	billableMetricIdVal, ok := billableMetricIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable_metric_id expected to be basetypes.StringValue, was: %T`, billableMetricIdAttribute))
	}

	chargeModelAttribute, ok := attributes["charge_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`charge_model is missing from object`)

		return nil, diags
	}

	chargeModelVal, ok := chargeModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`charge_model expected to be basetypes.StringValue, was: %T`, chargeModelAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	invoiceableAttribute, ok := attributes["invoiceable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoiceable is missing from object`)

		return nil, diags
	}

	invoiceableVal, ok := invoiceableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoiceable expected to be basetypes.BoolValue, was: %T`, invoiceableAttribute))
	}

	lagoBillableMetricIdAttribute, ok := attributes["lago_billable_metric_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_billable_metric_id is missing from object`)

		return nil, diags
	}

	lagoBillableMetricIdVal, ok := lagoBillableMetricIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_billable_metric_id expected to be basetypes.StringValue, was: %T`, lagoBillableMetricIdAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	minAmountCentsAttribute, ok := attributes["min_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_amount_cents is missing from object`)

		return nil, diags
	}

	minAmountCentsVal, ok := minAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_amount_cents expected to be basetypes.Int64Value, was: %T`, minAmountCentsAttribute))
	}

	payInAdvanceAttribute, ok := attributes["pay_in_advance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pay_in_advance is missing from object`)

		return nil, diags
	}

	payInAdvanceVal, ok := payInAdvanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pay_in_advance expected to be basetypes.BoolValue, was: %T`, payInAdvanceAttribute))
	}

	propertiesAttribute, ok := attributes["properties"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`properties is missing from object`)

		return nil, diags
	}

	propertiesVal, ok := propertiesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`properties expected to be basetypes.ObjectValue, was: %T`, propertiesAttribute))
	}

	proratedAttribute, ok := attributes["prorated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prorated is missing from object`)

		return nil, diags
	}

	proratedVal, ok := proratedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prorated expected to be basetypes.BoolValue, was: %T`, proratedAttribute))
	}

	regroupPaidFeesAttribute, ok := attributes["regroup_paid_fees"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regroup_paid_fees is missing from object`)

		return nil, diags
	}

	regroupPaidFeesVal, ok := regroupPaidFeesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regroup_paid_fees expected to be basetypes.StringValue, was: %T`, regroupPaidFeesAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return nil, diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	taxesAttribute, ok := attributes["taxes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes is missing from object`)

		return nil, diags
	}

	taxesVal, ok := taxesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes expected to be basetypes.ListValue, was: %T`, taxesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ChargesValue{
		BillableMetricCode:   billableMetricCodeVal,
		BillableMetricId:     billableMetricIdVal,
		ChargeModel:          chargeModelVal,
		CreatedAt:            createdAtVal,
		Filters:              filtersVal,
		InvoiceDisplayName:   invoiceDisplayNameVal,
		Invoiceable:          invoiceableVal,
		LagoBillableMetricId: lagoBillableMetricIdVal,
		LagoId:               lagoIdVal,
		MinAmountCents:       minAmountCentsVal,
		PayInAdvance:         payInAdvanceVal,
		Properties:           propertiesVal,
		Prorated:             proratedVal,
		RegroupPaidFees:      regroupPaidFeesVal,
		TaxCodes:             taxCodesVal,
		Taxes:                taxesVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewChargesValueNull() ChargesValue {
	return ChargesValue{
		state: attr.ValueStateNull,
	}
}

func NewChargesValueUnknown() ChargesValue {
	return ChargesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewChargesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ChargesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ChargesValue Attribute Value",
				"While creating a ChargesValue value, a missing attribute value was detected. "+
					"A ChargesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChargesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ChargesValue Attribute Type",
				"While creating a ChargesValue value, an invalid attribute value was detected. "+
					"A ChargesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChargesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ChargesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ChargesValue Attribute Value",
				"While creating a ChargesValue value, an extra attribute value was detected. "+
					"A ChargesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ChargesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewChargesValueUnknown(), diags
	}

	billableMetricCodeAttribute, ok := attributes["billable_metric_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable_metric_code is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	billableMetricCodeVal, ok := billableMetricCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable_metric_code expected to be basetypes.StringValue, was: %T`, billableMetricCodeAttribute))
	}

	billableMetricIdAttribute, ok := attributes["billable_metric_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable_metric_id is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	billableMetricIdVal, ok := billableMetricIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable_metric_id expected to be basetypes.StringValue, was: %T`, billableMetricIdAttribute))
	}

	chargeModelAttribute, ok := attributes["charge_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`charge_model is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	chargeModelVal, ok := chargeModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`charge_model expected to be basetypes.StringValue, was: %T`, chargeModelAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	invoiceableAttribute, ok := attributes["invoiceable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoiceable is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	invoiceableVal, ok := invoiceableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoiceable expected to be basetypes.BoolValue, was: %T`, invoiceableAttribute))
	}

	lagoBillableMetricIdAttribute, ok := attributes["lago_billable_metric_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_billable_metric_id is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	lagoBillableMetricIdVal, ok := lagoBillableMetricIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_billable_metric_id expected to be basetypes.StringValue, was: %T`, lagoBillableMetricIdAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	minAmountCentsAttribute, ok := attributes["min_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_amount_cents is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	minAmountCentsVal, ok := minAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_amount_cents expected to be basetypes.Int64Value, was: %T`, minAmountCentsAttribute))
	}

	payInAdvanceAttribute, ok := attributes["pay_in_advance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pay_in_advance is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	payInAdvanceVal, ok := payInAdvanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pay_in_advance expected to be basetypes.BoolValue, was: %T`, payInAdvanceAttribute))
	}

	propertiesAttribute, ok := attributes["properties"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`properties is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	propertiesVal, ok := propertiesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`properties expected to be basetypes.ObjectValue, was: %T`, propertiesAttribute))
	}

	proratedAttribute, ok := attributes["prorated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prorated is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	proratedVal, ok := proratedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prorated expected to be basetypes.BoolValue, was: %T`, proratedAttribute))
	}

	regroupPaidFeesAttribute, ok := attributes["regroup_paid_fees"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regroup_paid_fees is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	regroupPaidFeesVal, ok := regroupPaidFeesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regroup_paid_fees expected to be basetypes.StringValue, was: %T`, regroupPaidFeesAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	taxesAttribute, ok := attributes["taxes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes is missing from object`)

		return NewChargesValueUnknown(), diags
	}

	taxesVal, ok := taxesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes expected to be basetypes.ListValue, was: %T`, taxesAttribute))
	}

	if diags.HasError() {
		return NewChargesValueUnknown(), diags
	}

	return ChargesValue{
		BillableMetricCode:   billableMetricCodeVal,
		BillableMetricId:     billableMetricIdVal,
		ChargeModel:          chargeModelVal,
		CreatedAt:            createdAtVal,
		Filters:              filtersVal,
		InvoiceDisplayName:   invoiceDisplayNameVal,
		Invoiceable:          invoiceableVal,
		LagoBillableMetricId: lagoBillableMetricIdVal,
		LagoId:               lagoIdVal,
		MinAmountCents:       minAmountCentsVal,
		PayInAdvance:         payInAdvanceVal,
		Properties:           propertiesVal,
		Prorated:             proratedVal,
		RegroupPaidFees:      regroupPaidFeesVal,
		TaxCodes:             taxCodesVal,
		Taxes:                taxesVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewChargesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ChargesValue {
	object, diags := NewChargesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewChargesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ChargesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewChargesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewChargesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewChargesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewChargesValueMust(ChargesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ChargesType) ValueType(ctx context.Context) attr.Value {
	return ChargesValue{}
}

var _ basetypes.ObjectValuable = ChargesValue{}

type ChargesValue struct {
	BillableMetricCode   basetypes.StringValue `tfsdk:"billable_metric_code"`
	BillableMetricId     basetypes.StringValue `tfsdk:"billable_metric_id"`
	ChargeModel          basetypes.StringValue `tfsdk:"charge_model"`
	CreatedAt            basetypes.StringValue `tfsdk:"created_at"`
	Filters              basetypes.ListValue   `tfsdk:"filters"`
	InvoiceDisplayName   basetypes.StringValue `tfsdk:"invoice_display_name"`
	Invoiceable          basetypes.BoolValue   `tfsdk:"invoiceable"`
	LagoBillableMetricId basetypes.StringValue `tfsdk:"lago_billable_metric_id"`
	LagoId               basetypes.StringValue `tfsdk:"lago_id"`
	MinAmountCents       basetypes.Int64Value  `tfsdk:"min_amount_cents"`
	PayInAdvance         basetypes.BoolValue   `tfsdk:"pay_in_advance"`
	Properties           basetypes.ObjectValue `tfsdk:"properties"`
	Prorated             basetypes.BoolValue   `tfsdk:"prorated"`
	RegroupPaidFees      basetypes.StringValue `tfsdk:"regroup_paid_fees"`
	TaxCodes             basetypes.ListValue   `tfsdk:"tax_codes"`
	Taxes                basetypes.ListValue   `tfsdk:"taxes"`
	state                attr.ValueState
}

func (v ChargesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["billable_metric_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["billable_metric_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["charge_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["filters"] = basetypes.ListType{
		ElemType: FiltersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoiceable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["lago_billable_metric_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["min_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["pay_in_advance"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["properties"] = basetypes.ObjectType{
		AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prorated"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["regroup_paid_fees"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tax_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["taxes"] = basetypes.ListType{
		ElemType: TaxesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.BillableMetricCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billable_metric_code"] = val

		val, err = v.BillableMetricId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billable_metric_id"] = val

		val, err = v.ChargeModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["charge_model"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.Invoiceable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoiceable"] = val

		val, err = v.LagoBillableMetricId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_billable_metric_id"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.MinAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_amount_cents"] = val

		val, err = v.PayInAdvance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pay_in_advance"] = val

		val, err = v.Properties.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["properties"] = val

		val, err = v.Prorated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prorated"] = val

		val, err = v.RegroupPaidFees.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["regroup_paid_fees"] = val

		val, err = v.TaxCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_codes"] = val

		val, err = v.Taxes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taxes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ChargesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ChargesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ChargesValue) String() string {
	return "ChargesValue"
}

func (v ChargesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	filters := types.ListValueMust(
		FiltersType{
			basetypes.ObjectType{
				AttrTypes: FiltersValue{}.AttributeTypes(ctx),
			},
		},
		v.Filters.Elements(),
	)

	if v.Filters.IsNull() {
		filters = types.ListNull(
			FiltersType{
				basetypes.ObjectType{
					AttrTypes: FiltersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Filters.IsUnknown() {
		filters = types.ListUnknown(
			FiltersType{
				basetypes.ObjectType{
					AttrTypes: FiltersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var properties basetypes.ObjectValue

	if v.Properties.IsNull() {
		properties = types.ObjectNull(
			PropertiesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Properties.IsUnknown() {
		properties = types.ObjectUnknown(
			PropertiesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Properties.IsNull() && !v.Properties.IsUnknown() {
		properties = types.ObjectValueMust(
			PropertiesValue{}.AttributeTypes(ctx),
			v.Properties.Attributes(),
		)
	}

	taxes := types.ListValueMust(
		TaxesType{
			basetypes.ObjectType{
				AttrTypes: TaxesValue{}.AttributeTypes(ctx),
			},
		},
		v.Taxes.Elements(),
	)

	if v.Taxes.IsNull() {
		taxes = types.ListNull(
			TaxesType{
				basetypes.ObjectType{
					AttrTypes: TaxesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Taxes.IsUnknown() {
		taxes = types.ListUnknown(
			TaxesType{
				basetypes.ObjectType{
					AttrTypes: TaxesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var taxCodesVal basetypes.ListValue
	switch {
	case v.TaxCodes.IsUnknown():
		taxCodesVal = types.ListUnknown(types.StringType)
	case v.TaxCodes.IsNull():
		taxCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		taxCodesVal, d = types.ListValue(types.StringType, v.TaxCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"billable_metric_code": basetypes.StringType{},
			"billable_metric_id":   basetypes.StringType{},
			"charge_model":         basetypes.StringType{},
			"created_at":           basetypes.StringType{},
			"filters": basetypes.ListType{
				ElemType: FiltersValue{}.Type(ctx),
			},
			"invoice_display_name":    basetypes.StringType{},
			"invoiceable":             basetypes.BoolType{},
			"lago_billable_metric_id": basetypes.StringType{},
			"lago_id":                 basetypes.StringType{},
			"min_amount_cents":        basetypes.Int64Type{},
			"pay_in_advance":          basetypes.BoolType{},
			"properties": basetypes.ObjectType{
				AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
			},
			"prorated":          basetypes.BoolType{},
			"regroup_paid_fees": basetypes.StringType{},
			"tax_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"taxes": basetypes.ListType{
				ElemType: TaxesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"billable_metric_code": basetypes.StringType{},
		"billable_metric_id":   basetypes.StringType{},
		"charge_model":         basetypes.StringType{},
		"created_at":           basetypes.StringType{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"invoice_display_name":    basetypes.StringType{},
		"invoiceable":             basetypes.BoolType{},
		"lago_billable_metric_id": basetypes.StringType{},
		"lago_id":                 basetypes.StringType{},
		"min_amount_cents":        basetypes.Int64Type{},
		"pay_in_advance":          basetypes.BoolType{},
		"properties": basetypes.ObjectType{
			AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
		},
		"prorated":          basetypes.BoolType{},
		"regroup_paid_fees": basetypes.StringType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"taxes": basetypes.ListType{
			ElemType: TaxesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"billable_metric_code":    v.BillableMetricCode,
			"billable_metric_id":      v.BillableMetricId,
			"charge_model":            v.ChargeModel,
			"created_at":              v.CreatedAt,
			"filters":                 filters,
			"invoice_display_name":    v.InvoiceDisplayName,
			"invoiceable":             v.Invoiceable,
			"lago_billable_metric_id": v.LagoBillableMetricId,
			"lago_id":                 v.LagoId,
			"min_amount_cents":        v.MinAmountCents,
			"pay_in_advance":          v.PayInAdvance,
			"properties":              properties,
			"prorated":                v.Prorated,
			"regroup_paid_fees":       v.RegroupPaidFees,
			"tax_codes":               taxCodesVal,
			"taxes":                   taxes,
		})

	return objVal, diags
}

func (v ChargesValue) Equal(o attr.Value) bool {
	other, ok := o.(ChargesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BillableMetricCode.Equal(other.BillableMetricCode) {
		return false
	}

	if !v.BillableMetricId.Equal(other.BillableMetricId) {
		return false
	}

	if !v.ChargeModel.Equal(other.ChargeModel) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.Invoiceable.Equal(other.Invoiceable) {
		return false
	}

	if !v.LagoBillableMetricId.Equal(other.LagoBillableMetricId) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.MinAmountCents.Equal(other.MinAmountCents) {
		return false
	}

	if !v.PayInAdvance.Equal(other.PayInAdvance) {
		return false
	}

	if !v.Properties.Equal(other.Properties) {
		return false
	}

	if !v.Prorated.Equal(other.Prorated) {
		return false
	}

	if !v.RegroupPaidFees.Equal(other.RegroupPaidFees) {
		return false
	}

	if !v.TaxCodes.Equal(other.TaxCodes) {
		return false
	}

	if !v.Taxes.Equal(other.Taxes) {
		return false
	}

	return true
}

func (v ChargesValue) Type(ctx context.Context) attr.Type {
	return ChargesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ChargesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"billable_metric_code": basetypes.StringType{},
		"billable_metric_id":   basetypes.StringType{},
		"charge_model":         basetypes.StringType{},
		"created_at":           basetypes.StringType{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"invoice_display_name":    basetypes.StringType{},
		"invoiceable":             basetypes.BoolType{},
		"lago_billable_metric_id": basetypes.StringType{},
		"lago_id":                 basetypes.StringType{},
		"min_amount_cents":        basetypes.Int64Type{},
		"pay_in_advance":          basetypes.BoolType{},
		"properties": basetypes.ObjectType{
			AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
		},
		"prorated":          basetypes.BoolType{},
		"regroup_paid_fees": basetypes.StringType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"taxes": basetypes.ListType{
			ElemType: TaxesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = FiltersType{}

type FiltersType struct {
	basetypes.ObjectType
}

func (t FiltersType) Equal(o attr.Type) bool {
	other, ok := o.(FiltersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FiltersType) String() string {
	return "FiltersType"
}

func (t FiltersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	propertiesAttribute, ok := attributes["properties"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`properties is missing from object`)

		return nil, diags
	}

	propertiesVal, ok := propertiesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`properties expected to be basetypes.ObjectValue, was: %T`, propertiesAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.MapValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FiltersValue{
		InvoiceDisplayName: invoiceDisplayNameVal,
		Properties:         propertiesVal,
		Values:             valuesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueNull() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateNull,
	}
}

func NewFiltersValueUnknown() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFiltersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FiltersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FiltersValue Attribute Value",
				"While creating a FiltersValue value, a missing attribute value was detected. "+
					"A FiltersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FiltersValue Attribute Type",
				"While creating a FiltersValue value, an invalid attribute value was detected. "+
					"A FiltersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FiltersValue Attribute Value",
				"While creating a FiltersValue value, an extra attribute value was detected. "+
					"A FiltersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FiltersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	propertiesAttribute, ok := attributes["properties"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`properties is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	propertiesVal, ok := propertiesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`properties expected to be basetypes.ObjectValue, was: %T`, propertiesAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.MapValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	return FiltersValue{
		InvoiceDisplayName: invoiceDisplayNameVal,
		Properties:         propertiesVal,
		Values:             valuesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FiltersValue {
	object, diags := NewFiltersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFiltersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FiltersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFiltersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFiltersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFiltersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFiltersValueMust(FiltersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FiltersType) ValueType(ctx context.Context) attr.Value {
	return FiltersValue{}
}

var _ basetypes.ObjectValuable = FiltersValue{}

type FiltersValue struct {
	InvoiceDisplayName basetypes.StringValue `tfsdk:"invoice_display_name"`
	Properties         basetypes.ObjectValue `tfsdk:"properties"`
	Values             basetypes.MapValue    `tfsdk:"values"`
	state              attr.ValueState
}

func (v FiltersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["properties"] = basetypes.ObjectType{
		AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["values"] = basetypes.MapType{
		ElemType: types.ListType{
			ElemType: types.StringType,
		},
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.Properties.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["properties"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FiltersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FiltersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FiltersValue) String() string {
	return "FiltersValue"
}

func (v FiltersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var properties basetypes.ObjectValue

	if v.Properties.IsNull() {
		properties = types.ObjectNull(
			PropertiesValue{}.AttributeTypes(ctx),
		)
	}

	if v.Properties.IsUnknown() {
		properties = types.ObjectUnknown(
			PropertiesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Properties.IsNull() && !v.Properties.IsUnknown() {
		properties = types.ObjectValueMust(
			PropertiesValue{}.AttributeTypes(ctx),
			v.Properties.Attributes(),
		)
	}

	var valuesVal basetypes.MapValue
	switch {
	case v.Values.IsUnknown():
		valuesVal = types.MapUnknown(types.ListType{
			ElemType: types.StringType,
		})
	case v.Values.IsNull():
		valuesVal = types.MapNull(types.ListType{
			ElemType: types.StringType,
		})
	default:
		var d diag.Diagnostics
		valuesVal, d = types.MapValue(types.ListType{
			ElemType: types.StringType,
		}, v.Values.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"invoice_display_name": basetypes.StringType{},
			"properties": basetypes.ObjectType{
				AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
			},
			"values": basetypes.MapType{
				ElemType: types.ListType{
					ElemType: types.StringType,
				},
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"invoice_display_name": basetypes.StringType{},
		"properties": basetypes.ObjectType{
			AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
		},
		"values": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"invoice_display_name": v.InvoiceDisplayName,
			"properties":           properties,
			"values":               valuesVal,
		})

	return objVal, diags
}

func (v FiltersValue) Equal(o attr.Value) bool {
	other, ok := o.(FiltersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.Properties.Equal(other.Properties) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v FiltersValue) Type(ctx context.Context) attr.Type {
	return FiltersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FiltersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"invoice_display_name": basetypes.StringType{},
		"properties": basetypes.ObjectType{
			AttrTypes: PropertiesValue{}.AttributeTypes(ctx),
		},
		"values": basetypes.MapType{
			ElemType: types.ListType{
				ElemType: types.StringType,
			},
		},
	}
}

var _ basetypes.ObjectTypable = PropertiesType{}

type PropertiesType struct {
	basetypes.ObjectType
}

func (t PropertiesType) Equal(o attr.Type) bool {
	other, ok := o.(PropertiesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PropertiesType) String() string {
	return "PropertiesType"
}

func (t PropertiesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountAttribute, ok := attributes["amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount is missing from object`)

		return nil, diags
	}

	amountVal, ok := amountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount expected to be basetypes.StringValue, was: %T`, amountAttribute))
	}

	fixedAmountAttribute, ok := attributes["fixed_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_amount is missing from object`)

		return nil, diags
	}

	fixedAmountVal, ok := fixedAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_amount expected to be basetypes.StringValue, was: %T`, fixedAmountAttribute))
	}

	freeUnitsAttribute, ok := attributes["free_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units is missing from object`)

		return nil, diags
	}

	freeUnitsVal, ok := freeUnitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units expected to be basetypes.Int64Value, was: %T`, freeUnitsAttribute))
	}

	freeUnitsPerEventsAttribute, ok := attributes["free_units_per_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_events is missing from object`)

		return nil, diags
	}

	freeUnitsPerEventsVal, ok := freeUnitsPerEventsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_events expected to be basetypes.Int64Value, was: %T`, freeUnitsPerEventsAttribute))
	}

	freeUnitsPerTotalAggregationAttribute, ok := attributes["free_units_per_total_aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_total_aggregation is missing from object`)

		return nil, diags
	}

	freeUnitsPerTotalAggregationVal, ok := freeUnitsPerTotalAggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_total_aggregation expected to be basetypes.StringValue, was: %T`, freeUnitsPerTotalAggregationAttribute))
	}

	graduatedPercentageRangesAttribute, ok := attributes["graduated_percentage_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_percentage_ranges is missing from object`)

		return nil, diags
	}

	graduatedPercentageRangesVal, ok := graduatedPercentageRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_percentage_ranges expected to be basetypes.ListValue, was: %T`, graduatedPercentageRangesAttribute))
	}

	graduatedRangesAttribute, ok := attributes["graduated_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_ranges is missing from object`)

		return nil, diags
	}

	graduatedRangesVal, ok := graduatedRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_ranges expected to be basetypes.ListValue, was: %T`, graduatedRangesAttribute))
	}

	groupedByAttribute, ok := attributes["grouped_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_by is missing from object`)

		return nil, diags
	}

	groupedByVal, ok := groupedByAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_by expected to be basetypes.ListValue, was: %T`, groupedByAttribute))
	}

	packageSizeAttribute, ok := attributes["package_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_size is missing from object`)

		return nil, diags
	}

	packageSizeVal, ok := packageSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_size expected to be basetypes.Int64Value, was: %T`, packageSizeAttribute))
	}

	perTransactionMaxAmountAttribute, ok := attributes["per_transaction_max_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_max_amount is missing from object`)

		return nil, diags
	}

	perTransactionMaxAmountVal, ok := perTransactionMaxAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_max_amount expected to be basetypes.StringValue, was: %T`, perTransactionMaxAmountAttribute))
	}

	perTransactionMinAmountAttribute, ok := attributes["per_transaction_min_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_min_amount is missing from object`)

		return nil, diags
	}

	perTransactionMinAmountVal, ok := perTransactionMinAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_min_amount expected to be basetypes.StringValue, was: %T`, perTransactionMinAmountAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	volumeRangesAttribute, ok := attributes["volume_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_ranges is missing from object`)

		return nil, diags
	}

	volumeRangesVal, ok := volumeRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_ranges expected to be basetypes.ListValue, was: %T`, volumeRangesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PropertiesValue{
		Amount:                       amountVal,
		FixedAmount:                  fixedAmountVal,
		FreeUnits:                    freeUnitsVal,
		FreeUnitsPerEvents:           freeUnitsPerEventsVal,
		FreeUnitsPerTotalAggregation: freeUnitsPerTotalAggregationVal,
		GraduatedPercentageRanges:    graduatedPercentageRangesVal,
		GraduatedRanges:              graduatedRangesVal,
		GroupedBy:                    groupedByVal,
		PackageSize:                  packageSizeVal,
		PerTransactionMaxAmount:      perTransactionMaxAmountVal,
		PerTransactionMinAmount:      perTransactionMinAmountVal,
		Rate:                         rateVal,
		VolumeRanges:                 volumeRangesVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewPropertiesValueNull() PropertiesValue {
	return PropertiesValue{
		state: attr.ValueStateNull,
	}
}

func NewPropertiesValueUnknown() PropertiesValue {
	return PropertiesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPropertiesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PropertiesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PropertiesValue Attribute Value",
				"While creating a PropertiesValue value, a missing attribute value was detected. "+
					"A PropertiesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PropertiesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PropertiesValue Attribute Type",
				"While creating a PropertiesValue value, an invalid attribute value was detected. "+
					"A PropertiesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PropertiesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PropertiesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PropertiesValue Attribute Value",
				"While creating a PropertiesValue value, an extra attribute value was detected. "+
					"A PropertiesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PropertiesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPropertiesValueUnknown(), diags
	}

	amountAttribute, ok := attributes["amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	amountVal, ok := amountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount expected to be basetypes.StringValue, was: %T`, amountAttribute))
	}

	fixedAmountAttribute, ok := attributes["fixed_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	fixedAmountVal, ok := fixedAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_amount expected to be basetypes.StringValue, was: %T`, fixedAmountAttribute))
	}

	freeUnitsAttribute, ok := attributes["free_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	freeUnitsVal, ok := freeUnitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units expected to be basetypes.Int64Value, was: %T`, freeUnitsAttribute))
	}

	freeUnitsPerEventsAttribute, ok := attributes["free_units_per_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_events is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	freeUnitsPerEventsVal, ok := freeUnitsPerEventsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_events expected to be basetypes.Int64Value, was: %T`, freeUnitsPerEventsAttribute))
	}

	freeUnitsPerTotalAggregationAttribute, ok := attributes["free_units_per_total_aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_total_aggregation is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	freeUnitsPerTotalAggregationVal, ok := freeUnitsPerTotalAggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_total_aggregation expected to be basetypes.StringValue, was: %T`, freeUnitsPerTotalAggregationAttribute))
	}

	graduatedPercentageRangesAttribute, ok := attributes["graduated_percentage_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_percentage_ranges is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	graduatedPercentageRangesVal, ok := graduatedPercentageRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_percentage_ranges expected to be basetypes.ListValue, was: %T`, graduatedPercentageRangesAttribute))
	}

	graduatedRangesAttribute, ok := attributes["graduated_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_ranges is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	graduatedRangesVal, ok := graduatedRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_ranges expected to be basetypes.ListValue, was: %T`, graduatedRangesAttribute))
	}

	groupedByAttribute, ok := attributes["grouped_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_by is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	groupedByVal, ok := groupedByAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_by expected to be basetypes.ListValue, was: %T`, groupedByAttribute))
	}

	packageSizeAttribute, ok := attributes["package_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_size is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	packageSizeVal, ok := packageSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_size expected to be basetypes.Int64Value, was: %T`, packageSizeAttribute))
	}

	perTransactionMaxAmountAttribute, ok := attributes["per_transaction_max_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_max_amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	perTransactionMaxAmountVal, ok := perTransactionMaxAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_max_amount expected to be basetypes.StringValue, was: %T`, perTransactionMaxAmountAttribute))
	}

	perTransactionMinAmountAttribute, ok := attributes["per_transaction_min_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_min_amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	perTransactionMinAmountVal, ok := perTransactionMinAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_min_amount expected to be basetypes.StringValue, was: %T`, perTransactionMinAmountAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	volumeRangesAttribute, ok := attributes["volume_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_ranges is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	volumeRangesVal, ok := volumeRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_ranges expected to be basetypes.ListValue, was: %T`, volumeRangesAttribute))
	}

	if diags.HasError() {
		return NewPropertiesValueUnknown(), diags
	}

	return PropertiesValue{
		Amount:                       amountVal,
		FixedAmount:                  fixedAmountVal,
		FreeUnits:                    freeUnitsVal,
		FreeUnitsPerEvents:           freeUnitsPerEventsVal,
		FreeUnitsPerTotalAggregation: freeUnitsPerTotalAggregationVal,
		GraduatedPercentageRanges:    graduatedPercentageRangesVal,
		GraduatedRanges:              graduatedRangesVal,
		GroupedBy:                    groupedByVal,
		PackageSize:                  packageSizeVal,
		PerTransactionMaxAmount:      perTransactionMaxAmountVal,
		PerTransactionMinAmount:      perTransactionMinAmountVal,
		Rate:                         rateVal,
		VolumeRanges:                 volumeRangesVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewPropertiesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PropertiesValue {
	object, diags := NewPropertiesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPropertiesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PropertiesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPropertiesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPropertiesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPropertiesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPropertiesValueMust(PropertiesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PropertiesType) ValueType(ctx context.Context) attr.Value {
	return PropertiesValue{}
}

var _ basetypes.ObjectValuable = PropertiesValue{}

type PropertiesValue struct {
	Amount                       basetypes.StringValue `tfsdk:"amount"`
	FixedAmount                  basetypes.StringValue `tfsdk:"fixed_amount"`
	FreeUnits                    basetypes.Int64Value  `tfsdk:"free_units"`
	FreeUnitsPerEvents           basetypes.Int64Value  `tfsdk:"free_units_per_events"`
	FreeUnitsPerTotalAggregation basetypes.StringValue `tfsdk:"free_units_per_total_aggregation"`
	GraduatedPercentageRanges    basetypes.ListValue   `tfsdk:"graduated_percentage_ranges"`
	GraduatedRanges              basetypes.ListValue   `tfsdk:"graduated_ranges"`
	GroupedBy                    basetypes.ListValue   `tfsdk:"grouped_by"`
	PackageSize                  basetypes.Int64Value  `tfsdk:"package_size"`
	PerTransactionMaxAmount      basetypes.StringValue `tfsdk:"per_transaction_max_amount"`
	PerTransactionMinAmount      basetypes.StringValue `tfsdk:"per_transaction_min_amount"`
	Rate                         basetypes.StringValue `tfsdk:"rate"`
	VolumeRanges                 basetypes.ListValue   `tfsdk:"volume_ranges"`
	state                        attr.ValueState
}

func (v PropertiesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fixed_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["free_units"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["free_units_per_events"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["free_units_per_total_aggregation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["graduated_percentage_ranges"] = basetypes.ListType{
		ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["graduated_ranges"] = basetypes.ListType{
		ElemType: GraduatedRangesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["grouped_by"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["package_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_transaction_max_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["per_transaction_min_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_ranges"] = basetypes.ListType{
		ElemType: VolumeRangesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.Amount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount"] = val

		val, err = v.FixedAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_amount"] = val

		val, err = v.FreeUnits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units"] = val

		val, err = v.FreeUnitsPerEvents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units_per_events"] = val

		val, err = v.FreeUnitsPerTotalAggregation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units_per_total_aggregation"] = val

		val, err = v.GraduatedPercentageRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["graduated_percentage_ranges"] = val

		val, err = v.GraduatedRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["graduated_ranges"] = val

		val, err = v.GroupedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["grouped_by"] = val

		val, err = v.PackageSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["package_size"] = val

		val, err = v.PerTransactionMaxAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_transaction_max_amount"] = val

		val, err = v.PerTransactionMinAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_transaction_min_amount"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		val, err = v.VolumeRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_ranges"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PropertiesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PropertiesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PropertiesValue) String() string {
	return "PropertiesValue"
}

func (v PropertiesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	graduatedPercentageRanges := types.ListValueMust(
		GraduatedPercentageRangesType{
			basetypes.ObjectType{
				AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.GraduatedPercentageRanges.Elements(),
	)

	if v.GraduatedPercentageRanges.IsNull() {
		graduatedPercentageRanges = types.ListNull(
			GraduatedPercentageRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.GraduatedPercentageRanges.IsUnknown() {
		graduatedPercentageRanges = types.ListUnknown(
			GraduatedPercentageRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	graduatedRanges := types.ListValueMust(
		GraduatedRangesType{
			basetypes.ObjectType{
				AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.GraduatedRanges.Elements(),
	)

	if v.GraduatedRanges.IsNull() {
		graduatedRanges = types.ListNull(
			GraduatedRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.GraduatedRanges.IsUnknown() {
		graduatedRanges = types.ListUnknown(
			GraduatedRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	volumeRanges := types.ListValueMust(
		VolumeRangesType{
			basetypes.ObjectType{
				AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.VolumeRanges.Elements(),
	)

	if v.VolumeRanges.IsNull() {
		volumeRanges = types.ListNull(
			VolumeRangesType{
				basetypes.ObjectType{
					AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VolumeRanges.IsUnknown() {
		volumeRanges = types.ListUnknown(
			VolumeRangesType{
				basetypes.ObjectType{
					AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var groupedByVal basetypes.ListValue
	switch {
	case v.GroupedBy.IsUnknown():
		groupedByVal = types.ListUnknown(types.StringType)
	case v.GroupedBy.IsNull():
		groupedByVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		groupedByVal, d = types.ListValue(types.StringType, v.GroupedBy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount":                           basetypes.StringType{},
			"fixed_amount":                     basetypes.StringType{},
			"free_units":                       basetypes.Int64Type{},
			"free_units_per_events":            basetypes.Int64Type{},
			"free_units_per_total_aggregation": basetypes.StringType{},
			"graduated_percentage_ranges": basetypes.ListType{
				ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
			},
			"graduated_ranges": basetypes.ListType{
				ElemType: GraduatedRangesValue{}.Type(ctx),
			},
			"grouped_by": basetypes.ListType{
				ElemType: types.StringType,
			},
			"package_size":               basetypes.Int64Type{},
			"per_transaction_max_amount": basetypes.StringType{},
			"per_transaction_min_amount": basetypes.StringType{},
			"rate":                       basetypes.StringType{},
			"volume_ranges": basetypes.ListType{
				ElemType: VolumeRangesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount":                           basetypes.StringType{},
		"fixed_amount":                     basetypes.StringType{},
		"free_units":                       basetypes.Int64Type{},
		"free_units_per_events":            basetypes.Int64Type{},
		"free_units_per_total_aggregation": basetypes.StringType{},
		"graduated_percentage_ranges": basetypes.ListType{
			ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
		},
		"graduated_ranges": basetypes.ListType{
			ElemType: GraduatedRangesValue{}.Type(ctx),
		},
		"grouped_by": basetypes.ListType{
			ElemType: types.StringType,
		},
		"package_size":               basetypes.Int64Type{},
		"per_transaction_max_amount": basetypes.StringType{},
		"per_transaction_min_amount": basetypes.StringType{},
		"rate":                       basetypes.StringType{},
		"volume_ranges": basetypes.ListType{
			ElemType: VolumeRangesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount":                           v.Amount,
			"fixed_amount":                     v.FixedAmount,
			"free_units":                       v.FreeUnits,
			"free_units_per_events":            v.FreeUnitsPerEvents,
			"free_units_per_total_aggregation": v.FreeUnitsPerTotalAggregation,
			"graduated_percentage_ranges":      graduatedPercentageRanges,
			"graduated_ranges":                 graduatedRanges,
			"grouped_by":                       groupedByVal,
			"package_size":                     v.PackageSize,
			"per_transaction_max_amount":       v.PerTransactionMaxAmount,
			"per_transaction_min_amount":       v.PerTransactionMinAmount,
			"rate":                             v.Rate,
			"volume_ranges":                    volumeRanges,
		})

	return objVal, diags
}

func (v PropertiesValue) Equal(o attr.Value) bool {
	other, ok := o.(PropertiesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Amount.Equal(other.Amount) {
		return false
	}

	if !v.FixedAmount.Equal(other.FixedAmount) {
		return false
	}

	if !v.FreeUnits.Equal(other.FreeUnits) {
		return false
	}

	if !v.FreeUnitsPerEvents.Equal(other.FreeUnitsPerEvents) {
		return false
	}

	if !v.FreeUnitsPerTotalAggregation.Equal(other.FreeUnitsPerTotalAggregation) {
		return false
	}

	if !v.GraduatedPercentageRanges.Equal(other.GraduatedPercentageRanges) {
		return false
	}

	if !v.GraduatedRanges.Equal(other.GraduatedRanges) {
		return false
	}

	if !v.GroupedBy.Equal(other.GroupedBy) {
		return false
	}

	if !v.PackageSize.Equal(other.PackageSize) {
		return false
	}

	if !v.PerTransactionMaxAmount.Equal(other.PerTransactionMaxAmount) {
		return false
	}

	if !v.PerTransactionMinAmount.Equal(other.PerTransactionMinAmount) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	if !v.VolumeRanges.Equal(other.VolumeRanges) {
		return false
	}

	return true
}

func (v PropertiesValue) Type(ctx context.Context) attr.Type {
	return PropertiesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PropertiesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount":                           basetypes.StringType{},
		"fixed_amount":                     basetypes.StringType{},
		"free_units":                       basetypes.Int64Type{},
		"free_units_per_events":            basetypes.Int64Type{},
		"free_units_per_total_aggregation": basetypes.StringType{},
		"graduated_percentage_ranges": basetypes.ListType{
			ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
		},
		"graduated_ranges": basetypes.ListType{
			ElemType: GraduatedRangesValue{}.Type(ctx),
		},
		"grouped_by": basetypes.ListType{
			ElemType: types.StringType,
		},
		"package_size":               basetypes.Int64Type{},
		"per_transaction_max_amount": basetypes.StringType{},
		"per_transaction_min_amount": basetypes.StringType{},
		"rate":                       basetypes.StringType{},
		"volume_ranges": basetypes.ListType{
			ElemType: VolumeRangesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = GraduatedPercentageRangesType{}

type GraduatedPercentageRangesType struct {
	basetypes.ObjectType
}

func (t GraduatedPercentageRangesType) Equal(o attr.Type) bool {
	other, ok := o.(GraduatedPercentageRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GraduatedPercentageRangesType) String() string {
	return "GraduatedPercentageRangesType"
}

func (t GraduatedPercentageRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return nil, diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GraduatedPercentageRangesValue{
		FlatAmount: flatAmountVal,
		FromValue:  fromValueVal,
		Rate:       rateVal,
		ToValue:    toValueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewGraduatedPercentageRangesValueNull() GraduatedPercentageRangesValue {
	return GraduatedPercentageRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewGraduatedPercentageRangesValueUnknown() GraduatedPercentageRangesValue {
	return GraduatedPercentageRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGraduatedPercentageRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GraduatedPercentageRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GraduatedPercentageRangesValue Attribute Value",
				"While creating a GraduatedPercentageRangesValue value, a missing attribute value was detected. "+
					"A GraduatedPercentageRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GraduatedPercentageRangesValue Attribute Type",
				"While creating a GraduatedPercentageRangesValue value, an invalid attribute value was detected. "+
					"A GraduatedPercentageRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GraduatedPercentageRangesValue Attribute Value",
				"While creating a GraduatedPercentageRangesValue value, an extra attribute value was detected. "+
					"A GraduatedPercentageRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GraduatedPercentageRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	return GraduatedPercentageRangesValue{
		FlatAmount: flatAmountVal,
		FromValue:  fromValueVal,
		Rate:       rateVal,
		ToValue:    toValueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewGraduatedPercentageRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GraduatedPercentageRangesValue {
	object, diags := NewGraduatedPercentageRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGraduatedPercentageRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GraduatedPercentageRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGraduatedPercentageRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGraduatedPercentageRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGraduatedPercentageRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGraduatedPercentageRangesValueMust(GraduatedPercentageRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GraduatedPercentageRangesType) ValueType(ctx context.Context) attr.Value {
	return GraduatedPercentageRangesValue{}
}

var _ basetypes.ObjectValuable = GraduatedPercentageRangesValue{}

type GraduatedPercentageRangesValue struct {
	FlatAmount basetypes.StringValue `tfsdk:"flat_amount"`
	FromValue  basetypes.Int64Value  `tfsdk:"from_value"`
	Rate       basetypes.StringValue `tfsdk:"rate"`
	ToValue    basetypes.Int64Value  `tfsdk:"to_value"`
	state      attr.ValueState
}

func (v GraduatedPercentageRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GraduatedPercentageRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GraduatedPercentageRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GraduatedPercentageRangesValue) String() string {
	return "GraduatedPercentageRangesValue"
}

func (v GraduatedPercentageRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_amount": basetypes.StringType{},
		"from_value":  basetypes.Int64Type{},
		"rate":        basetypes.StringType{},
		"to_value":    basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_amount": v.FlatAmount,
			"from_value":  v.FromValue,
			"rate":        v.Rate,
			"to_value":    v.ToValue,
		})

	return objVal, diags
}

func (v GraduatedPercentageRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(GraduatedPercentageRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatAmount.Equal(other.FlatAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	return true
}

func (v GraduatedPercentageRangesValue) Type(ctx context.Context) attr.Type {
	return GraduatedPercentageRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GraduatedPercentageRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_amount": basetypes.StringType{},
		"from_value":  basetypes.Int64Type{},
		"rate":        basetypes.StringType{},
		"to_value":    basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = GraduatedRangesType{}

type GraduatedRangesType struct {
	basetypes.ObjectType
}

func (t GraduatedRangesType) Equal(o attr.Type) bool {
	other, ok := o.(GraduatedRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GraduatedRangesType) String() string {
	return "GraduatedRangesType"
}

func (t GraduatedRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return nil, diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return nil, diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GraduatedRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewGraduatedRangesValueNull() GraduatedRangesValue {
	return GraduatedRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewGraduatedRangesValueUnknown() GraduatedRangesValue {
	return GraduatedRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGraduatedRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GraduatedRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GraduatedRangesValue Attribute Value",
				"While creating a GraduatedRangesValue value, a missing attribute value was detected. "+
					"A GraduatedRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GraduatedRangesValue Attribute Type",
				"While creating a GraduatedRangesValue value, an invalid attribute value was detected. "+
					"A GraduatedRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GraduatedRangesValue Attribute Value",
				"While creating a GraduatedRangesValue value, an extra attribute value was detected. "+
					"A GraduatedRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GraduatedRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGraduatedRangesValueUnknown(), diags
	}

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return NewGraduatedRangesValueUnknown(), diags
	}

	return GraduatedRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewGraduatedRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GraduatedRangesValue {
	object, diags := NewGraduatedRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGraduatedRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GraduatedRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGraduatedRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGraduatedRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGraduatedRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGraduatedRangesValueMust(GraduatedRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GraduatedRangesType) ValueType(ctx context.Context) attr.Value {
	return GraduatedRangesValue{}
}

var _ basetypes.ObjectValuable = GraduatedRangesValue{}

type GraduatedRangesValue struct {
	FlatAmount    basetypes.StringValue `tfsdk:"flat_amount"`
	FromValue     basetypes.Int64Value  `tfsdk:"from_value"`
	PerUnitAmount basetypes.StringValue `tfsdk:"per_unit_amount"`
	ToValue       basetypes.Int64Value  `tfsdk:"to_value"`
	state         attr.ValueState
}

func (v GraduatedRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.PerUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_amount"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GraduatedRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GraduatedRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GraduatedRangesValue) String() string {
	return "GraduatedRangesValue"
}

func (v GraduatedRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_amount":     v.FlatAmount,
			"from_value":      v.FromValue,
			"per_unit_amount": v.PerUnitAmount,
			"to_value":        v.ToValue,
		})

	return objVal, diags
}

func (v GraduatedRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(GraduatedRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatAmount.Equal(other.FlatAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.PerUnitAmount.Equal(other.PerUnitAmount) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	return true
}

func (v GraduatedRangesValue) Type(ctx context.Context) attr.Type {
	return GraduatedRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GraduatedRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = VolumeRangesType{}

type VolumeRangesType struct {
	basetypes.ObjectType
}

func (t VolumeRangesType) Equal(o attr.Type) bool {
	other, ok := o.(VolumeRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumeRangesType) String() string {
	return "VolumeRangesType"
}

func (t VolumeRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return nil, diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return nil, diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumeRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewVolumeRangesValueNull() VolumeRangesValue {
	return VolumeRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumeRangesValueUnknown() VolumeRangesValue {
	return VolumeRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumeRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumeRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumeRangesValue Attribute Value",
				"While creating a VolumeRangesValue value, a missing attribute value was detected. "+
					"A VolumeRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumeRangesValue Attribute Type",
				"While creating a VolumeRangesValue value, an invalid attribute value was detected. "+
					"A VolumeRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumeRangesValue Attribute Value",
				"While creating a VolumeRangesValue value, an extra attribute value was detected. "+
					"A VolumeRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumeRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumeRangesValueUnknown(), diags
	}

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return NewVolumeRangesValueUnknown(), diags
	}

	return VolumeRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewVolumeRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumeRangesValue {
	object, diags := NewVolumeRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumeRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumeRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumeRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumeRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumeRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumeRangesValueMust(VolumeRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumeRangesType) ValueType(ctx context.Context) attr.Value {
	return VolumeRangesValue{}
}

var _ basetypes.ObjectValuable = VolumeRangesValue{}

type VolumeRangesValue struct {
	FlatAmount    basetypes.StringValue `tfsdk:"flat_amount"`
	FromValue     basetypes.Int64Value  `tfsdk:"from_value"`
	PerUnitAmount basetypes.StringValue `tfsdk:"per_unit_amount"`
	ToValue       basetypes.Int64Value  `tfsdk:"to_value"`
	state         attr.ValueState
}

func (v VolumeRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.PerUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_amount"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumeRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumeRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumeRangesValue) String() string {
	return "VolumeRangesValue"
}

func (v VolumeRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_amount":     v.FlatAmount,
			"from_value":      v.FromValue,
			"per_unit_amount": v.PerUnitAmount,
			"to_value":        v.ToValue,
		})

	return objVal, diags
}

func (v VolumeRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumeRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatAmount.Equal(other.FlatAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.PerUnitAmount.Equal(other.PerUnitAmount) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	return true
}

func (v VolumeRangesValue) Type(ctx context.Context) attr.Type {
	return VolumeRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumeRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PropertiesType{}

type PropertiesType struct {
	basetypes.ObjectType
}

func (t PropertiesType) Equal(o attr.Type) bool {
	other, ok := o.(PropertiesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PropertiesType) String() string {
	return "PropertiesType"
}

func (t PropertiesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountAttribute, ok := attributes["amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount is missing from object`)

		return nil, diags
	}

	amountVal, ok := amountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount expected to be basetypes.StringValue, was: %T`, amountAttribute))
	}

	fixedAmountAttribute, ok := attributes["fixed_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_amount is missing from object`)

		return nil, diags
	}

	fixedAmountVal, ok := fixedAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_amount expected to be basetypes.StringValue, was: %T`, fixedAmountAttribute))
	}

	freeUnitsAttribute, ok := attributes["free_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units is missing from object`)

		return nil, diags
	}

	freeUnitsVal, ok := freeUnitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units expected to be basetypes.Int64Value, was: %T`, freeUnitsAttribute))
	}

	freeUnitsPerEventsAttribute, ok := attributes["free_units_per_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_events is missing from object`)

		return nil, diags
	}

	freeUnitsPerEventsVal, ok := freeUnitsPerEventsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_events expected to be basetypes.Int64Value, was: %T`, freeUnitsPerEventsAttribute))
	}

	freeUnitsPerTotalAggregationAttribute, ok := attributes["free_units_per_total_aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_total_aggregation is missing from object`)

		return nil, diags
	}

	freeUnitsPerTotalAggregationVal, ok := freeUnitsPerTotalAggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_total_aggregation expected to be basetypes.StringValue, was: %T`, freeUnitsPerTotalAggregationAttribute))
	}

	graduatedPercentageRangesAttribute, ok := attributes["graduated_percentage_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_percentage_ranges is missing from object`)

		return nil, diags
	}

	graduatedPercentageRangesVal, ok := graduatedPercentageRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_percentage_ranges expected to be basetypes.ListValue, was: %T`, graduatedPercentageRangesAttribute))
	}

	graduatedRangesAttribute, ok := attributes["graduated_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_ranges is missing from object`)

		return nil, diags
	}

	graduatedRangesVal, ok := graduatedRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_ranges expected to be basetypes.ListValue, was: %T`, graduatedRangesAttribute))
	}

	groupedByAttribute, ok := attributes["grouped_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_by is missing from object`)

		return nil, diags
	}

	groupedByVal, ok := groupedByAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_by expected to be basetypes.ListValue, was: %T`, groupedByAttribute))
	}

	packageSizeAttribute, ok := attributes["package_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_size is missing from object`)

		return nil, diags
	}

	packageSizeVal, ok := packageSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_size expected to be basetypes.Int64Value, was: %T`, packageSizeAttribute))
	}

	perTransactionMaxAmountAttribute, ok := attributes["per_transaction_max_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_max_amount is missing from object`)

		return nil, diags
	}

	perTransactionMaxAmountVal, ok := perTransactionMaxAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_max_amount expected to be basetypes.StringValue, was: %T`, perTransactionMaxAmountAttribute))
	}

	perTransactionMinAmountAttribute, ok := attributes["per_transaction_min_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_min_amount is missing from object`)

		return nil, diags
	}

	perTransactionMinAmountVal, ok := perTransactionMinAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_min_amount expected to be basetypes.StringValue, was: %T`, perTransactionMinAmountAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	volumeRangesAttribute, ok := attributes["volume_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_ranges is missing from object`)

		return nil, diags
	}

	volumeRangesVal, ok := volumeRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_ranges expected to be basetypes.ListValue, was: %T`, volumeRangesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PropertiesValue{
		Amount:                       amountVal,
		FixedAmount:                  fixedAmountVal,
		FreeUnits:                    freeUnitsVal,
		FreeUnitsPerEvents:           freeUnitsPerEventsVal,
		FreeUnitsPerTotalAggregation: freeUnitsPerTotalAggregationVal,
		GraduatedPercentageRanges:    graduatedPercentageRangesVal,
		GraduatedRanges:              graduatedRangesVal,
		GroupedBy:                    groupedByVal,
		PackageSize:                  packageSizeVal,
		PerTransactionMaxAmount:      perTransactionMaxAmountVal,
		PerTransactionMinAmount:      perTransactionMinAmountVal,
		Rate:                         rateVal,
		VolumeRanges:                 volumeRangesVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewPropertiesValueNull() PropertiesValue {
	return PropertiesValue{
		state: attr.ValueStateNull,
	}
}

func NewPropertiesValueUnknown() PropertiesValue {
	return PropertiesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPropertiesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PropertiesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PropertiesValue Attribute Value",
				"While creating a PropertiesValue value, a missing attribute value was detected. "+
					"A PropertiesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PropertiesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PropertiesValue Attribute Type",
				"While creating a PropertiesValue value, an invalid attribute value was detected. "+
					"A PropertiesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PropertiesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PropertiesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PropertiesValue Attribute Value",
				"While creating a PropertiesValue value, an extra attribute value was detected. "+
					"A PropertiesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PropertiesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPropertiesValueUnknown(), diags
	}

	amountAttribute, ok := attributes["amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	amountVal, ok := amountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount expected to be basetypes.StringValue, was: %T`, amountAttribute))
	}

	fixedAmountAttribute, ok := attributes["fixed_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	fixedAmountVal, ok := fixedAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_amount expected to be basetypes.StringValue, was: %T`, fixedAmountAttribute))
	}

	freeUnitsAttribute, ok := attributes["free_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	freeUnitsVal, ok := freeUnitsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units expected to be basetypes.Int64Value, was: %T`, freeUnitsAttribute))
	}

	freeUnitsPerEventsAttribute, ok := attributes["free_units_per_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_events is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	freeUnitsPerEventsVal, ok := freeUnitsPerEventsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_events expected to be basetypes.Int64Value, was: %T`, freeUnitsPerEventsAttribute))
	}

	freeUnitsPerTotalAggregationAttribute, ok := attributes["free_units_per_total_aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`free_units_per_total_aggregation is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	freeUnitsPerTotalAggregationVal, ok := freeUnitsPerTotalAggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`free_units_per_total_aggregation expected to be basetypes.StringValue, was: %T`, freeUnitsPerTotalAggregationAttribute))
	}

	graduatedPercentageRangesAttribute, ok := attributes["graduated_percentage_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_percentage_ranges is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	graduatedPercentageRangesVal, ok := graduatedPercentageRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_percentage_ranges expected to be basetypes.ListValue, was: %T`, graduatedPercentageRangesAttribute))
	}

	graduatedRangesAttribute, ok := attributes["graduated_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graduated_ranges is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	graduatedRangesVal, ok := graduatedRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graduated_ranges expected to be basetypes.ListValue, was: %T`, graduatedRangesAttribute))
	}

	groupedByAttribute, ok := attributes["grouped_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_by is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	groupedByVal, ok := groupedByAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_by expected to be basetypes.ListValue, was: %T`, groupedByAttribute))
	}

	packageSizeAttribute, ok := attributes["package_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_size is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	packageSizeVal, ok := packageSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_size expected to be basetypes.Int64Value, was: %T`, packageSizeAttribute))
	}

	perTransactionMaxAmountAttribute, ok := attributes["per_transaction_max_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_max_amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	perTransactionMaxAmountVal, ok := perTransactionMaxAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_max_amount expected to be basetypes.StringValue, was: %T`, perTransactionMaxAmountAttribute))
	}

	perTransactionMinAmountAttribute, ok := attributes["per_transaction_min_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_transaction_min_amount is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	perTransactionMinAmountVal, ok := perTransactionMinAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_transaction_min_amount expected to be basetypes.StringValue, was: %T`, perTransactionMinAmountAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	volumeRangesAttribute, ok := attributes["volume_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volume_ranges is missing from object`)

		return NewPropertiesValueUnknown(), diags
	}

	volumeRangesVal, ok := volumeRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volume_ranges expected to be basetypes.ListValue, was: %T`, volumeRangesAttribute))
	}

	if diags.HasError() {
		return NewPropertiesValueUnknown(), diags
	}

	return PropertiesValue{
		Amount:                       amountVal,
		FixedAmount:                  fixedAmountVal,
		FreeUnits:                    freeUnitsVal,
		FreeUnitsPerEvents:           freeUnitsPerEventsVal,
		FreeUnitsPerTotalAggregation: freeUnitsPerTotalAggregationVal,
		GraduatedPercentageRanges:    graduatedPercentageRangesVal,
		GraduatedRanges:              graduatedRangesVal,
		GroupedBy:                    groupedByVal,
		PackageSize:                  packageSizeVal,
		PerTransactionMaxAmount:      perTransactionMaxAmountVal,
		PerTransactionMinAmount:      perTransactionMinAmountVal,
		Rate:                         rateVal,
		VolumeRanges:                 volumeRangesVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewPropertiesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PropertiesValue {
	object, diags := NewPropertiesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPropertiesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PropertiesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPropertiesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPropertiesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPropertiesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPropertiesValueMust(PropertiesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PropertiesType) ValueType(ctx context.Context) attr.Value {
	return PropertiesValue{}
}

var _ basetypes.ObjectValuable = PropertiesValue{}

type PropertiesValue struct {
	Amount                       basetypes.StringValue `tfsdk:"amount"`
	FixedAmount                  basetypes.StringValue `tfsdk:"fixed_amount"`
	FreeUnits                    basetypes.Int64Value  `tfsdk:"free_units"`
	FreeUnitsPerEvents           basetypes.Int64Value  `tfsdk:"free_units_per_events"`
	FreeUnitsPerTotalAggregation basetypes.StringValue `tfsdk:"free_units_per_total_aggregation"`
	GraduatedPercentageRanges    basetypes.ListValue   `tfsdk:"graduated_percentage_ranges"`
	GraduatedRanges              basetypes.ListValue   `tfsdk:"graduated_ranges"`
	GroupedBy                    basetypes.ListValue   `tfsdk:"grouped_by"`
	PackageSize                  basetypes.Int64Value  `tfsdk:"package_size"`
	PerTransactionMaxAmount      basetypes.StringValue `tfsdk:"per_transaction_max_amount"`
	PerTransactionMinAmount      basetypes.StringValue `tfsdk:"per_transaction_min_amount"`
	Rate                         basetypes.StringValue `tfsdk:"rate"`
	VolumeRanges                 basetypes.ListValue   `tfsdk:"volume_ranges"`
	state                        attr.ValueState
}

func (v PropertiesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fixed_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["free_units"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["free_units_per_events"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["free_units_per_total_aggregation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["graduated_percentage_ranges"] = basetypes.ListType{
		ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["graduated_ranges"] = basetypes.ListType{
		ElemType: GraduatedRangesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["grouped_by"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["package_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_transaction_max_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["per_transaction_min_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volume_ranges"] = basetypes.ListType{
		ElemType: VolumeRangesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.Amount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount"] = val

		val, err = v.FixedAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_amount"] = val

		val, err = v.FreeUnits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units"] = val

		val, err = v.FreeUnitsPerEvents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units_per_events"] = val

		val, err = v.FreeUnitsPerTotalAggregation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["free_units_per_total_aggregation"] = val

		val, err = v.GraduatedPercentageRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["graduated_percentage_ranges"] = val

		val, err = v.GraduatedRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["graduated_ranges"] = val

		val, err = v.GroupedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["grouped_by"] = val

		val, err = v.PackageSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["package_size"] = val

		val, err = v.PerTransactionMaxAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_transaction_max_amount"] = val

		val, err = v.PerTransactionMinAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_transaction_min_amount"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		val, err = v.VolumeRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volume_ranges"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PropertiesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PropertiesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PropertiesValue) String() string {
	return "PropertiesValue"
}

func (v PropertiesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	graduatedPercentageRanges := types.ListValueMust(
		GraduatedPercentageRangesType{
			basetypes.ObjectType{
				AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.GraduatedPercentageRanges.Elements(),
	)

	if v.GraduatedPercentageRanges.IsNull() {
		graduatedPercentageRanges = types.ListNull(
			GraduatedPercentageRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.GraduatedPercentageRanges.IsUnknown() {
		graduatedPercentageRanges = types.ListUnknown(
			GraduatedPercentageRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedPercentageRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	graduatedRanges := types.ListValueMust(
		GraduatedRangesType{
			basetypes.ObjectType{
				AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.GraduatedRanges.Elements(),
	)

	if v.GraduatedRanges.IsNull() {
		graduatedRanges = types.ListNull(
			GraduatedRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.GraduatedRanges.IsUnknown() {
		graduatedRanges = types.ListUnknown(
			GraduatedRangesType{
				basetypes.ObjectType{
					AttrTypes: GraduatedRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	volumeRanges := types.ListValueMust(
		VolumeRangesType{
			basetypes.ObjectType{
				AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.VolumeRanges.Elements(),
	)

	if v.VolumeRanges.IsNull() {
		volumeRanges = types.ListNull(
			VolumeRangesType{
				basetypes.ObjectType{
					AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VolumeRanges.IsUnknown() {
		volumeRanges = types.ListUnknown(
			VolumeRangesType{
				basetypes.ObjectType{
					AttrTypes: VolumeRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var groupedByVal basetypes.ListValue
	switch {
	case v.GroupedBy.IsUnknown():
		groupedByVal = types.ListUnknown(types.StringType)
	case v.GroupedBy.IsNull():
		groupedByVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		groupedByVal, d = types.ListValue(types.StringType, v.GroupedBy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount":                           basetypes.StringType{},
			"fixed_amount":                     basetypes.StringType{},
			"free_units":                       basetypes.Int64Type{},
			"free_units_per_events":            basetypes.Int64Type{},
			"free_units_per_total_aggregation": basetypes.StringType{},
			"graduated_percentage_ranges": basetypes.ListType{
				ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
			},
			"graduated_ranges": basetypes.ListType{
				ElemType: GraduatedRangesValue{}.Type(ctx),
			},
			"grouped_by": basetypes.ListType{
				ElemType: types.StringType,
			},
			"package_size":               basetypes.Int64Type{},
			"per_transaction_max_amount": basetypes.StringType{},
			"per_transaction_min_amount": basetypes.StringType{},
			"rate":                       basetypes.StringType{},
			"volume_ranges": basetypes.ListType{
				ElemType: VolumeRangesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount":                           basetypes.StringType{},
		"fixed_amount":                     basetypes.StringType{},
		"free_units":                       basetypes.Int64Type{},
		"free_units_per_events":            basetypes.Int64Type{},
		"free_units_per_total_aggregation": basetypes.StringType{},
		"graduated_percentage_ranges": basetypes.ListType{
			ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
		},
		"graduated_ranges": basetypes.ListType{
			ElemType: GraduatedRangesValue{}.Type(ctx),
		},
		"grouped_by": basetypes.ListType{
			ElemType: types.StringType,
		},
		"package_size":               basetypes.Int64Type{},
		"per_transaction_max_amount": basetypes.StringType{},
		"per_transaction_min_amount": basetypes.StringType{},
		"rate":                       basetypes.StringType{},
		"volume_ranges": basetypes.ListType{
			ElemType: VolumeRangesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount":                           v.Amount,
			"fixed_amount":                     v.FixedAmount,
			"free_units":                       v.FreeUnits,
			"free_units_per_events":            v.FreeUnitsPerEvents,
			"free_units_per_total_aggregation": v.FreeUnitsPerTotalAggregation,
			"graduated_percentage_ranges":      graduatedPercentageRanges,
			"graduated_ranges":                 graduatedRanges,
			"grouped_by":                       groupedByVal,
			"package_size":                     v.PackageSize,
			"per_transaction_max_amount":       v.PerTransactionMaxAmount,
			"per_transaction_min_amount":       v.PerTransactionMinAmount,
			"rate":                             v.Rate,
			"volume_ranges":                    volumeRanges,
		})

	return objVal, diags
}

func (v PropertiesValue) Equal(o attr.Value) bool {
	other, ok := o.(PropertiesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Amount.Equal(other.Amount) {
		return false
	}

	if !v.FixedAmount.Equal(other.FixedAmount) {
		return false
	}

	if !v.FreeUnits.Equal(other.FreeUnits) {
		return false
	}

	if !v.FreeUnitsPerEvents.Equal(other.FreeUnitsPerEvents) {
		return false
	}

	if !v.FreeUnitsPerTotalAggregation.Equal(other.FreeUnitsPerTotalAggregation) {
		return false
	}

	if !v.GraduatedPercentageRanges.Equal(other.GraduatedPercentageRanges) {
		return false
	}

	if !v.GraduatedRanges.Equal(other.GraduatedRanges) {
		return false
	}

	if !v.GroupedBy.Equal(other.GroupedBy) {
		return false
	}

	if !v.PackageSize.Equal(other.PackageSize) {
		return false
	}

	if !v.PerTransactionMaxAmount.Equal(other.PerTransactionMaxAmount) {
		return false
	}

	if !v.PerTransactionMinAmount.Equal(other.PerTransactionMinAmount) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	if !v.VolumeRanges.Equal(other.VolumeRanges) {
		return false
	}

	return true
}

func (v PropertiesValue) Type(ctx context.Context) attr.Type {
	return PropertiesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PropertiesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount":                           basetypes.StringType{},
		"fixed_amount":                     basetypes.StringType{},
		"free_units":                       basetypes.Int64Type{},
		"free_units_per_events":            basetypes.Int64Type{},
		"free_units_per_total_aggregation": basetypes.StringType{},
		"graduated_percentage_ranges": basetypes.ListType{
			ElemType: GraduatedPercentageRangesValue{}.Type(ctx),
		},
		"graduated_ranges": basetypes.ListType{
			ElemType: GraduatedRangesValue{}.Type(ctx),
		},
		"grouped_by": basetypes.ListType{
			ElemType: types.StringType,
		},
		"package_size":               basetypes.Int64Type{},
		"per_transaction_max_amount": basetypes.StringType{},
		"per_transaction_min_amount": basetypes.StringType{},
		"rate":                       basetypes.StringType{},
		"volume_ranges": basetypes.ListType{
			ElemType: VolumeRangesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = GraduatedPercentageRangesType{}

type GraduatedPercentageRangesType struct {
	basetypes.ObjectType
}

func (t GraduatedPercentageRangesType) Equal(o attr.Type) bool {
	other, ok := o.(GraduatedPercentageRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GraduatedPercentageRangesType) String() string {
	return "GraduatedPercentageRangesType"
}

func (t GraduatedPercentageRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return nil, diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GraduatedPercentageRangesValue{
		FlatAmount: flatAmountVal,
		FromValue:  fromValueVal,
		Rate:       rateVal,
		ToValue:    toValueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewGraduatedPercentageRangesValueNull() GraduatedPercentageRangesValue {
	return GraduatedPercentageRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewGraduatedPercentageRangesValueUnknown() GraduatedPercentageRangesValue {
	return GraduatedPercentageRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGraduatedPercentageRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GraduatedPercentageRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GraduatedPercentageRangesValue Attribute Value",
				"While creating a GraduatedPercentageRangesValue value, a missing attribute value was detected. "+
					"A GraduatedPercentageRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GraduatedPercentageRangesValue Attribute Type",
				"While creating a GraduatedPercentageRangesValue value, an invalid attribute value was detected. "+
					"A GraduatedPercentageRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GraduatedPercentageRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GraduatedPercentageRangesValue Attribute Value",
				"While creating a GraduatedPercentageRangesValue value, an extra attribute value was detected. "+
					"A GraduatedPercentageRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GraduatedPercentageRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.StringValue, was: %T`, rateAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return NewGraduatedPercentageRangesValueUnknown(), diags
	}

	return GraduatedPercentageRangesValue{
		FlatAmount: flatAmountVal,
		FromValue:  fromValueVal,
		Rate:       rateVal,
		ToValue:    toValueVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewGraduatedPercentageRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GraduatedPercentageRangesValue {
	object, diags := NewGraduatedPercentageRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGraduatedPercentageRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GraduatedPercentageRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGraduatedPercentageRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGraduatedPercentageRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGraduatedPercentageRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGraduatedPercentageRangesValueMust(GraduatedPercentageRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GraduatedPercentageRangesType) ValueType(ctx context.Context) attr.Value {
	return GraduatedPercentageRangesValue{}
}

var _ basetypes.ObjectValuable = GraduatedPercentageRangesValue{}

type GraduatedPercentageRangesValue struct {
	FlatAmount basetypes.StringValue `tfsdk:"flat_amount"`
	FromValue  basetypes.Int64Value  `tfsdk:"from_value"`
	Rate       basetypes.StringValue `tfsdk:"rate"`
	ToValue    basetypes.Int64Value  `tfsdk:"to_value"`
	state      attr.ValueState
}

func (v GraduatedPercentageRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GraduatedPercentageRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GraduatedPercentageRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GraduatedPercentageRangesValue) String() string {
	return "GraduatedPercentageRangesValue"
}

func (v GraduatedPercentageRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_amount": basetypes.StringType{},
		"from_value":  basetypes.Int64Type{},
		"rate":        basetypes.StringType{},
		"to_value":    basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_amount": v.FlatAmount,
			"from_value":  v.FromValue,
			"rate":        v.Rate,
			"to_value":    v.ToValue,
		})

	return objVal, diags
}

func (v GraduatedPercentageRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(GraduatedPercentageRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatAmount.Equal(other.FlatAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	return true
}

func (v GraduatedPercentageRangesValue) Type(ctx context.Context) attr.Type {
	return GraduatedPercentageRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GraduatedPercentageRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_amount": basetypes.StringType{},
		"from_value":  basetypes.Int64Type{},
		"rate":        basetypes.StringType{},
		"to_value":    basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = GraduatedRangesType{}

type GraduatedRangesType struct {
	basetypes.ObjectType
}

func (t GraduatedRangesType) Equal(o attr.Type) bool {
	other, ok := o.(GraduatedRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GraduatedRangesType) String() string {
	return "GraduatedRangesType"
}

func (t GraduatedRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return nil, diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return nil, diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GraduatedRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewGraduatedRangesValueNull() GraduatedRangesValue {
	return GraduatedRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewGraduatedRangesValueUnknown() GraduatedRangesValue {
	return GraduatedRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGraduatedRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GraduatedRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GraduatedRangesValue Attribute Value",
				"While creating a GraduatedRangesValue value, a missing attribute value was detected. "+
					"A GraduatedRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GraduatedRangesValue Attribute Type",
				"While creating a GraduatedRangesValue value, an invalid attribute value was detected. "+
					"A GraduatedRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GraduatedRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GraduatedRangesValue Attribute Value",
				"While creating a GraduatedRangesValue value, an extra attribute value was detected. "+
					"A GraduatedRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GraduatedRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGraduatedRangesValueUnknown(), diags
	}

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewGraduatedRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return NewGraduatedRangesValueUnknown(), diags
	}

	return GraduatedRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewGraduatedRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GraduatedRangesValue {
	object, diags := NewGraduatedRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGraduatedRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GraduatedRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGraduatedRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGraduatedRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGraduatedRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGraduatedRangesValueMust(GraduatedRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GraduatedRangesType) ValueType(ctx context.Context) attr.Value {
	return GraduatedRangesValue{}
}

var _ basetypes.ObjectValuable = GraduatedRangesValue{}

type GraduatedRangesValue struct {
	FlatAmount    basetypes.StringValue `tfsdk:"flat_amount"`
	FromValue     basetypes.Int64Value  `tfsdk:"from_value"`
	PerUnitAmount basetypes.StringValue `tfsdk:"per_unit_amount"`
	ToValue       basetypes.Int64Value  `tfsdk:"to_value"`
	state         attr.ValueState
}

func (v GraduatedRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.PerUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_amount"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GraduatedRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GraduatedRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GraduatedRangesValue) String() string {
	return "GraduatedRangesValue"
}

func (v GraduatedRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_amount":     v.FlatAmount,
			"from_value":      v.FromValue,
			"per_unit_amount": v.PerUnitAmount,
			"to_value":        v.ToValue,
		})

	return objVal, diags
}

func (v GraduatedRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(GraduatedRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatAmount.Equal(other.FlatAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.PerUnitAmount.Equal(other.PerUnitAmount) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	return true
}

func (v GraduatedRangesValue) Type(ctx context.Context) attr.Type {
	return GraduatedRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GraduatedRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = VolumeRangesType{}

type VolumeRangesType struct {
	basetypes.ObjectType
}

func (t VolumeRangesType) Equal(o attr.Type) bool {
	other, ok := o.(VolumeRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumeRangesType) String() string {
	return "VolumeRangesType"
}

func (t VolumeRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return nil, diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return nil, diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return nil, diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return nil, diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumeRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewVolumeRangesValueNull() VolumeRangesValue {
	return VolumeRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumeRangesValueUnknown() VolumeRangesValue {
	return VolumeRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumeRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumeRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumeRangesValue Attribute Value",
				"While creating a VolumeRangesValue value, a missing attribute value was detected. "+
					"A VolumeRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumeRangesValue Attribute Type",
				"While creating a VolumeRangesValue value, an invalid attribute value was detected. "+
					"A VolumeRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumeRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumeRangesValue Attribute Value",
				"While creating a VolumeRangesValue value, an extra attribute value was detected. "+
					"A VolumeRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumeRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumeRangesValueUnknown(), diags
	}

	flatAmountAttribute, ok := attributes["flat_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flat_amount is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	flatAmountVal, ok := flatAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flat_amount expected to be basetypes.StringValue, was: %T`, flatAmountAttribute))
	}

	fromValueAttribute, ok := attributes["from_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_value is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	fromValueVal, ok := fromValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_value expected to be basetypes.Int64Value, was: %T`, fromValueAttribute))
	}

	perUnitAmountAttribute, ok := attributes["per_unit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_unit_amount is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	perUnitAmountVal, ok := perUnitAmountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_unit_amount expected to be basetypes.StringValue, was: %T`, perUnitAmountAttribute))
	}

	toValueAttribute, ok := attributes["to_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_value is missing from object`)

		return NewVolumeRangesValueUnknown(), diags
	}

	toValueVal, ok := toValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_value expected to be basetypes.Int64Value, was: %T`, toValueAttribute))
	}

	if diags.HasError() {
		return NewVolumeRangesValueUnknown(), diags
	}

	return VolumeRangesValue{
		FlatAmount:    flatAmountVal,
		FromValue:     fromValueVal,
		PerUnitAmount: perUnitAmountVal,
		ToValue:       toValueVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewVolumeRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumeRangesValue {
	object, diags := NewVolumeRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumeRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumeRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumeRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumeRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumeRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumeRangesValueMust(VolumeRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumeRangesType) ValueType(ctx context.Context) attr.Value {
	return VolumeRangesValue{}
}

var _ basetypes.ObjectValuable = VolumeRangesValue{}

type VolumeRangesValue struct {
	FlatAmount    basetypes.StringValue `tfsdk:"flat_amount"`
	FromValue     basetypes.Int64Value  `tfsdk:"from_value"`
	PerUnitAmount basetypes.StringValue `tfsdk:"per_unit_amount"`
	ToValue       basetypes.Int64Value  `tfsdk:"to_value"`
	state         attr.ValueState
}

func (v VolumeRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["flat_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["per_unit_amount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FlatAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flat_amount"] = val

		val, err = v.FromValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_value"] = val

		val, err = v.PerUnitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_unit_amount"] = val

		val, err = v.ToValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumeRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumeRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumeRangesValue) String() string {
	return "VolumeRangesValue"
}

func (v VolumeRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"flat_amount":     v.FlatAmount,
			"from_value":      v.FromValue,
			"per_unit_amount": v.PerUnitAmount,
			"to_value":        v.ToValue,
		})

	return objVal, diags
}

func (v VolumeRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumeRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FlatAmount.Equal(other.FlatAmount) {
		return false
	}

	if !v.FromValue.Equal(other.FromValue) {
		return false
	}

	if !v.PerUnitAmount.Equal(other.PerUnitAmount) {
		return false
	}

	if !v.ToValue.Equal(other.ToValue) {
		return false
	}

	return true
}

func (v VolumeRangesValue) Type(ctx context.Context) attr.Type {
	return VolumeRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumeRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"flat_amount":     basetypes.StringType{},
		"from_value":      basetypes.Int64Type{},
		"per_unit_amount": basetypes.StringType{},
		"to_value":        basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = TaxesType{}

type TaxesType struct {
	basetypes.ObjectType
}

func (t TaxesType) Equal(o attr.Type) bool {
	other, ok := o.(TaxesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TaxesType) String() string {
	return "TaxesType"
}

func (t TaxesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appliedToOrganizationAttribute, ok := attributes["applied_to_organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applied_to_organization is missing from object`)

		return nil, diags
	}

	appliedToOrganizationVal, ok := appliedToOrganizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applied_to_organization expected to be basetypes.BoolValue, was: %T`, appliedToOrganizationAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.NumberValue, was: %T`, rateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TaxesValue{
		AppliedToOrganization: appliedToOrganizationVal,
		Code:                  codeVal,
		CreatedAt:             createdAtVal,
		Description:           descriptionVal,
		LagoId:                lagoIdVal,
		Name:                  nameVal,
		Rate:                  rateVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewTaxesValueNull() TaxesValue {
	return TaxesValue{
		state: attr.ValueStateNull,
	}
}

func NewTaxesValueUnknown() TaxesValue {
	return TaxesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTaxesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TaxesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TaxesValue Attribute Value",
				"While creating a TaxesValue value, a missing attribute value was detected. "+
					"A TaxesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TaxesValue Attribute Type",
				"While creating a TaxesValue value, an invalid attribute value was detected. "+
					"A TaxesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TaxesValue Attribute Value",
				"While creating a TaxesValue value, an extra attribute value was detected. "+
					"A TaxesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TaxesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTaxesValueUnknown(), diags
	}

	appliedToOrganizationAttribute, ok := attributes["applied_to_organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applied_to_organization is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	appliedToOrganizationVal, ok := appliedToOrganizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applied_to_organization expected to be basetypes.BoolValue, was: %T`, appliedToOrganizationAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.NumberValue, was: %T`, rateAttribute))
	}

	if diags.HasError() {
		return NewTaxesValueUnknown(), diags
	}

	return TaxesValue{
		AppliedToOrganization: appliedToOrganizationVal,
		Code:                  codeVal,
		CreatedAt:             createdAtVal,
		Description:           descriptionVal,
		LagoId:                lagoIdVal,
		Name:                  nameVal,
		Rate:                  rateVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewTaxesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TaxesValue {
	object, diags := NewTaxesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTaxesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TaxesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTaxesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTaxesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTaxesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTaxesValueMust(TaxesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TaxesType) ValueType(ctx context.Context) attr.Value {
	return TaxesValue{}
}

var _ basetypes.ObjectValuable = TaxesValue{}

type TaxesValue struct {
	AppliedToOrganization basetypes.BoolValue   `tfsdk:"applied_to_organization"`
	Code                  basetypes.StringValue `tfsdk:"code"`
	CreatedAt             basetypes.StringValue `tfsdk:"created_at"`
	Description           basetypes.StringValue `tfsdk:"description"`
	LagoId                basetypes.StringValue `tfsdk:"lago_id"`
	Name                  basetypes.StringValue `tfsdk:"name"`
	Rate                  basetypes.NumberValue `tfsdk:"rate"`
	state                 attr.ValueState
}

func (v TaxesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["applied_to_organization"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AppliedToOrganization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["applied_to_organization"] = val

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TaxesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TaxesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TaxesValue) String() string {
	return "TaxesValue"
}

func (v TaxesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"applied_to_organization": basetypes.BoolType{},
		"code":                    basetypes.StringType{},
		"created_at":              basetypes.StringType{},
		"description":             basetypes.StringType{},
		"lago_id":                 basetypes.StringType{},
		"name":                    basetypes.StringType{},
		"rate":                    basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"applied_to_organization": v.AppliedToOrganization,
			"code":                    v.Code,
			"created_at":              v.CreatedAt,
			"description":             v.Description,
			"lago_id":                 v.LagoId,
			"name":                    v.Name,
			"rate":                    v.Rate,
		})

	return objVal, diags
}

func (v TaxesValue) Equal(o attr.Value) bool {
	other, ok := o.(TaxesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AppliedToOrganization.Equal(other.AppliedToOrganization) {
		return false
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	return true
}

func (v TaxesValue) Type(ctx context.Context) attr.Type {
	return TaxesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TaxesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"applied_to_organization": basetypes.BoolType{},
		"code":                    basetypes.StringType{},
		"created_at":              basetypes.StringType{},
		"description":             basetypes.StringType{},
		"lago_id":                 basetypes.StringType{},
		"name":                    basetypes.StringType{},
		"rate":                    basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = MinimumCommitmentType{}

type MinimumCommitmentType struct {
	basetypes.ObjectType
}

func (t MinimumCommitmentType) Equal(o attr.Type) bool {
	other, ok := o.(MinimumCommitmentType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MinimumCommitmentType) String() string {
	return "MinimumCommitmentType"
}

func (t MinimumCommitmentType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return nil, diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	planCodeAttribute, ok := attributes["plan_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_code is missing from object`)

		return nil, diags
	}

	planCodeVal, ok := planCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_code expected to be basetypes.StringValue, was: %T`, planCodeAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return nil, diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	taxesAttribute, ok := attributes["taxes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes is missing from object`)

		return nil, diags
	}

	taxesVal, ok := taxesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes expected to be basetypes.ListValue, was: %T`, taxesAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MinimumCommitmentValue{
		AmountCents:        amountCentsVal,
		CreatedAt:          createdAtVal,
		Interval:           intervalVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		LagoId:             lagoIdVal,
		PlanCode:           planCodeVal,
		TaxCodes:           taxCodesVal,
		Taxes:              taxesVal,
		UpdatedAt:          updatedAtVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewMinimumCommitmentValueNull() MinimumCommitmentValue {
	return MinimumCommitmentValue{
		state: attr.ValueStateNull,
	}
}

func NewMinimumCommitmentValueUnknown() MinimumCommitmentValue {
	return MinimumCommitmentValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMinimumCommitmentValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MinimumCommitmentValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MinimumCommitmentValue Attribute Value",
				"While creating a MinimumCommitmentValue value, a missing attribute value was detected. "+
					"A MinimumCommitmentValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MinimumCommitmentValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MinimumCommitmentValue Attribute Type",
				"While creating a MinimumCommitmentValue value, an invalid attribute value was detected. "+
					"A MinimumCommitmentValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MinimumCommitmentValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MinimumCommitmentValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MinimumCommitmentValue Attribute Value",
				"While creating a MinimumCommitmentValue value, an extra attribute value was detected. "+
					"A MinimumCommitmentValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MinimumCommitmentValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMinimumCommitmentValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.StringValue, was: %T`, intervalAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	planCodeAttribute, ok := attributes["plan_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_code is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	planCodeVal, ok := planCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_code expected to be basetypes.StringValue, was: %T`, planCodeAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	taxesAttribute, ok := attributes["taxes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	taxesVal, ok := taxesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes expected to be basetypes.ListValue, was: %T`, taxesAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewMinimumCommitmentValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewMinimumCommitmentValueUnknown(), diags
	}

	return MinimumCommitmentValue{
		AmountCents:        amountCentsVal,
		CreatedAt:          createdAtVal,
		Interval:           intervalVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		LagoId:             lagoIdVal,
		PlanCode:           planCodeVal,
		TaxCodes:           taxCodesVal,
		Taxes:              taxesVal,
		UpdatedAt:          updatedAtVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewMinimumCommitmentValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MinimumCommitmentValue {
	object, diags := NewMinimumCommitmentValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMinimumCommitmentValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MinimumCommitmentType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMinimumCommitmentValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMinimumCommitmentValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMinimumCommitmentValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMinimumCommitmentValueMust(MinimumCommitmentValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MinimumCommitmentType) ValueType(ctx context.Context) attr.Value {
	return MinimumCommitmentValue{}
}

var _ basetypes.ObjectValuable = MinimumCommitmentValue{}

type MinimumCommitmentValue struct {
	AmountCents        basetypes.Int64Value  `tfsdk:"amount_cents"`
	CreatedAt          basetypes.StringValue `tfsdk:"created_at"`
	Interval           basetypes.StringValue `tfsdk:"interval"`
	InvoiceDisplayName basetypes.StringValue `tfsdk:"invoice_display_name"`
	LagoId             basetypes.StringValue `tfsdk:"lago_id"`
	PlanCode           basetypes.StringValue `tfsdk:"plan_code"`
	TaxCodes           basetypes.ListValue   `tfsdk:"tax_codes"`
	Taxes              basetypes.ListValue   `tfsdk:"taxes"`
	UpdatedAt          basetypes.StringValue `tfsdk:"updated_at"`
	state              attr.ValueState
}

func (v MinimumCommitmentValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interval"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["plan_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tax_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["taxes"] = basetypes.ListType{
		ElemType: TaxesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Interval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interval"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.PlanCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan_code"] = val

		val, err = v.TaxCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_codes"] = val

		val, err = v.Taxes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taxes"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MinimumCommitmentValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MinimumCommitmentValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MinimumCommitmentValue) String() string {
	return "MinimumCommitmentValue"
}

func (v MinimumCommitmentValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	taxes := types.ListValueMust(
		TaxesType{
			basetypes.ObjectType{
				AttrTypes: TaxesValue{}.AttributeTypes(ctx),
			},
		},
		v.Taxes.Elements(),
	)

	if v.Taxes.IsNull() {
		taxes = types.ListNull(
			TaxesType{
				basetypes.ObjectType{
					AttrTypes: TaxesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Taxes.IsUnknown() {
		taxes = types.ListUnknown(
			TaxesType{
				basetypes.ObjectType{
					AttrTypes: TaxesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var taxCodesVal basetypes.ListValue
	switch {
	case v.TaxCodes.IsUnknown():
		taxCodesVal = types.ListUnknown(types.StringType)
	case v.TaxCodes.IsNull():
		taxCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		taxCodesVal, d = types.ListValue(types.StringType, v.TaxCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount_cents":         basetypes.Int64Type{},
			"created_at":           basetypes.StringType{},
			"interval":             basetypes.StringType{},
			"invoice_display_name": basetypes.StringType{},
			"lago_id":              basetypes.StringType{},
			"plan_code":            basetypes.StringType{},
			"tax_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"taxes": basetypes.ListType{
				ElemType: TaxesValue{}.Type(ctx),
			},
			"updated_at": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":         basetypes.Int64Type{},
		"created_at":           basetypes.StringType{},
		"interval":             basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"lago_id":              basetypes.StringType{},
		"plan_code":            basetypes.StringType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"taxes": basetypes.ListType{
			ElemType: TaxesValue{}.Type(ctx),
		},
		"updated_at": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":         v.AmountCents,
			"created_at":           v.CreatedAt,
			"interval":             v.Interval,
			"invoice_display_name": v.InvoiceDisplayName,
			"lago_id":              v.LagoId,
			"plan_code":            v.PlanCode,
			"tax_codes":            taxCodesVal,
			"taxes":                taxes,
			"updated_at":           v.UpdatedAt,
		})

	return objVal, diags
}

func (v MinimumCommitmentValue) Equal(o attr.Value) bool {
	other, ok := o.(MinimumCommitmentValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Interval.Equal(other.Interval) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.PlanCode.Equal(other.PlanCode) {
		return false
	}

	if !v.TaxCodes.Equal(other.TaxCodes) {
		return false
	}

	if !v.Taxes.Equal(other.Taxes) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v MinimumCommitmentValue) Type(ctx context.Context) attr.Type {
	return MinimumCommitmentType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MinimumCommitmentValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":         basetypes.Int64Type{},
		"created_at":           basetypes.StringType{},
		"interval":             basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"lago_id":              basetypes.StringType{},
		"plan_code":            basetypes.StringType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"taxes": basetypes.ListType{
			ElemType: TaxesValue{}.Type(ctx),
		},
		"updated_at": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TaxesType{}

type TaxesType struct {
	basetypes.ObjectType
}

func (t TaxesType) Equal(o attr.Type) bool {
	other, ok := o.(TaxesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TaxesType) String() string {
	return "TaxesType"
}

func (t TaxesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appliedToOrganizationAttribute, ok := attributes["applied_to_organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applied_to_organization is missing from object`)

		return nil, diags
	}

	appliedToOrganizationVal, ok := appliedToOrganizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applied_to_organization expected to be basetypes.BoolValue, was: %T`, appliedToOrganizationAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.NumberValue, was: %T`, rateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TaxesValue{
		AppliedToOrganization: appliedToOrganizationVal,
		Code:                  codeVal,
		CreatedAt:             createdAtVal,
		Description:           descriptionVal,
		LagoId:                lagoIdVal,
		Name:                  nameVal,
		Rate:                  rateVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewTaxesValueNull() TaxesValue {
	return TaxesValue{
		state: attr.ValueStateNull,
	}
}

func NewTaxesValueUnknown() TaxesValue {
	return TaxesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTaxesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TaxesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TaxesValue Attribute Value",
				"While creating a TaxesValue value, a missing attribute value was detected. "+
					"A TaxesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TaxesValue Attribute Type",
				"While creating a TaxesValue value, an invalid attribute value was detected. "+
					"A TaxesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TaxesValue Attribute Value",
				"While creating a TaxesValue value, an extra attribute value was detected. "+
					"A TaxesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TaxesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTaxesValueUnknown(), diags
	}

	appliedToOrganizationAttribute, ok := attributes["applied_to_organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applied_to_organization is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	appliedToOrganizationVal, ok := appliedToOrganizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applied_to_organization expected to be basetypes.BoolValue, was: %T`, appliedToOrganizationAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.NumberValue, was: %T`, rateAttribute))
	}

	if diags.HasError() {
		return NewTaxesValueUnknown(), diags
	}

	return TaxesValue{
		AppliedToOrganization: appliedToOrganizationVal,
		Code:                  codeVal,
		CreatedAt:             createdAtVal,
		Description:           descriptionVal,
		LagoId:                lagoIdVal,
		Name:                  nameVal,
		Rate:                  rateVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewTaxesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TaxesValue {
	object, diags := NewTaxesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTaxesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TaxesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTaxesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTaxesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTaxesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTaxesValueMust(TaxesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TaxesType) ValueType(ctx context.Context) attr.Value {
	return TaxesValue{}
}

var _ basetypes.ObjectValuable = TaxesValue{}

type TaxesValue struct {
	AppliedToOrganization basetypes.BoolValue   `tfsdk:"applied_to_organization"`
	Code                  basetypes.StringValue `tfsdk:"code"`
	CreatedAt             basetypes.StringValue `tfsdk:"created_at"`
	Description           basetypes.StringValue `tfsdk:"description"`
	LagoId                basetypes.StringValue `tfsdk:"lago_id"`
	Name                  basetypes.StringValue `tfsdk:"name"`
	Rate                  basetypes.NumberValue `tfsdk:"rate"`
	state                 attr.ValueState
}

func (v TaxesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["applied_to_organization"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AppliedToOrganization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["applied_to_organization"] = val

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TaxesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TaxesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TaxesValue) String() string {
	return "TaxesValue"
}

func (v TaxesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"applied_to_organization": basetypes.BoolType{},
		"code":                    basetypes.StringType{},
		"created_at":              basetypes.StringType{},
		"description":             basetypes.StringType{},
		"lago_id":                 basetypes.StringType{},
		"name":                    basetypes.StringType{},
		"rate":                    basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"applied_to_organization": v.AppliedToOrganization,
			"code":                    v.Code,
			"created_at":              v.CreatedAt,
			"description":             v.Description,
			"lago_id":                 v.LagoId,
			"name":                    v.Name,
			"rate":                    v.Rate,
		})

	return objVal, diags
}

func (v TaxesValue) Equal(o attr.Value) bool {
	other, ok := o.(TaxesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AppliedToOrganization.Equal(other.AppliedToOrganization) {
		return false
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	return true
}

func (v TaxesValue) Type(ctx context.Context) attr.Type {
	return TaxesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TaxesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"applied_to_organization": basetypes.BoolType{},
		"code":                    basetypes.StringType{},
		"created_at":              basetypes.StringType{},
		"description":             basetypes.StringType{},
		"lago_id":                 basetypes.StringType{},
		"name":                    basetypes.StringType{},
		"rate":                    basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = TaxesType{}

type TaxesType struct {
	basetypes.ObjectType
}

func (t TaxesType) Equal(o attr.Type) bool {
	other, ok := o.(TaxesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TaxesType) String() string {
	return "TaxesType"
}

func (t TaxesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appliedToOrganizationAttribute, ok := attributes["applied_to_organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applied_to_organization is missing from object`)

		return nil, diags
	}

	appliedToOrganizationVal, ok := appliedToOrganizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applied_to_organization expected to be basetypes.BoolValue, was: %T`, appliedToOrganizationAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.NumberValue, was: %T`, rateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TaxesValue{
		AppliedToOrganization: appliedToOrganizationVal,
		Code:                  codeVal,
		CreatedAt:             createdAtVal,
		Description:           descriptionVal,
		LagoId:                lagoIdVal,
		Name:                  nameVal,
		Rate:                  rateVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewTaxesValueNull() TaxesValue {
	return TaxesValue{
		state: attr.ValueStateNull,
	}
}

func NewTaxesValueUnknown() TaxesValue {
	return TaxesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTaxesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TaxesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TaxesValue Attribute Value",
				"While creating a TaxesValue value, a missing attribute value was detected. "+
					"A TaxesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TaxesValue Attribute Type",
				"While creating a TaxesValue value, an invalid attribute value was detected. "+
					"A TaxesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TaxesValue Attribute Value",
				"While creating a TaxesValue value, an extra attribute value was detected. "+
					"A TaxesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TaxesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTaxesValueUnknown(), diags
	}

	appliedToOrganizationAttribute, ok := attributes["applied_to_organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applied_to_organization is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	appliedToOrganizationVal, ok := appliedToOrganizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applied_to_organization expected to be basetypes.BoolValue, was: %T`, appliedToOrganizationAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.NumberValue, was: %T`, rateAttribute))
	}

	if diags.HasError() {
		return NewTaxesValueUnknown(), diags
	}

	return TaxesValue{
		AppliedToOrganization: appliedToOrganizationVal,
		Code:                  codeVal,
		CreatedAt:             createdAtVal,
		Description:           descriptionVal,
		LagoId:                lagoIdVal,
		Name:                  nameVal,
		Rate:                  rateVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewTaxesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TaxesValue {
	object, diags := NewTaxesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTaxesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TaxesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTaxesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTaxesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTaxesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTaxesValueMust(TaxesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TaxesType) ValueType(ctx context.Context) attr.Value {
	return TaxesValue{}
}

var _ basetypes.ObjectValuable = TaxesValue{}

type TaxesValue struct {
	AppliedToOrganization basetypes.BoolValue   `tfsdk:"applied_to_organization"`
	Code                  basetypes.StringValue `tfsdk:"code"`
	CreatedAt             basetypes.StringValue `tfsdk:"created_at"`
	Description           basetypes.StringValue `tfsdk:"description"`
	LagoId                basetypes.StringValue `tfsdk:"lago_id"`
	Name                  basetypes.StringValue `tfsdk:"name"`
	Rate                  basetypes.NumberValue `tfsdk:"rate"`
	state                 attr.ValueState
}

func (v TaxesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["applied_to_organization"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AppliedToOrganization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["applied_to_organization"] = val

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TaxesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TaxesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TaxesValue) String() string {
	return "TaxesValue"
}

func (v TaxesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"applied_to_organization": basetypes.BoolType{},
		"code":                    basetypes.StringType{},
		"created_at":              basetypes.StringType{},
		"description":             basetypes.StringType{},
		"lago_id":                 basetypes.StringType{},
		"name":                    basetypes.StringType{},
		"rate":                    basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"applied_to_organization": v.AppliedToOrganization,
			"code":                    v.Code,
			"created_at":              v.CreatedAt,
			"description":             v.Description,
			"lago_id":                 v.LagoId,
			"name":                    v.Name,
			"rate":                    v.Rate,
		})

	return objVal, diags
}

func (v TaxesValue) Equal(o attr.Value) bool {
	other, ok := o.(TaxesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AppliedToOrganization.Equal(other.AppliedToOrganization) {
		return false
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	return true
}

func (v TaxesValue) Type(ctx context.Context) attr.Type {
	return TaxesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TaxesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"applied_to_organization": basetypes.BoolType{},
		"code":                    basetypes.StringType{},
		"created_at":              basetypes.StringType{},
		"description":             basetypes.StringType{},
		"lago_id":                 basetypes.StringType{},
		"name":                    basetypes.StringType{},
		"rate":                    basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = UsageThresholdsType{}

type UsageThresholdsType struct {
	basetypes.ObjectType
}

func (t UsageThresholdsType) Equal(o attr.Type) bool {
	other, ok := o.(UsageThresholdsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsageThresholdsType) String() string {
	return "UsageThresholdsType"
}

func (t UsageThresholdsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	recurringAttribute, ok := attributes["recurring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recurring is missing from object`)

		return nil, diags
	}

	recurringVal, ok := recurringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recurring expected to be basetypes.BoolValue, was: %T`, recurringAttribute))
	}

	thresholdDisplayNameAttribute, ok := attributes["threshold_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold_display_name is missing from object`)

		return nil, diags
	}

	thresholdDisplayNameVal, ok := thresholdDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold_display_name expected to be basetypes.StringValue, was: %T`, thresholdDisplayNameAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsageThresholdsValue{
		AmountCents:          amountCentsVal,
		CreatedAt:            createdAtVal,
		Id:                   idVal,
		LagoId:               lagoIdVal,
		Recurring:            recurringVal,
		ThresholdDisplayName: thresholdDisplayNameVal,
		UpdatedAt:            updatedAtVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewUsageThresholdsValueNull() UsageThresholdsValue {
	return UsageThresholdsValue{
		state: attr.ValueStateNull,
	}
}

func NewUsageThresholdsValueUnknown() UsageThresholdsValue {
	return UsageThresholdsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsageThresholdsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsageThresholdsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsageThresholdsValue Attribute Value",
				"While creating a UsageThresholdsValue value, a missing attribute value was detected. "+
					"A UsageThresholdsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsageThresholdsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsageThresholdsValue Attribute Type",
				"While creating a UsageThresholdsValue value, an invalid attribute value was detected. "+
					"A UsageThresholdsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsageThresholdsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsageThresholdsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsageThresholdsValue Attribute Value",
				"While creating a UsageThresholdsValue value, an extra attribute value was detected. "+
					"A UsageThresholdsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsageThresholdsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsageThresholdsValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	recurringAttribute, ok := attributes["recurring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recurring is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	recurringVal, ok := recurringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recurring expected to be basetypes.BoolValue, was: %T`, recurringAttribute))
	}

	thresholdDisplayNameAttribute, ok := attributes["threshold_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold_display_name is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	thresholdDisplayNameVal, ok := thresholdDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold_display_name expected to be basetypes.StringValue, was: %T`, thresholdDisplayNameAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewUsageThresholdsValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	if diags.HasError() {
		return NewUsageThresholdsValueUnknown(), diags
	}

	return UsageThresholdsValue{
		AmountCents:          amountCentsVal,
		CreatedAt:            createdAtVal,
		Id:                   idVal,
		LagoId:               lagoIdVal,
		Recurring:            recurringVal,
		ThresholdDisplayName: thresholdDisplayNameVal,
		UpdatedAt:            updatedAtVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewUsageThresholdsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsageThresholdsValue {
	object, diags := NewUsageThresholdsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsageThresholdsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsageThresholdsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsageThresholdsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsageThresholdsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsageThresholdsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsageThresholdsValueMust(UsageThresholdsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsageThresholdsType) ValueType(ctx context.Context) attr.Value {
	return UsageThresholdsValue{}
}

var _ basetypes.ObjectValuable = UsageThresholdsValue{}

type UsageThresholdsValue struct {
	AmountCents          basetypes.Int64Value  `tfsdk:"amount_cents"`
	CreatedAt            basetypes.StringValue `tfsdk:"created_at"`
	Id                   basetypes.StringValue `tfsdk:"id"`
	LagoId               basetypes.StringValue `tfsdk:"lago_id"`
	Recurring            basetypes.BoolValue   `tfsdk:"recurring"`
	ThresholdDisplayName basetypes.StringValue `tfsdk:"threshold_display_name"`
	UpdatedAt            basetypes.StringValue `tfsdk:"updated_at"`
	state                attr.ValueState
}

func (v UsageThresholdsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recurring"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["threshold_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Recurring.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recurring"] = val

		val, err = v.ThresholdDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["threshold_display_name"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsageThresholdsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsageThresholdsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsageThresholdsValue) String() string {
	return "UsageThresholdsValue"
}

func (v UsageThresholdsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"amount_cents":           basetypes.Int64Type{},
		"created_at":             basetypes.StringType{},
		"id":                     basetypes.StringType{},
		"lago_id":                basetypes.StringType{},
		"recurring":              basetypes.BoolType{},
		"threshold_display_name": basetypes.StringType{},
		"updated_at":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":           v.AmountCents,
			"created_at":             v.CreatedAt,
			"id":                     v.Id,
			"lago_id":                v.LagoId,
			"recurring":              v.Recurring,
			"threshold_display_name": v.ThresholdDisplayName,
			"updated_at":             v.UpdatedAt,
		})

	return objVal, diags
}

func (v UsageThresholdsValue) Equal(o attr.Value) bool {
	other, ok := o.(UsageThresholdsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Recurring.Equal(other.Recurring) {
		return false
	}

	if !v.ThresholdDisplayName.Equal(other.ThresholdDisplayName) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	return true
}

func (v UsageThresholdsValue) Type(ctx context.Context) attr.Type {
	return UsageThresholdsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsageThresholdsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":           basetypes.Int64Type{},
		"created_at":             basetypes.StringType{},
		"id":                     basetypes.StringType{},
		"lago_id":                basetypes.StringType{},
		"recurring":              basetypes.BoolType{},
		"threshold_display_name": basetypes.StringType{},
		"updated_at":             basetypes.StringType{},
	}
}
