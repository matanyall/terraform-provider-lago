// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_payment_requests

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func PaymentRequestsResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"external_customer_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Unique identifier assigned to the customer in your application.",
				MarkdownDescription: "Unique identifier assigned to the customer in your application.",
			},
			"meta": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"current_page": schema.Int64Attribute{
						Computed:            true,
						Description:         "Current page.",
						MarkdownDescription: "Current page.",
					},
					"next_page": schema.Int64Attribute{
						Computed:            true,
						Description:         "Next page.",
						MarkdownDescription: "Next page.",
					},
					"prev_page": schema.Int64Attribute{
						Computed:            true,
						Description:         "Previous page.",
						MarkdownDescription: "Previous page.",
					},
					"total_count": schema.Int64Attribute{
						Computed:            true,
						Description:         "Total number of records.",
						MarkdownDescription: "Total number of records.",
					},
					"total_pages": schema.Int64Attribute{
						Computed:            true,
						Description:         "Total number of pages.",
						MarkdownDescription: "Total number of pages.",
					},
				},
				CustomType: MetaType{
					ObjectType: types.ObjectType{
						AttrTypes: MetaValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"page": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Page number.",
				MarkdownDescription: "Page number.",
			},
			"payment_request": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"amount_cents": schema.Int64Attribute{
						Computed:            true,
						Description:         "The sum of the total amounts of all the invoices included in the payment request, expressed in cents.",
						MarkdownDescription: "The sum of the total amounts of all the invoices included in the payment request, expressed in cents.",
					},
					"amount_currency": schema.StringAttribute{
						Computed: true,
					},
					"created_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date and time when the payment request was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the payment request was initially created.",
						MarkdownDescription: "The date and time when the payment request was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the payment request was initially created.",
					},
					"customer": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"account_type": schema.StringAttribute{
								Computed:            true,
								Description:         "The type of the account. It can have one of the following values:\n- `customer`: the account is a customer.\n- `partner`: the account is a partner.",
								MarkdownDescription: "The type of the account. It can have one of the following values:\n- `customer`: the account is a customer.\n- `partner`: the account is a partner.",
							},
							"address_line1": schema.StringAttribute{
								Computed:            true,
								Description:         "The first line of the billing address",
								MarkdownDescription: "The first line of the billing address",
							},
							"address_line2": schema.StringAttribute{
								Computed:            true,
								Description:         "The second line of the billing address",
								MarkdownDescription: "The second line of the billing address",
							},
							"applicable_timezone": schema.StringAttribute{
								Computed: true,
							},
							"billing_configuration": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"document_locale": schema.StringAttribute{
										Computed:            true,
										Description:         "The document locale, specified in the ISO 639-1 format. This field represents the language or locale used for the documents issued by Lago",
										MarkdownDescription: "The document locale, specified in the ISO 639-1 format. This field represents the language or locale used for the documents issued by Lago",
									},
									"invoice_grace_period": schema.Int64Attribute{
										Computed:            true,
										Description:         "The grace period, expressed in days, for the invoice. This period refers to the additional time granted to the customer beyond the invoice due date to adjust usage and line items",
										MarkdownDescription: "The grace period, expressed in days, for the invoice. This period refers to the additional time granted to the customer beyond the invoice due date to adjust usage and line items",
									},
									"payment_provider": schema.StringAttribute{
										Computed:            true,
										Description:         "The payment provider utilized to initiate payments for invoices issued by Lago.\nAccepted values: `stripe`, `adyen`, `gocardless` or null. This field is required if you intend to assign a `provider_customer_id`.",
										MarkdownDescription: "The payment provider utilized to initiate payments for invoices issued by Lago.\nAccepted values: `stripe`, `adyen`, `gocardless` or null. This field is required if you intend to assign a `provider_customer_id`.",
									},
									"payment_provider_code": schema.StringAttribute{
										Computed:            true,
										Description:         "Unique code used to identify a payment provider connection.",
										MarkdownDescription: "Unique code used to identify a payment provider connection.",
									},
									"provider_customer_id": schema.StringAttribute{
										Computed:            true,
										Description:         "The customer ID within the payment provider's system. If this field is not provided, Lago has the option to create a new customer record within the payment provider's system on behalf of the customer",
										MarkdownDescription: "The customer ID within the payment provider's system. If this field is not provided, Lago has the option to create a new customer record within the payment provider's system on behalf of the customer",
									},
									"provider_payment_methods": schema.ListAttribute{
										ElementType:         types.StringType,
										Computed:            true,
										Description:         "Specifies the available payment methods that can be used for this customer when `payment_provider` is set to `stripe`. The `provider_payment_methods` field is an array that allows multiple payment options to be defined. If this field is not explicitly set, the payment methods will be set to `card`. For now, possible values are `card`, `sepa_debit`, `us_bank_account`, `bacs_debit`, `boleto`, `link`, `crypto` and `customer_balance`. Note that when `link` is selected, `card` should also be provided in the array. When `customer_balance` is selected, no other payment can be selected.",
										MarkdownDescription: "Specifies the available payment methods that can be used for this customer when `payment_provider` is set to `stripe`. The `provider_payment_methods` field is an array that allows multiple payment options to be defined. If this field is not explicitly set, the payment methods will be set to `card`. For now, possible values are `card`, `sepa_debit`, `us_bank_account`, `bacs_debit`, `boleto`, `link`, `crypto` and `customer_balance`. Note that when `link` is selected, `card` should also be provided in the array. When `customer_balance` is selected, no other payment can be selected.",
									},
									"sync": schema.BoolAttribute{
										Computed:            true,
										Description:         "Set this field to `true` if you want to create the customer in the payment provider synchronously with the customer creation process in Lago. This option is applicable only when the `provider_customer_id` is `null` and the customer is automatically created in the payment provider through Lago. By default, the value is set to `false`",
										MarkdownDescription: "Set this field to `true` if you want to create the customer in the payment provider synchronously with the customer creation process in Lago. This option is applicable only when the `provider_customer_id` is `null` and the customer is automatically created in the payment provider through Lago. By default, the value is set to `false`",
									},
									"sync_with_provider": schema.BoolAttribute{
										Computed:            true,
										Description:         "Set this field to `true` if you want to create a customer record in the payment provider's system. This option is applicable only when the `provider_customer_id` is null and the `sync_with_provider` field is set to `true`. By default, the value is set to `false`",
										MarkdownDescription: "Set this field to `true` if you want to create a customer record in the payment provider's system. This option is applicable only when the `provider_customer_id` is null and the `sync_with_provider` field is set to `true`. By default, the value is set to `false`",
									},
								},
								CustomType: BillingConfigurationType{
									ObjectType: types.ObjectType{
										AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.",
								MarkdownDescription: "Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.",
							},
							"city": schema.StringAttribute{
								Computed:            true,
								Description:         "The city of the customer's billing address",
								MarkdownDescription: "The city of the customer's billing address",
							},
							"country": schema.StringAttribute{
								Computed: true,
							},
							"created_at": schema.StringAttribute{
								Computed:            true,
								Description:         "The date of the customer creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the customer object was created",
								MarkdownDescription: "The date of the customer creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the customer object was created",
							},
							"currency": schema.StringAttribute{
								Computed: true,
							},
							"customer_type": schema.StringAttribute{
								Computed:            true,
								Description:         "The type of the customer. It can have one of the following values:\n- `company`: the customer is a company.\n- `individual`: the customer is an individual.",
								MarkdownDescription: "The type of the customer. It can have one of the following values:\n- `company`: the customer is a company.\n- `individual`: the customer is an individual.",
							},
							"email": schema.StringAttribute{
								Computed:            true,
								Description:         "The email of the customer",
								MarkdownDescription: "The email of the customer",
							},
							"external_id": schema.StringAttribute{
								Computed:            true,
								Description:         "The customer external unique identifier (provided by your own application)",
								MarkdownDescription: "The customer external unique identifier (provided by your own application)",
							},
							"finalize_zero_amount_invoice": schema.StringAttribute{
								Computed:            true,
								Description:         "Specifies how invoices with a zero total amount should be handled:\n- `inherit`: (Default) Follows the organization-level configuration.\n- `finalize`: Invoices are issued and finalized even if the total amount is zero.\n- `skip`: Invoices with a total amount of zero are not finalized.",
								MarkdownDescription: "Specifies how invoices with a zero total amount should be handled:\n- `inherit`: (Default) Follows the organization-level configuration.\n- `finalize`: Invoices are issued and finalized even if the total amount is zero.\n- `skip`: Invoices with a total amount of zero are not finalized.",
							},
							"firstname": schema.StringAttribute{
								Computed:            true,
								Description:         "First name of the customer",
								MarkdownDescription: "First name of the customer",
							},
							"lago_id": schema.StringAttribute{
								Computed:            true,
								Description:         "Unique identifier assigned to the customer within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the customer's record within the Lago system",
								MarkdownDescription: "Unique identifier assigned to the customer within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the customer's record within the Lago system",
							},
							"lastname": schema.StringAttribute{
								Computed:            true,
								Description:         "Last name of the customer",
								MarkdownDescription: "Last name of the customer",
							},
							"legal_name": schema.StringAttribute{
								Computed:            true,
								Description:         "The legal company name of the customer",
								MarkdownDescription: "The legal company name of the customer",
							},
							"legal_number": schema.StringAttribute{
								Computed:            true,
								Description:         "The legal company number of the customer",
								MarkdownDescription: "The legal company number of the customer",
							},
							"logo_url": schema.StringAttribute{
								Computed:            true,
								Description:         "The logo URL of the customer",
								MarkdownDescription: "The logo URL of the customer",
							},
							"metadata": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"created_at": schema.StringAttribute{
											Computed:            true,
											Description:         "The date of the metadata object creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the metadata object was created",
											MarkdownDescription: "The date of the metadata object creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the metadata object was created",
										},
										"display_in_invoice": schema.BoolAttribute{
											Computed:            true,
											Description:         "Determines whether the item or information should be displayed in the invoice. If set to true, the item or information will be included and visible in the generated invoice. If set to false, the item or information will be excluded and not displayed in the invoice.",
											MarkdownDescription: "Determines whether the item or information should be displayed in the invoice. If set to true, the item or information will be included and visible in the generated invoice. If set to false, the item or information will be excluded and not displayed in the invoice.",
										},
										"key": schema.StringAttribute{
											Computed:            true,
											Description:         "The metadata object key",
											MarkdownDescription: "The metadata object key",
										},
										"lago_id": schema.StringAttribute{
											Computed:            true,
											Description:         "A unique identifier for the customer metadata object in the Lago application. Can be used to update a key-value pair",
											MarkdownDescription: "A unique identifier for the customer metadata object in the Lago application. Can be used to update a key-value pair",
										},
										"value": schema.StringAttribute{
											Computed:            true,
											Description:         "The metadata object value",
											MarkdownDescription: "The metadata object value",
										},
									},
									CustomType: MetadataType{
										ObjectType: types.ObjectType{
											AttrTypes: MetadataValue{}.AttributeTypes(ctx),
										},
									},
								},
								Computed: true,
							},
							"name": schema.StringAttribute{
								Computed:            true,
								Description:         "The full name of the customer",
								MarkdownDescription: "The full name of the customer",
							},
							"net_payment_term": schema.Int64Attribute{
								Computed:            true,
								Description:         "The net payment term, expressed in days, specifies the duration within which a customer is expected to remit payment after the invoice is finalized.",
								MarkdownDescription: "The net payment term, expressed in days, specifies the duration within which a customer is expected to remit payment after the invoice is finalized.",
							},
							"phone": schema.StringAttribute{
								Computed:            true,
								Description:         "The phone number of the customer",
								MarkdownDescription: "The phone number of the customer",
							},
							"sequential_id": schema.Int64Attribute{
								Computed:            true,
								Description:         "The unique identifier assigned to the customer within the organization's scope. This identifier is used to track and reference the customer's order of creation within the organization's system. It ensures that each customer has a distinct `sequential_id`` associated with them, allowing for easy identification and sorting based on the order of creation",
								MarkdownDescription: "The unique identifier assigned to the customer within the organization's scope. This identifier is used to track and reference the customer's order of creation within the organization's system. It ensures that each customer has a distinct `sequential_id`` associated with them, allowing for easy identification and sorting based on the order of creation",
							},
							"shipping_address": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"address_line1": schema.StringAttribute{
										Computed:            true,
										Description:         "The first line of the billing address",
										MarkdownDescription: "The first line of the billing address",
									},
									"address_line2": schema.StringAttribute{
										Computed:            true,
										Description:         "The second line of the billing address",
										MarkdownDescription: "The second line of the billing address",
									},
									"city": schema.StringAttribute{
										Computed:            true,
										Description:         "The city of the customer's billing address",
										MarkdownDescription: "The city of the customer's billing address",
									},
									"country": schema.StringAttribute{
										Computed: true,
									},
									"state": schema.StringAttribute{
										Computed:            true,
										Description:         "The state of the customer's billing address",
										MarkdownDescription: "The state of the customer's billing address",
									},
									"zipcode": schema.StringAttribute{
										Computed:            true,
										Description:         "The zipcode of the customer's billing address",
										MarkdownDescription: "The zipcode of the customer's billing address",
									},
								},
								CustomType: ShippingAddressType{
									ObjectType: types.ObjectType{
										AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.",
								MarkdownDescription: "Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.",
							},
							"skip_invoice_custom_sections": schema.BoolAttribute{
								Computed:            true,
								Description:         "Set to true to exclude all invoice custom sections from PDF generation for this customer only.",
								MarkdownDescription: "Set to true to exclude all invoice custom sections from PDF generation for this customer only.",
							},
							"slug": schema.StringAttribute{
								Computed:            true,
								Description:         "A concise and unique identifier for the customer, formed by combining the Organization's `name`, `id`, and customer's `sequential_id`",
								MarkdownDescription: "A concise and unique identifier for the customer, formed by combining the Organization's `name`, `id`, and customer's `sequential_id`",
							},
							"state": schema.StringAttribute{
								Computed:            true,
								Description:         "The state of the customer's billing address",
								MarkdownDescription: "The state of the customer's billing address",
							},
							"tax_identification_number": schema.StringAttribute{
								Computed:            true,
								Description:         "The tax identification number of the customer",
								MarkdownDescription: "The tax identification number of the customer",
							},
							"timezone": schema.StringAttribute{
								Computed: true,
							},
							"updated_at": schema.StringAttribute{
								Computed:            true,
								Description:         "The date of the customer update, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The update_date provides a standardized and internationally recognized timestamp for when the customer object was updated",
								MarkdownDescription: "The date of the customer update, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The update_date provides a standardized and internationally recognized timestamp for when the customer object was updated",
							},
							"url": schema.StringAttribute{
								Computed:            true,
								Description:         "The custom website URL of the customer",
								MarkdownDescription: "The custom website URL of the customer",
							},
							"zipcode": schema.StringAttribute{
								Computed:            true,
								Description:         "The zipcode of the customer's billing address",
								MarkdownDescription: "The zipcode of the customer's billing address",
							},
						},
						CustomType: CustomerType{
							ObjectType: types.ObjectType{
								AttrTypes: CustomerValue{}.AttributeTypes(ctx),
							},
						},
						Computed: true,
					},
					"email": schema.StringAttribute{
						Required:            true,
						Description:         "The customer's email address used for sending dunning notifications",
						MarkdownDescription: "The customer's email address used for sending dunning notifications",
					},
					"external_customer_id": schema.StringAttribute{
						Required:            true,
						Description:         "The customer external unique identifier (provided by your own application)",
						MarkdownDescription: "The customer external unique identifier (provided by your own application)",
					},
					"invoices": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"coupons_amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "The total sum of all coupons discounted on the invoice. It calculates the cumulative discount amount applied by coupons, expressed in cents.",
									MarkdownDescription: "The total sum of all coupons discounted on the invoice. It calculates the cumulative discount amount applied by coupons, expressed in cents.",
								},
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The date of the invoice creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the invoice object was created",
									MarkdownDescription: "The date of the invoice creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the invoice object was created",
								},
								"credit_notes_amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "The total sum of all credit notes discounted on the invoice. It calculates the cumulative discount amount applied by credit notes, expressed in cents.",
									MarkdownDescription: "The total sum of all credit notes discounted on the invoice. It calculates the cumulative discount amount applied by credit notes, expressed in cents.",
								},
								"currency": schema.StringAttribute{
									Computed: true,
								},
								"fees_amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "The total sum of fees amount in cents. It calculates the cumulative amount of all the fees associated with the invoice, providing a consolidated value.",
									MarkdownDescription: "The total sum of fees amount in cents. It calculates the cumulative amount of all the fees associated with the invoice, providing a consolidated value.",
								},
								"file_url": schema.StringAttribute{
									Computed:            true,
									Description:         "Contains the URL that provides direct access to the invoice PDF file. You can use this URL to download or view the PDF document of the invoice",
									MarkdownDescription: "Contains the URL that provides direct access to the invoice PDF file. You can use this URL to download or view the PDF document of the invoice",
								},
								"invoice_type": schema.StringAttribute{
									Computed:            true,
									Description:         "The type of invoice issued. Possible values are `subscription`, `one-off`, `credit` or `progressive_billing`.",
									MarkdownDescription: "The type of invoice issued. Possible values are `subscription`, `one-off`, `credit` or `progressive_billing`.",
								},
								"issuing_date": schema.StringAttribute{
									Computed:            true,
									Description:         "The date when the invoice was issued. It is provided in the ISO 8601 date format.",
									MarkdownDescription: "The date when the invoice was issued. It is provided in the ISO 8601 date format.",
								},
								"lago_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the fee's record within the Lago system.",
									MarkdownDescription: "Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the fee's record within the Lago system.",
								},
								"net_payment_term": schema.Int64Attribute{
									Computed:            true,
									Description:         "The net payment term, expressed in days, specifies the duration within which a customer is expected to remit payment after the invoice is finalized.",
									MarkdownDescription: "The net payment term, expressed in days, specifies the duration within which a customer is expected to remit payment after the invoice is finalized.",
								},
								"number": schema.StringAttribute{
									Computed:            true,
									Description:         "The unique number assigned to the invoice. This number serves as a distinct identifier for the invoice and helps in differentiating it from other invoices in the system.",
									MarkdownDescription: "The unique number assigned to the invoice. This number serves as a distinct identifier for the invoice and helps in differentiating it from other invoices in the system.",
								},
								"payment_dispute_lost_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The date when the payment dispute was lost. It is expressed in Coordinated Universal Time (UTC).",
									MarkdownDescription: "The date when the payment dispute was lost. It is expressed in Coordinated Universal Time (UTC).",
								},
								"payment_due_date": schema.StringAttribute{
									Computed:            true,
									Description:         "The payment due date for the invoice, specified in the ISO 8601 date format.",
									MarkdownDescription: "The payment due date for the invoice, specified in the ISO 8601 date format.",
								},
								"payment_overdue": schema.BoolAttribute{
									Computed:            true,
									Description:         "Specifies if the payment is considered as overdue.",
									MarkdownDescription: "Specifies if the payment is considered as overdue.",
								},
								"payment_status": schema.StringAttribute{
									Computed:            true,
									Description:         "The status of the payment associated with the invoice. It can have one of the following values:\n- `pending`: the payment is pending, waiting for payment processing in Stripe or when the invoice is emitted but users have not updated the payment status through the endpoint.\n- `succeeded`: the payment of the invoice has been successfully processed.\n- `failed`: the payment of the invoice has failed or encountered an error during processing.",
									MarkdownDescription: "The status of the payment associated with the invoice. It can have one of the following values:\n- `pending`: the payment is pending, waiting for payment processing in Stripe or when the invoice is emitted but users have not updated the payment status through the endpoint.\n- `succeeded`: the payment of the invoice has been successfully processed.\n- `failed`: the payment of the invoice has failed or encountered an error during processing.",
								},
								"prepaid_credit_amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "The total sum of all prepaid credits discounted on the invoice. It calculates the cumulative discount amount applied by prepaid credits, expressed in cents.",
									MarkdownDescription: "The total sum of all prepaid credits discounted on the invoice. It calculates the cumulative discount amount applied by prepaid credits, expressed in cents.",
								},
								"progressive_billing_credit_amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "The usage already billed in previous invoices. Only apply to `progressive_billing` and `subscription` invoices.",
									MarkdownDescription: "The usage already billed in previous invoices. Only apply to `progressive_billing` and `subscription` invoices.",
								},
								"self_billed": schema.BoolAttribute{
									Computed:            true,
									Description:         "Indicates if the invoice is self-billed. Self-billing is a process where an organization creates the invoice on behalf of the partner. This field specifies whether the invoice is self-billed or not.",
									MarkdownDescription: "Indicates if the invoice is self-billed. Self-billing is a process where an organization creates the invoice on behalf of the partner. This field specifies whether the invoice is self-billed or not.",
								},
								"sequential_id": schema.Int64Attribute{
									Computed:            true,
									Description:         "This ID helps in uniquely identifying and organizing the invoices associated with a specific customer. It provides a sequential numbering system specific to the customer, allowing for easy tracking and management of invoices within the customer's context.",
									MarkdownDescription: "This ID helps in uniquely identifying and organizing the invoices associated with a specific customer. It provides a sequential numbering system specific to the customer, allowing for easy tracking and management of invoices within the customer's context.",
								},
								"status": schema.StringAttribute{
									Computed:            true,
									Description:         "The status of the invoice. It indicates the current state of the invoice and can have following values:\n- `draft`: the invoice is in the draft state, waiting for the end of the grace period to be finalized. During this period, events can still be ingested and added to the invoice.\n- `finalized`: the invoice has been issued and finalized. In this state, events cannot be ingested or added to the invoice anymore.\n- `voided`: the invoice has been issued and subsequently voided. In this state, events cannot be ingested or added to the invoice anymore.\n- `pending`: the invoice remains pending until the taxes are fetched from the external provider.\n- `failed`: during an attempt of finalization of the invoice, an error happened. This invoice will have an array of error_details, explaining, in which part of the system an error happened and how it's possible to fix it. This invoice can't be edited or updated, only retried. This action will discard current error_details and will create new ones if the finalization failed again.",
									MarkdownDescription: "The status of the invoice. It indicates the current state of the invoice and can have following values:\n- `draft`: the invoice is in the draft state, waiting for the end of the grace period to be finalized. During this period, events can still be ingested and added to the invoice.\n- `finalized`: the invoice has been issued and finalized. In this state, events cannot be ingested or added to the invoice anymore.\n- `voided`: the invoice has been issued and subsequently voided. In this state, events cannot be ingested or added to the invoice anymore.\n- `pending`: the invoice remains pending until the taxes are fetched from the external provider.\n- `failed`: during an attempt of finalization of the invoice, an error happened. This invoice will have an array of error_details, explaining, in which part of the system an error happened and how it's possible to fix it. This invoice can't be edited or updated, only retried. This action will discard current error_details and will create new ones if the finalization failed again.",
								},
								"sub_total_excluding_taxes_amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "Subtotal amount, excluding taxes, expressed in cents.\nThis field depends on the version number. Here are the definitions based on the version:\n- Version 1: is equal to the sum of `fees_amount_cents`, minus `coupons_amount_cents`, and minus `prepaid_credit_amount_cents`.\n- Version 2: is equal to the `fees_amount_cents`.\n- Version 3 & 4: is equal to the `fees_amount_cents`, minus `coupons_amount_cents`",
									MarkdownDescription: "Subtotal amount, excluding taxes, expressed in cents.\nThis field depends on the version number. Here are the definitions based on the version:\n- Version 1: is equal to the sum of `fees_amount_cents`, minus `coupons_amount_cents`, and minus `prepaid_credit_amount_cents`.\n- Version 2: is equal to the `fees_amount_cents`.\n- Version 3 & 4: is equal to the `fees_amount_cents`, minus `coupons_amount_cents`",
								},
								"sub_total_including_taxes_amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "Subtotal amount, including taxes, expressed in cents.\nThis field depends on the version number. Here are the definitions based on the version:\n- Version 1: is equal to the `total_amount_cents`.\n- Version 2: is equal to the sum of `fees_amount_cents` and `taxes_amount_cents`.\n- Version 3 & 4: is equal to the sum `sub_total_excluding_taxes_amount_cents` and `taxes_amount_cents`",
									MarkdownDescription: "Subtotal amount, including taxes, expressed in cents.\nThis field depends on the version number. Here are the definitions based on the version:\n- Version 1: is equal to the `total_amount_cents`.\n- Version 2: is equal to the sum of `fees_amount_cents` and `taxes_amount_cents`.\n- Version 3 & 4: is equal to the sum `sub_total_excluding_taxes_amount_cents` and `taxes_amount_cents`",
								},
								"taxes_amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "The sum of tax amount associated with the invoice, expressed in cents.",
									MarkdownDescription: "The sum of tax amount associated with the invoice, expressed in cents.",
								},
								"total_amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "The sum of the amount and taxes amount on the invoice, expressed in cents. It calculates the total financial value of the invoice, including both the original amount and any applicable taxes.",
									MarkdownDescription: "The sum of the amount and taxes amount on the invoice, expressed in cents. It calculates the total financial value of the invoice, including both the original amount and any applicable taxes.",
								},
								"updated_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The date of the invoice update, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The update_date provides a standardized and internationally recognized timestamp for when the invoice object was updated",
									MarkdownDescription: "The date of the invoice update, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The update_date provides a standardized and internationally recognized timestamp for when the invoice object was updated",
								},
								"version_number": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: InvoicesType{
								ObjectType: types.ObjectType{
									AttrTypes: InvoicesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed: true,
					},
					"lago_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier of the payment request, created by Lago.",
						MarkdownDescription: "Unique identifier of the payment request, created by Lago.",
					},
					"lago_invoice_ids": schema.ListAttribute{
						ElementType:         types.StringType,
						Required:            true,
						Description:         "A list of Lago IDs for the customer's overdue invoices to start the dunning process",
						MarkdownDescription: "A list of Lago IDs for the customer's overdue invoices to start the dunning process",
					},
					"payment_status": schema.StringAttribute{
						Computed:            true,
						Description:         "The status of the payment associated with the payment request. It can have one of the following values:\n- `pending`: the payment is pending, waiting for payment processing in the payment provider or when the invoice is emitted but users have not updated the payment status through the endpoint.\n- `succeeded`: the payment of the payment request has been successfully processed.\n- `failed`: the payment of the payment request has failed or encountered an error during processing.",
						MarkdownDescription: "The status of the payment associated with the payment request. It can have one of the following values:\n- `pending`: the payment is pending, waiting for payment processing in the payment provider or when the invoice is emitted but users have not updated the payment status through the endpoint.\n- `succeeded`: the payment of the payment request has been successfully processed.\n- `failed`: the payment of the payment request has failed or encountered an error during processing.",
					},
				},
				CustomType: PaymentRequestType{
					ObjectType: types.ObjectType{
						AttrTypes: PaymentRequestValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"payment_requests": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"amount_cents": schema.Int64Attribute{
							Computed:            true,
							Description:         "The sum of the total amounts of all the invoices included in the payment request, expressed in cents.",
							MarkdownDescription: "The sum of the total amounts of all the invoices included in the payment request, expressed in cents.",
						},
						"amount_currency": schema.StringAttribute{
							Computed: true,
						},
						"created_at": schema.StringAttribute{
							Computed:            true,
							Description:         "The date and time when the payment request was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the payment request was initially created.",
							MarkdownDescription: "The date and time when the payment request was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the payment request was initially created.",
						},
						"customer": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"account_type": schema.StringAttribute{
									Computed:            true,
									Description:         "The type of the account. It can have one of the following values:\n- `customer`: the account is a customer.\n- `partner`: the account is a partner.",
									MarkdownDescription: "The type of the account. It can have one of the following values:\n- `customer`: the account is a customer.\n- `partner`: the account is a partner.",
								},
								"address_line1": schema.StringAttribute{
									Computed:            true,
									Description:         "The first line of the billing address",
									MarkdownDescription: "The first line of the billing address",
								},
								"address_line2": schema.StringAttribute{
									Computed:            true,
									Description:         "The second line of the billing address",
									MarkdownDescription: "The second line of the billing address",
								},
								"applicable_timezone": schema.StringAttribute{
									Computed: true,
								},
								"billing_configuration": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"document_locale": schema.StringAttribute{
											Computed:            true,
											Description:         "The document locale, specified in the ISO 639-1 format. This field represents the language or locale used for the documents issued by Lago",
											MarkdownDescription: "The document locale, specified in the ISO 639-1 format. This field represents the language or locale used for the documents issued by Lago",
										},
										"invoice_grace_period": schema.Int64Attribute{
											Computed:            true,
											Description:         "The grace period, expressed in days, for the invoice. This period refers to the additional time granted to the customer beyond the invoice due date to adjust usage and line items",
											MarkdownDescription: "The grace period, expressed in days, for the invoice. This period refers to the additional time granted to the customer beyond the invoice due date to adjust usage and line items",
										},
										"payment_provider": schema.StringAttribute{
											Computed:            true,
											Description:         "The payment provider utilized to initiate payments for invoices issued by Lago.\nAccepted values: `stripe`, `adyen`, `gocardless` or null. This field is required if you intend to assign a `provider_customer_id`.",
											MarkdownDescription: "The payment provider utilized to initiate payments for invoices issued by Lago.\nAccepted values: `stripe`, `adyen`, `gocardless` or null. This field is required if you intend to assign a `provider_customer_id`.",
										},
										"payment_provider_code": schema.StringAttribute{
											Computed:            true,
											Description:         "Unique code used to identify a payment provider connection.",
											MarkdownDescription: "Unique code used to identify a payment provider connection.",
										},
										"provider_customer_id": schema.StringAttribute{
											Computed:            true,
											Description:         "The customer ID within the payment provider's system. If this field is not provided, Lago has the option to create a new customer record within the payment provider's system on behalf of the customer",
											MarkdownDescription: "The customer ID within the payment provider's system. If this field is not provided, Lago has the option to create a new customer record within the payment provider's system on behalf of the customer",
										},
										"provider_payment_methods": schema.ListAttribute{
											ElementType:         types.StringType,
											Computed:            true,
											Description:         "Specifies the available payment methods that can be used for this customer when `payment_provider` is set to `stripe`. The `provider_payment_methods` field is an array that allows multiple payment options to be defined. If this field is not explicitly set, the payment methods will be set to `card`. For now, possible values are `card`, `sepa_debit`, `us_bank_account`, `bacs_debit`, `boleto`, `link`, `crypto` and `customer_balance`. Note that when `link` is selected, `card` should also be provided in the array. When `customer_balance` is selected, no other payment can be selected.",
											MarkdownDescription: "Specifies the available payment methods that can be used for this customer when `payment_provider` is set to `stripe`. The `provider_payment_methods` field is an array that allows multiple payment options to be defined. If this field is not explicitly set, the payment methods will be set to `card`. For now, possible values are `card`, `sepa_debit`, `us_bank_account`, `bacs_debit`, `boleto`, `link`, `crypto` and `customer_balance`. Note that when `link` is selected, `card` should also be provided in the array. When `customer_balance` is selected, no other payment can be selected.",
										},
										"sync": schema.BoolAttribute{
											Computed:            true,
											Description:         "Set this field to `true` if you want to create the customer in the payment provider synchronously with the customer creation process in Lago. This option is applicable only when the `provider_customer_id` is `null` and the customer is automatically created in the payment provider through Lago. By default, the value is set to `false`",
											MarkdownDescription: "Set this field to `true` if you want to create the customer in the payment provider synchronously with the customer creation process in Lago. This option is applicable only when the `provider_customer_id` is `null` and the customer is automatically created in the payment provider through Lago. By default, the value is set to `false`",
										},
										"sync_with_provider": schema.BoolAttribute{
											Computed:            true,
											Description:         "Set this field to `true` if you want to create a customer record in the payment provider's system. This option is applicable only when the `provider_customer_id` is null and the `sync_with_provider` field is set to `true`. By default, the value is set to `false`",
											MarkdownDescription: "Set this field to `true` if you want to create a customer record in the payment provider's system. This option is applicable only when the `provider_customer_id` is null and the `sync_with_provider` field is set to `true`. By default, the value is set to `false`",
										},
									},
									CustomType: BillingConfigurationType{
										ObjectType: types.ObjectType{
											AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.",
									MarkdownDescription: "Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.",
								},
								"city": schema.StringAttribute{
									Computed:            true,
									Description:         "The city of the customer's billing address",
									MarkdownDescription: "The city of the customer's billing address",
								},
								"country": schema.StringAttribute{
									Computed: true,
								},
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The date of the customer creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the customer object was created",
									MarkdownDescription: "The date of the customer creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the customer object was created",
								},
								"currency": schema.StringAttribute{
									Computed: true,
								},
								"customer_type": schema.StringAttribute{
									Computed:            true,
									Description:         "The type of the customer. It can have one of the following values:\n- `company`: the customer is a company.\n- `individual`: the customer is an individual.",
									MarkdownDescription: "The type of the customer. It can have one of the following values:\n- `company`: the customer is a company.\n- `individual`: the customer is an individual.",
								},
								"email": schema.StringAttribute{
									Computed:            true,
									Description:         "The email of the customer",
									MarkdownDescription: "The email of the customer",
								},
								"external_id": schema.StringAttribute{
									Computed:            true,
									Description:         "The customer external unique identifier (provided by your own application)",
									MarkdownDescription: "The customer external unique identifier (provided by your own application)",
								},
								"finalize_zero_amount_invoice": schema.StringAttribute{
									Computed:            true,
									Description:         "Specifies how invoices with a zero total amount should be handled:\n- `inherit`: (Default) Follows the organization-level configuration.\n- `finalize`: Invoices are issued and finalized even if the total amount is zero.\n- `skip`: Invoices with a total amount of zero are not finalized.",
									MarkdownDescription: "Specifies how invoices with a zero total amount should be handled:\n- `inherit`: (Default) Follows the organization-level configuration.\n- `finalize`: Invoices are issued and finalized even if the total amount is zero.\n- `skip`: Invoices with a total amount of zero are not finalized.",
								},
								"firstname": schema.StringAttribute{
									Computed:            true,
									Description:         "First name of the customer",
									MarkdownDescription: "First name of the customer",
								},
								"lago_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique identifier assigned to the customer within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the customer's record within the Lago system",
									MarkdownDescription: "Unique identifier assigned to the customer within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the customer's record within the Lago system",
								},
								"lastname": schema.StringAttribute{
									Computed:            true,
									Description:         "Last name of the customer",
									MarkdownDescription: "Last name of the customer",
								},
								"legal_name": schema.StringAttribute{
									Computed:            true,
									Description:         "The legal company name of the customer",
									MarkdownDescription: "The legal company name of the customer",
								},
								"legal_number": schema.StringAttribute{
									Computed:            true,
									Description:         "The legal company number of the customer",
									MarkdownDescription: "The legal company number of the customer",
								},
								"logo_url": schema.StringAttribute{
									Computed:            true,
									Description:         "The logo URL of the customer",
									MarkdownDescription: "The logo URL of the customer",
								},
								"metadata": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"created_at": schema.StringAttribute{
												Computed:            true,
												Description:         "The date of the metadata object creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the metadata object was created",
												MarkdownDescription: "The date of the metadata object creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the metadata object was created",
											},
											"display_in_invoice": schema.BoolAttribute{
												Computed:            true,
												Description:         "Determines whether the item or information should be displayed in the invoice. If set to true, the item or information will be included and visible in the generated invoice. If set to false, the item or information will be excluded and not displayed in the invoice.",
												MarkdownDescription: "Determines whether the item or information should be displayed in the invoice. If set to true, the item or information will be included and visible in the generated invoice. If set to false, the item or information will be excluded and not displayed in the invoice.",
											},
											"key": schema.StringAttribute{
												Computed:            true,
												Description:         "The metadata object key",
												MarkdownDescription: "The metadata object key",
											},
											"lago_id": schema.StringAttribute{
												Computed:            true,
												Description:         "A unique identifier for the customer metadata object in the Lago application. Can be used to update a key-value pair",
												MarkdownDescription: "A unique identifier for the customer metadata object in the Lago application. Can be used to update a key-value pair",
											},
											"value": schema.StringAttribute{
												Computed:            true,
												Description:         "The metadata object value",
												MarkdownDescription: "The metadata object value",
											},
										},
										CustomType: MetadataType{
											ObjectType: types.ObjectType{
												AttrTypes: MetadataValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed:            true,
									Description:         "The full name of the customer",
									MarkdownDescription: "The full name of the customer",
								},
								"net_payment_term": schema.Int64Attribute{
									Computed:            true,
									Description:         "The net payment term, expressed in days, specifies the duration within which a customer is expected to remit payment after the invoice is finalized.",
									MarkdownDescription: "The net payment term, expressed in days, specifies the duration within which a customer is expected to remit payment after the invoice is finalized.",
								},
								"phone": schema.StringAttribute{
									Computed:            true,
									Description:         "The phone number of the customer",
									MarkdownDescription: "The phone number of the customer",
								},
								"sequential_id": schema.Int64Attribute{
									Computed:            true,
									Description:         "The unique identifier assigned to the customer within the organization's scope. This identifier is used to track and reference the customer's order of creation within the organization's system. It ensures that each customer has a distinct `sequential_id`` associated with them, allowing for easy identification and sorting based on the order of creation",
									MarkdownDescription: "The unique identifier assigned to the customer within the organization's scope. This identifier is used to track and reference the customer's order of creation within the organization's system. It ensures that each customer has a distinct `sequential_id`` associated with them, allowing for easy identification and sorting based on the order of creation",
								},
								"shipping_address": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"address_line1": schema.StringAttribute{
											Computed:            true,
											Description:         "The first line of the billing address",
											MarkdownDescription: "The first line of the billing address",
										},
										"address_line2": schema.StringAttribute{
											Computed:            true,
											Description:         "The second line of the billing address",
											MarkdownDescription: "The second line of the billing address",
										},
										"city": schema.StringAttribute{
											Computed:            true,
											Description:         "The city of the customer's billing address",
											MarkdownDescription: "The city of the customer's billing address",
										},
										"country": schema.StringAttribute{
											Computed: true,
										},
										"state": schema.StringAttribute{
											Computed:            true,
											Description:         "The state of the customer's billing address",
											MarkdownDescription: "The state of the customer's billing address",
										},
										"zipcode": schema.StringAttribute{
											Computed:            true,
											Description:         "The zipcode of the customer's billing address",
											MarkdownDescription: "The zipcode of the customer's billing address",
										},
									},
									CustomType: ShippingAddressType{
										ObjectType: types.ObjectType{
											AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.",
									MarkdownDescription: "Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.",
								},
								"skip_invoice_custom_sections": schema.BoolAttribute{
									Computed:            true,
									Description:         "Set to true to exclude all invoice custom sections from PDF generation for this customer only.",
									MarkdownDescription: "Set to true to exclude all invoice custom sections from PDF generation for this customer only.",
								},
								"slug": schema.StringAttribute{
									Computed:            true,
									Description:         "A concise and unique identifier for the customer, formed by combining the Organization's `name`, `id`, and customer's `sequential_id`",
									MarkdownDescription: "A concise and unique identifier for the customer, formed by combining the Organization's `name`, `id`, and customer's `sequential_id`",
								},
								"state": schema.StringAttribute{
									Computed:            true,
									Description:         "The state of the customer's billing address",
									MarkdownDescription: "The state of the customer's billing address",
								},
								"tax_identification_number": schema.StringAttribute{
									Computed:            true,
									Description:         "The tax identification number of the customer",
									MarkdownDescription: "The tax identification number of the customer",
								},
								"timezone": schema.StringAttribute{
									Computed: true,
								},
								"updated_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The date of the customer update, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The update_date provides a standardized and internationally recognized timestamp for when the customer object was updated",
									MarkdownDescription: "The date of the customer update, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The update_date provides a standardized and internationally recognized timestamp for when the customer object was updated",
								},
								"url": schema.StringAttribute{
									Computed:            true,
									Description:         "The custom website URL of the customer",
									MarkdownDescription: "The custom website URL of the customer",
								},
								"zipcode": schema.StringAttribute{
									Computed:            true,
									Description:         "The zipcode of the customer's billing address",
									MarkdownDescription: "The zipcode of the customer's billing address",
								},
							},
							CustomType: CustomerType{
								ObjectType: types.ObjectType{
									AttrTypes: CustomerValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"email": schema.StringAttribute{
							Computed:            true,
							Description:         "The customer's email address used for sending dunning notifications",
							MarkdownDescription: "The customer's email address used for sending dunning notifications",
						},
						"invoices": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"coupons_amount_cents": schema.Int64Attribute{
										Computed:            true,
										Description:         "The total sum of all coupons discounted on the invoice. It calculates the cumulative discount amount applied by coupons, expressed in cents.",
										MarkdownDescription: "The total sum of all coupons discounted on the invoice. It calculates the cumulative discount amount applied by coupons, expressed in cents.",
									},
									"created_at": schema.StringAttribute{
										Computed:            true,
										Description:         "The date of the invoice creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the invoice object was created",
										MarkdownDescription: "The date of the invoice creation, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The creation_date provides a standardized and internationally recognized timestamp for when the invoice object was created",
									},
									"credit_notes_amount_cents": schema.Int64Attribute{
										Computed:            true,
										Description:         "The total sum of all credit notes discounted on the invoice. It calculates the cumulative discount amount applied by credit notes, expressed in cents.",
										MarkdownDescription: "The total sum of all credit notes discounted on the invoice. It calculates the cumulative discount amount applied by credit notes, expressed in cents.",
									},
									"currency": schema.StringAttribute{
										Computed: true,
									},
									"fees_amount_cents": schema.Int64Attribute{
										Computed:            true,
										Description:         "The total sum of fees amount in cents. It calculates the cumulative amount of all the fees associated with the invoice, providing a consolidated value.",
										MarkdownDescription: "The total sum of fees amount in cents. It calculates the cumulative amount of all the fees associated with the invoice, providing a consolidated value.",
									},
									"file_url": schema.StringAttribute{
										Computed:            true,
										Description:         "Contains the URL that provides direct access to the invoice PDF file. You can use this URL to download or view the PDF document of the invoice",
										MarkdownDescription: "Contains the URL that provides direct access to the invoice PDF file. You can use this URL to download or view the PDF document of the invoice",
									},
									"invoice_type": schema.StringAttribute{
										Computed:            true,
										Description:         "The type of invoice issued. Possible values are `subscription`, `one-off`, `credit` or `progressive_billing`.",
										MarkdownDescription: "The type of invoice issued. Possible values are `subscription`, `one-off`, `credit` or `progressive_billing`.",
									},
									"issuing_date": schema.StringAttribute{
										Computed:            true,
										Description:         "The date when the invoice was issued. It is provided in the ISO 8601 date format.",
										MarkdownDescription: "The date when the invoice was issued. It is provided in the ISO 8601 date format.",
									},
									"lago_id": schema.StringAttribute{
										Computed:            true,
										Description:         "Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the fee's record within the Lago system.",
										MarkdownDescription: "Unique identifier assigned to the fee within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the fee's record within the Lago system.",
									},
									"net_payment_term": schema.Int64Attribute{
										Computed:            true,
										Description:         "The net payment term, expressed in days, specifies the duration within which a customer is expected to remit payment after the invoice is finalized.",
										MarkdownDescription: "The net payment term, expressed in days, specifies the duration within which a customer is expected to remit payment after the invoice is finalized.",
									},
									"number": schema.StringAttribute{
										Computed:            true,
										Description:         "The unique number assigned to the invoice. This number serves as a distinct identifier for the invoice and helps in differentiating it from other invoices in the system.",
										MarkdownDescription: "The unique number assigned to the invoice. This number serves as a distinct identifier for the invoice and helps in differentiating it from other invoices in the system.",
									},
									"payment_dispute_lost_at": schema.StringAttribute{
										Computed:            true,
										Description:         "The date when the payment dispute was lost. It is expressed in Coordinated Universal Time (UTC).",
										MarkdownDescription: "The date when the payment dispute was lost. It is expressed in Coordinated Universal Time (UTC).",
									},
									"payment_due_date": schema.StringAttribute{
										Computed:            true,
										Description:         "The payment due date for the invoice, specified in the ISO 8601 date format.",
										MarkdownDescription: "The payment due date for the invoice, specified in the ISO 8601 date format.",
									},
									"payment_overdue": schema.BoolAttribute{
										Computed:            true,
										Description:         "Specifies if the payment is considered as overdue.",
										MarkdownDescription: "Specifies if the payment is considered as overdue.",
									},
									"payment_status": schema.StringAttribute{
										Computed:            true,
										Description:         "The status of the payment associated with the invoice. It can have one of the following values:\n- `pending`: the payment is pending, waiting for payment processing in Stripe or when the invoice is emitted but users have not updated the payment status through the endpoint.\n- `succeeded`: the payment of the invoice has been successfully processed.\n- `failed`: the payment of the invoice has failed or encountered an error during processing.",
										MarkdownDescription: "The status of the payment associated with the invoice. It can have one of the following values:\n- `pending`: the payment is pending, waiting for payment processing in Stripe or when the invoice is emitted but users have not updated the payment status through the endpoint.\n- `succeeded`: the payment of the invoice has been successfully processed.\n- `failed`: the payment of the invoice has failed or encountered an error during processing.",
									},
									"prepaid_credit_amount_cents": schema.Int64Attribute{
										Computed:            true,
										Description:         "The total sum of all prepaid credits discounted on the invoice. It calculates the cumulative discount amount applied by prepaid credits, expressed in cents.",
										MarkdownDescription: "The total sum of all prepaid credits discounted on the invoice. It calculates the cumulative discount amount applied by prepaid credits, expressed in cents.",
									},
									"progressive_billing_credit_amount_cents": schema.Int64Attribute{
										Computed:            true,
										Description:         "The usage already billed in previous invoices. Only apply to `progressive_billing` and `subscription` invoices.",
										MarkdownDescription: "The usage already billed in previous invoices. Only apply to `progressive_billing` and `subscription` invoices.",
									},
									"self_billed": schema.BoolAttribute{
										Computed:            true,
										Description:         "Indicates if the invoice is self-billed. Self-billing is a process where an organization creates the invoice on behalf of the partner. This field specifies whether the invoice is self-billed or not.",
										MarkdownDescription: "Indicates if the invoice is self-billed. Self-billing is a process where an organization creates the invoice on behalf of the partner. This field specifies whether the invoice is self-billed or not.",
									},
									"sequential_id": schema.Int64Attribute{
										Computed:            true,
										Description:         "This ID helps in uniquely identifying and organizing the invoices associated with a specific customer. It provides a sequential numbering system specific to the customer, allowing for easy tracking and management of invoices within the customer's context.",
										MarkdownDescription: "This ID helps in uniquely identifying and organizing the invoices associated with a specific customer. It provides a sequential numbering system specific to the customer, allowing for easy tracking and management of invoices within the customer's context.",
									},
									"status": schema.StringAttribute{
										Computed:            true,
										Description:         "The status of the invoice. It indicates the current state of the invoice and can have following values:\n- `draft`: the invoice is in the draft state, waiting for the end of the grace period to be finalized. During this period, events can still be ingested and added to the invoice.\n- `finalized`: the invoice has been issued and finalized. In this state, events cannot be ingested or added to the invoice anymore.\n- `voided`: the invoice has been issued and subsequently voided. In this state, events cannot be ingested or added to the invoice anymore.\n- `pending`: the invoice remains pending until the taxes are fetched from the external provider.\n- `failed`: during an attempt of finalization of the invoice, an error happened. This invoice will have an array of error_details, explaining, in which part of the system an error happened and how it's possible to fix it. This invoice can't be edited or updated, only retried. This action will discard current error_details and will create new ones if the finalization failed again.",
										MarkdownDescription: "The status of the invoice. It indicates the current state of the invoice and can have following values:\n- `draft`: the invoice is in the draft state, waiting for the end of the grace period to be finalized. During this period, events can still be ingested and added to the invoice.\n- `finalized`: the invoice has been issued and finalized. In this state, events cannot be ingested or added to the invoice anymore.\n- `voided`: the invoice has been issued and subsequently voided. In this state, events cannot be ingested or added to the invoice anymore.\n- `pending`: the invoice remains pending until the taxes are fetched from the external provider.\n- `failed`: during an attempt of finalization of the invoice, an error happened. This invoice will have an array of error_details, explaining, in which part of the system an error happened and how it's possible to fix it. This invoice can't be edited or updated, only retried. This action will discard current error_details and will create new ones if the finalization failed again.",
									},
									"sub_total_excluding_taxes_amount_cents": schema.Int64Attribute{
										Computed:            true,
										Description:         "Subtotal amount, excluding taxes, expressed in cents.\nThis field depends on the version number. Here are the definitions based on the version:\n- Version 1: is equal to the sum of `fees_amount_cents`, minus `coupons_amount_cents`, and minus `prepaid_credit_amount_cents`.\n- Version 2: is equal to the `fees_amount_cents`.\n- Version 3 & 4: is equal to the `fees_amount_cents`, minus `coupons_amount_cents`",
										MarkdownDescription: "Subtotal amount, excluding taxes, expressed in cents.\nThis field depends on the version number. Here are the definitions based on the version:\n- Version 1: is equal to the sum of `fees_amount_cents`, minus `coupons_amount_cents`, and minus `prepaid_credit_amount_cents`.\n- Version 2: is equal to the `fees_amount_cents`.\n- Version 3 & 4: is equal to the `fees_amount_cents`, minus `coupons_amount_cents`",
									},
									"sub_total_including_taxes_amount_cents": schema.Int64Attribute{
										Computed:            true,
										Description:         "Subtotal amount, including taxes, expressed in cents.\nThis field depends on the version number. Here are the definitions based on the version:\n- Version 1: is equal to the `total_amount_cents`.\n- Version 2: is equal to the sum of `fees_amount_cents` and `taxes_amount_cents`.\n- Version 3 & 4: is equal to the sum `sub_total_excluding_taxes_amount_cents` and `taxes_amount_cents`",
										MarkdownDescription: "Subtotal amount, including taxes, expressed in cents.\nThis field depends on the version number. Here are the definitions based on the version:\n- Version 1: is equal to the `total_amount_cents`.\n- Version 2: is equal to the sum of `fees_amount_cents` and `taxes_amount_cents`.\n- Version 3 & 4: is equal to the sum `sub_total_excluding_taxes_amount_cents` and `taxes_amount_cents`",
									},
									"taxes_amount_cents": schema.Int64Attribute{
										Computed:            true,
										Description:         "The sum of tax amount associated with the invoice, expressed in cents.",
										MarkdownDescription: "The sum of tax amount associated with the invoice, expressed in cents.",
									},
									"total_amount_cents": schema.Int64Attribute{
										Computed:            true,
										Description:         "The sum of the amount and taxes amount on the invoice, expressed in cents. It calculates the total financial value of the invoice, including both the original amount and any applicable taxes.",
										MarkdownDescription: "The sum of the amount and taxes amount on the invoice, expressed in cents. It calculates the total financial value of the invoice, including both the original amount and any applicable taxes.",
									},
									"updated_at": schema.StringAttribute{
										Computed:            true,
										Description:         "The date of the invoice update, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The update_date provides a standardized and internationally recognized timestamp for when the invoice object was updated",
										MarkdownDescription: "The date of the invoice update, represented in ISO 8601 datetime format and expressed in Coordinated Universal Time (UTC). The update_date provides a standardized and internationally recognized timestamp for when the invoice object was updated",
									},
									"version_number": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: InvoicesType{
									ObjectType: types.ObjectType{
										AttrTypes: InvoicesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"lago_id": schema.StringAttribute{
							Computed:            true,
							Description:         "Unique identifier of the payment request, created by Lago.",
							MarkdownDescription: "Unique identifier of the payment request, created by Lago.",
						},
						"payment_status": schema.StringAttribute{
							Computed:            true,
							Description:         "The status of the payment associated with the payment request. It can have one of the following values:\n- `pending`: the payment is pending, waiting for payment processing in the payment provider or when the invoice is emitted but users have not updated the payment status through the endpoint.\n- `succeeded`: the payment of the payment request has been successfully processed.\n- `failed`: the payment of the payment request has failed or encountered an error during processing.",
							MarkdownDescription: "The status of the payment associated with the payment request. It can have one of the following values:\n- `pending`: the payment is pending, waiting for payment processing in the payment provider or when the invoice is emitted but users have not updated the payment status through the endpoint.\n- `succeeded`: the payment of the payment request has been successfully processed.\n- `failed`: the payment of the payment request has failed or encountered an error during processing.",
						},
					},
					CustomType: PaymentRequestsType{
						ObjectType: types.ObjectType{
							AttrTypes: PaymentRequestsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"per_page": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of records per page.",
				MarkdownDescription: "Number of records per page.",
			},
		},
	}
}

type PaymentRequestsModel struct {
	ExternalCustomerId types.String        `tfsdk:"external_customer_id"`
	Meta               MetaValue           `tfsdk:"meta"`
	Page               types.Int64         `tfsdk:"page"`
	PaymentRequest     PaymentRequestValue `tfsdk:"payment_request"`
	PaymentRequests    types.List          `tfsdk:"payment_requests"`
	PerPage            types.Int64         `tfsdk:"per_page"`
}

var _ basetypes.ObjectTypable = MetaType{}

type MetaType struct {
	basetypes.ObjectType
}

func (t MetaType) Equal(o attr.Type) bool {
	other, ok := o.(MetaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetaType) String() string {
	return "MetaType"
}

func (t MetaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	currentPageAttribute, ok := attributes["current_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_page is missing from object`)

		return nil, diags
	}

	currentPageVal, ok := currentPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_page expected to be basetypes.Int64Value, was: %T`, currentPageAttribute))
	}

	nextPageAttribute, ok := attributes["next_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_page is missing from object`)

		return nil, diags
	}

	nextPageVal, ok := nextPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_page expected to be basetypes.Int64Value, was: %T`, nextPageAttribute))
	}

	prevPageAttribute, ok := attributes["prev_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prev_page is missing from object`)

		return nil, diags
	}

	prevPageVal, ok := prevPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prev_page expected to be basetypes.Int64Value, was: %T`, prevPageAttribute))
	}

	totalCountAttribute, ok := attributes["total_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_count is missing from object`)

		return nil, diags
	}

	totalCountVal, ok := totalCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_count expected to be basetypes.Int64Value, was: %T`, totalCountAttribute))
	}

	totalPagesAttribute, ok := attributes["total_pages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_pages is missing from object`)

		return nil, diags
	}

	totalPagesVal, ok := totalPagesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_pages expected to be basetypes.Int64Value, was: %T`, totalPagesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetaValue{
		CurrentPage: currentPageVal,
		NextPage:    nextPageVal,
		PrevPage:    prevPageVal,
		TotalCount:  totalCountVal,
		TotalPages:  totalPagesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetaValueNull() MetaValue {
	return MetaValue{
		state: attr.ValueStateNull,
	}
}

func NewMetaValueUnknown() MetaValue {
	return MetaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetaValue Attribute Value",
				"While creating a MetaValue value, a missing attribute value was detected. "+
					"A MetaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetaValue Attribute Type",
				"While creating a MetaValue value, an invalid attribute value was detected. "+
					"A MetaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetaValue Attribute Value",
				"While creating a MetaValue value, an extra attribute value was detected. "+
					"A MetaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	currentPageAttribute, ok := attributes["current_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_page is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	currentPageVal, ok := currentPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_page expected to be basetypes.Int64Value, was: %T`, currentPageAttribute))
	}

	nextPageAttribute, ok := attributes["next_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_page is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	nextPageVal, ok := nextPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_page expected to be basetypes.Int64Value, was: %T`, nextPageAttribute))
	}

	prevPageAttribute, ok := attributes["prev_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prev_page is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	prevPageVal, ok := prevPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prev_page expected to be basetypes.Int64Value, was: %T`, prevPageAttribute))
	}

	totalCountAttribute, ok := attributes["total_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_count is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	totalCountVal, ok := totalCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_count expected to be basetypes.Int64Value, was: %T`, totalCountAttribute))
	}

	totalPagesAttribute, ok := attributes["total_pages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_pages is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	totalPagesVal, ok := totalPagesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_pages expected to be basetypes.Int64Value, was: %T`, totalPagesAttribute))
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	return MetaValue{
		CurrentPage: currentPageVal,
		NextPage:    nextPageVal,
		PrevPage:    prevPageVal,
		TotalCount:  totalCountVal,
		TotalPages:  totalPagesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetaValue {
	object, diags := NewMetaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetaValueMust(MetaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetaType) ValueType(ctx context.Context) attr.Value {
	return MetaValue{}
}

var _ basetypes.ObjectValuable = MetaValue{}

type MetaValue struct {
	CurrentPage basetypes.Int64Value `tfsdk:"current_page"`
	NextPage    basetypes.Int64Value `tfsdk:"next_page"`
	PrevPage    basetypes.Int64Value `tfsdk:"prev_page"`
	TotalCount  basetypes.Int64Value `tfsdk:"total_count"`
	TotalPages  basetypes.Int64Value `tfsdk:"total_pages"`
	state       attr.ValueState
}

func (v MetaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["current_page"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["next_page"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prev_page"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_pages"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CurrentPage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_page"] = val

		val, err = v.NextPage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_page"] = val

		val, err = v.PrevPage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prev_page"] = val

		val, err = v.TotalCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_count"] = val

		val, err = v.TotalPages.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_pages"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetaValue) String() string {
	return "MetaValue"
}

func (v MetaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"current_page": basetypes.Int64Type{},
		"next_page":    basetypes.Int64Type{},
		"prev_page":    basetypes.Int64Type{},
		"total_count":  basetypes.Int64Type{},
		"total_pages":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"current_page": v.CurrentPage,
			"next_page":    v.NextPage,
			"prev_page":    v.PrevPage,
			"total_count":  v.TotalCount,
			"total_pages":  v.TotalPages,
		})

	return objVal, diags
}

func (v MetaValue) Equal(o attr.Value) bool {
	other, ok := o.(MetaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CurrentPage.Equal(other.CurrentPage) {
		return false
	}

	if !v.NextPage.Equal(other.NextPage) {
		return false
	}

	if !v.PrevPage.Equal(other.PrevPage) {
		return false
	}

	if !v.TotalCount.Equal(other.TotalCount) {
		return false
	}

	if !v.TotalPages.Equal(other.TotalPages) {
		return false
	}

	return true
}

func (v MetaValue) Type(ctx context.Context) attr.Type {
	return MetaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"current_page": basetypes.Int64Type{},
		"next_page":    basetypes.Int64Type{},
		"prev_page":    basetypes.Int64Type{},
		"total_count":  basetypes.Int64Type{},
		"total_pages":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PaymentRequestType{}

type PaymentRequestType struct {
	basetypes.ObjectType
}

func (t PaymentRequestType) Equal(o attr.Type) bool {
	other, ok := o.(PaymentRequestType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PaymentRequestType) String() string {
	return "PaymentRequestType"
}

func (t PaymentRequestType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return nil, diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return nil, diags
	}

	customerVal, ok := customerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.ObjectValue, was: %T`, customerAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return nil, diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	externalCustomerIdAttribute, ok := attributes["external_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_customer_id is missing from object`)

		return nil, diags
	}

	externalCustomerIdVal, ok := externalCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_customer_id expected to be basetypes.StringValue, was: %T`, externalCustomerIdAttribute))
	}

	invoicesAttribute, ok := attributes["invoices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoices is missing from object`)

		return nil, diags
	}

	invoicesVal, ok := invoicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoices expected to be basetypes.ListValue, was: %T`, invoicesAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lagoInvoiceIdsAttribute, ok := attributes["lago_invoice_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_invoice_ids is missing from object`)

		return nil, diags
	}

	lagoInvoiceIdsVal, ok := lagoInvoiceIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_invoice_ids expected to be basetypes.ListValue, was: %T`, lagoInvoiceIdsAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return nil, diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PaymentRequestValue{
		AmountCents:        amountCentsVal,
		AmountCurrency:     amountCurrencyVal,
		CreatedAt:          createdAtVal,
		Customer:           customerVal,
		Email:              emailVal,
		ExternalCustomerId: externalCustomerIdVal,
		Invoices:           invoicesVal,
		LagoId:             lagoIdVal,
		LagoInvoiceIds:     lagoInvoiceIdsVal,
		PaymentStatus:      paymentStatusVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPaymentRequestValueNull() PaymentRequestValue {
	return PaymentRequestValue{
		state: attr.ValueStateNull,
	}
}

func NewPaymentRequestValueUnknown() PaymentRequestValue {
	return PaymentRequestValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPaymentRequestValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PaymentRequestValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PaymentRequestValue Attribute Value",
				"While creating a PaymentRequestValue value, a missing attribute value was detected. "+
					"A PaymentRequestValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PaymentRequestValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PaymentRequestValue Attribute Type",
				"While creating a PaymentRequestValue value, an invalid attribute value was detected. "+
					"A PaymentRequestValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PaymentRequestValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PaymentRequestValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PaymentRequestValue Attribute Value",
				"While creating a PaymentRequestValue value, an extra attribute value was detected. "+
					"A PaymentRequestValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PaymentRequestValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPaymentRequestValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewPaymentRequestValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return NewPaymentRequestValueUnknown(), diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewPaymentRequestValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return NewPaymentRequestValueUnknown(), diags
	}

	customerVal, ok := customerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.ObjectValue, was: %T`, customerAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return NewPaymentRequestValueUnknown(), diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	externalCustomerIdAttribute, ok := attributes["external_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_customer_id is missing from object`)

		return NewPaymentRequestValueUnknown(), diags
	}

	externalCustomerIdVal, ok := externalCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_customer_id expected to be basetypes.StringValue, was: %T`, externalCustomerIdAttribute))
	}

	invoicesAttribute, ok := attributes["invoices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoices is missing from object`)

		return NewPaymentRequestValueUnknown(), diags
	}

	invoicesVal, ok := invoicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoices expected to be basetypes.ListValue, was: %T`, invoicesAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewPaymentRequestValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lagoInvoiceIdsAttribute, ok := attributes["lago_invoice_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_invoice_ids is missing from object`)

		return NewPaymentRequestValueUnknown(), diags
	}

	lagoInvoiceIdsVal, ok := lagoInvoiceIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_invoice_ids expected to be basetypes.ListValue, was: %T`, lagoInvoiceIdsAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return NewPaymentRequestValueUnknown(), diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	if diags.HasError() {
		return NewPaymentRequestValueUnknown(), diags
	}

	return PaymentRequestValue{
		AmountCents:        amountCentsVal,
		AmountCurrency:     amountCurrencyVal,
		CreatedAt:          createdAtVal,
		Customer:           customerVal,
		Email:              emailVal,
		ExternalCustomerId: externalCustomerIdVal,
		Invoices:           invoicesVal,
		LagoId:             lagoIdVal,
		LagoInvoiceIds:     lagoInvoiceIdsVal,
		PaymentStatus:      paymentStatusVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPaymentRequestValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PaymentRequestValue {
	object, diags := NewPaymentRequestValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPaymentRequestValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PaymentRequestType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPaymentRequestValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPaymentRequestValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPaymentRequestValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPaymentRequestValueMust(PaymentRequestValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PaymentRequestType) ValueType(ctx context.Context) attr.Value {
	return PaymentRequestValue{}
}

var _ basetypes.ObjectValuable = PaymentRequestValue{}

type PaymentRequestValue struct {
	AmountCents        basetypes.Int64Value  `tfsdk:"amount_cents"`
	AmountCurrency     basetypes.StringValue `tfsdk:"amount_currency"`
	CreatedAt          basetypes.StringValue `tfsdk:"created_at"`
	Customer           basetypes.ObjectValue `tfsdk:"customer"`
	Email              basetypes.StringValue `tfsdk:"email"`
	ExternalCustomerId basetypes.StringValue `tfsdk:"external_customer_id"`
	Invoices           basetypes.ListValue   `tfsdk:"invoices"`
	LagoId             basetypes.StringValue `tfsdk:"lago_id"`
	LagoInvoiceIds     basetypes.ListValue   `tfsdk:"lago_invoice_ids"`
	PaymentStatus      basetypes.StringValue `tfsdk:"payment_status"`
	state              attr.ValueState
}

func (v PaymentRequestValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["amount_currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer"] = basetypes.ObjectType{
		AttrTypes: CustomerValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_customer_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoices"] = basetypes.ListType{
		ElemType: InvoicesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_invoice_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["payment_status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.AmountCurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_currency"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Customer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer"] = val

		val, err = v.Email.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email"] = val

		val, err = v.ExternalCustomerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_customer_id"] = val

		val, err = v.Invoices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoices"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.LagoInvoiceIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_invoice_ids"] = val

		val, err = v.PaymentStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PaymentRequestValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PaymentRequestValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PaymentRequestValue) String() string {
	return "PaymentRequestValue"
}

func (v PaymentRequestValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var customer basetypes.ObjectValue

	if v.Customer.IsNull() {
		customer = types.ObjectNull(
			CustomerValue{}.AttributeTypes(ctx),
		)
	}

	if v.Customer.IsUnknown() {
		customer = types.ObjectUnknown(
			CustomerValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Customer.IsNull() && !v.Customer.IsUnknown() {
		customer = types.ObjectValueMust(
			CustomerValue{}.AttributeTypes(ctx),
			v.Customer.Attributes(),
		)
	}

	invoices := types.ListValueMust(
		InvoicesType{
			basetypes.ObjectType{
				AttrTypes: InvoicesValue{}.AttributeTypes(ctx),
			},
		},
		v.Invoices.Elements(),
	)

	if v.Invoices.IsNull() {
		invoices = types.ListNull(
			InvoicesType{
				basetypes.ObjectType{
					AttrTypes: InvoicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Invoices.IsUnknown() {
		invoices = types.ListUnknown(
			InvoicesType{
				basetypes.ObjectType{
					AttrTypes: InvoicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var lagoInvoiceIdsVal basetypes.ListValue
	switch {
	case v.LagoInvoiceIds.IsUnknown():
		lagoInvoiceIdsVal = types.ListUnknown(types.StringType)
	case v.LagoInvoiceIds.IsNull():
		lagoInvoiceIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		lagoInvoiceIdsVal, d = types.ListValue(types.StringType, v.LagoInvoiceIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount_cents":    basetypes.Int64Type{},
			"amount_currency": basetypes.StringType{},
			"created_at":      basetypes.StringType{},
			"customer": basetypes.ObjectType{
				AttrTypes: CustomerValue{}.AttributeTypes(ctx),
			},
			"email":                basetypes.StringType{},
			"external_customer_id": basetypes.StringType{},
			"invoices": basetypes.ListType{
				ElemType: InvoicesValue{}.Type(ctx),
			},
			"lago_id": basetypes.StringType{},
			"lago_invoice_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"payment_status": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"created_at":      basetypes.StringType{},
		"customer": basetypes.ObjectType{
			AttrTypes: CustomerValue{}.AttributeTypes(ctx),
		},
		"email":                basetypes.StringType{},
		"external_customer_id": basetypes.StringType{},
		"invoices": basetypes.ListType{
			ElemType: InvoicesValue{}.Type(ctx),
		},
		"lago_id": basetypes.StringType{},
		"lago_invoice_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"payment_status": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":         v.AmountCents,
			"amount_currency":      v.AmountCurrency,
			"created_at":           v.CreatedAt,
			"customer":             customer,
			"email":                v.Email,
			"external_customer_id": v.ExternalCustomerId,
			"invoices":             invoices,
			"lago_id":              v.LagoId,
			"lago_invoice_ids":     lagoInvoiceIdsVal,
			"payment_status":       v.PaymentStatus,
		})

	return objVal, diags
}

func (v PaymentRequestValue) Equal(o attr.Value) bool {
	other, ok := o.(PaymentRequestValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.AmountCurrency.Equal(other.AmountCurrency) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Customer.Equal(other.Customer) {
		return false
	}

	if !v.Email.Equal(other.Email) {
		return false
	}

	if !v.ExternalCustomerId.Equal(other.ExternalCustomerId) {
		return false
	}

	if !v.Invoices.Equal(other.Invoices) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.LagoInvoiceIds.Equal(other.LagoInvoiceIds) {
		return false
	}

	if !v.PaymentStatus.Equal(other.PaymentStatus) {
		return false
	}

	return true
}

func (v PaymentRequestValue) Type(ctx context.Context) attr.Type {
	return PaymentRequestType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PaymentRequestValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"created_at":      basetypes.StringType{},
		"customer": basetypes.ObjectType{
			AttrTypes: CustomerValue{}.AttributeTypes(ctx),
		},
		"email":                basetypes.StringType{},
		"external_customer_id": basetypes.StringType{},
		"invoices": basetypes.ListType{
			ElemType: InvoicesValue{}.Type(ctx),
		},
		"lago_id": basetypes.StringType{},
		"lago_invoice_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"payment_status": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CustomerType{}

type CustomerType struct {
	basetypes.ObjectType
}

func (t CustomerType) Equal(o attr.Type) bool {
	other, ok := o.(CustomerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomerType) String() string {
	return "CustomerType"
}

func (t CustomerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accountTypeAttribute, ok := attributes["account_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_type is missing from object`)

		return nil, diags
	}

	accountTypeVal, ok := accountTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_type expected to be basetypes.StringValue, was: %T`, accountTypeAttribute))
	}

	addressLine1Attribute, ok := attributes["address_line1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line1 is missing from object`)

		return nil, diags
	}

	addressLine1Val, ok := addressLine1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line1 expected to be basetypes.StringValue, was: %T`, addressLine1Attribute))
	}

	addressLine2Attribute, ok := attributes["address_line2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line2 is missing from object`)

		return nil, diags
	}

	addressLine2Val, ok := addressLine2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line2 expected to be basetypes.StringValue, was: %T`, addressLine2Attribute))
	}

	applicableTimezoneAttribute, ok := attributes["applicable_timezone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applicable_timezone is missing from object`)

		return nil, diags
	}

	applicableTimezoneVal, ok := applicableTimezoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applicable_timezone expected to be basetypes.StringValue, was: %T`, applicableTimezoneAttribute))
	}

	billingConfigurationAttribute, ok := attributes["billing_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billing_configuration is missing from object`)

		return nil, diags
	}

	billingConfigurationVal, ok := billingConfigurationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billing_configuration expected to be basetypes.ObjectValue, was: %T`, billingConfigurationAttribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return nil, diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return nil, diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return nil, diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	customerTypeAttribute, ok := attributes["customer_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_type is missing from object`)

		return nil, diags
	}

	customerTypeVal, ok := customerTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_type expected to be basetypes.StringValue, was: %T`, customerTypeAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return nil, diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	externalIdAttribute, ok := attributes["external_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_id is missing from object`)

		return nil, diags
	}

	externalIdVal, ok := externalIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_id expected to be basetypes.StringValue, was: %T`, externalIdAttribute))
	}

	finalizeZeroAmountInvoiceAttribute, ok := attributes["finalize_zero_amount_invoice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`finalize_zero_amount_invoice is missing from object`)

		return nil, diags
	}

	finalizeZeroAmountInvoiceVal, ok := finalizeZeroAmountInvoiceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`finalize_zero_amount_invoice expected to be basetypes.StringValue, was: %T`, finalizeZeroAmountInvoiceAttribute))
	}

	firstnameAttribute, ok := attributes["firstname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`firstname is missing from object`)

		return nil, diags
	}

	firstnameVal, ok := firstnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`firstname expected to be basetypes.StringValue, was: %T`, firstnameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lastnameAttribute, ok := attributes["lastname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lastname is missing from object`)

		return nil, diags
	}

	lastnameVal, ok := lastnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lastname expected to be basetypes.StringValue, was: %T`, lastnameAttribute))
	}

	legalNameAttribute, ok := attributes["legal_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legal_name is missing from object`)

		return nil, diags
	}

	legalNameVal, ok := legalNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legal_name expected to be basetypes.StringValue, was: %T`, legalNameAttribute))
	}

	legalNumberAttribute, ok := attributes["legal_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legal_number is missing from object`)

		return nil, diags
	}

	legalNumberVal, ok := legalNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legal_number expected to be basetypes.StringValue, was: %T`, legalNumberAttribute))
	}

	logoUrlAttribute, ok := attributes["logo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`logo_url is missing from object`)

		return nil, diags
	}

	logoUrlVal, ok := logoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`logo_url expected to be basetypes.StringValue, was: %T`, logoUrlAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ListValue, was: %T`, metadataAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	netPaymentTermAttribute, ok := attributes["net_payment_term"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_payment_term is missing from object`)

		return nil, diags
	}

	netPaymentTermVal, ok := netPaymentTermAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_payment_term expected to be basetypes.Int64Value, was: %T`, netPaymentTermAttribute))
	}

	phoneAttribute, ok := attributes["phone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phone is missing from object`)

		return nil, diags
	}

	phoneVal, ok := phoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phone expected to be basetypes.StringValue, was: %T`, phoneAttribute))
	}

	sequentialIdAttribute, ok := attributes["sequential_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sequential_id is missing from object`)

		return nil, diags
	}

	sequentialIdVal, ok := sequentialIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sequential_id expected to be basetypes.Int64Value, was: %T`, sequentialIdAttribute))
	}

	shippingAddressAttribute, ok := attributes["shipping_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`shipping_address is missing from object`)

		return nil, diags
	}

	shippingAddressVal, ok := shippingAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`shipping_address expected to be basetypes.ObjectValue, was: %T`, shippingAddressAttribute))
	}

	skipInvoiceCustomSectionsAttribute, ok := attributes["skip_invoice_custom_sections"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_invoice_custom_sections is missing from object`)

		return nil, diags
	}

	skipInvoiceCustomSectionsVal, ok := skipInvoiceCustomSectionsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_invoice_custom_sections expected to be basetypes.BoolValue, was: %T`, skipInvoiceCustomSectionsAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	taxIdentificationNumberAttribute, ok := attributes["tax_identification_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_identification_number is missing from object`)

		return nil, diags
	}

	taxIdentificationNumberVal, ok := taxIdentificationNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_identification_number expected to be basetypes.StringValue, was: %T`, taxIdentificationNumberAttribute))
	}

	timezoneAttribute, ok := attributes["timezone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timezone is missing from object`)

		return nil, diags
	}

	timezoneVal, ok := timezoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timezone expected to be basetypes.StringValue, was: %T`, timezoneAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	zipcodeAttribute, ok := attributes["zipcode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zipcode is missing from object`)

		return nil, diags
	}

	zipcodeVal, ok := zipcodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zipcode expected to be basetypes.StringValue, was: %T`, zipcodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomerValue{
		AccountType:               accountTypeVal,
		AddressLine1:              addressLine1Val,
		AddressLine2:              addressLine2Val,
		ApplicableTimezone:        applicableTimezoneVal,
		BillingConfiguration:      billingConfigurationVal,
		City:                      cityVal,
		Country:                   countryVal,
		CreatedAt:                 createdAtVal,
		Currency:                  currencyVal,
		CustomerType:              customerTypeVal,
		Email:                     emailVal,
		ExternalId:                externalIdVal,
		FinalizeZeroAmountInvoice: finalizeZeroAmountInvoiceVal,
		Firstname:                 firstnameVal,
		LagoId:                    lagoIdVal,
		Lastname:                  lastnameVal,
		LegalName:                 legalNameVal,
		LegalNumber:               legalNumberVal,
		LogoUrl:                   logoUrlVal,
		Metadata:                  metadataVal,
		Name:                      nameVal,
		NetPaymentTerm:            netPaymentTermVal,
		Phone:                     phoneVal,
		SequentialId:              sequentialIdVal,
		ShippingAddress:           shippingAddressVal,
		SkipInvoiceCustomSections: skipInvoiceCustomSectionsVal,
		Slug:                      slugVal,
		State:                     stateVal,
		TaxIdentificationNumber:   taxIdentificationNumberVal,
		Timezone:                  timezoneVal,
		UpdatedAt:                 updatedAtVal,
		Url:                       urlVal,
		Zipcode:                   zipcodeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewCustomerValueNull() CustomerValue {
	return CustomerValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomerValueUnknown() CustomerValue {
	return CustomerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomerValue Attribute Value",
				"While creating a CustomerValue value, a missing attribute value was detected. "+
					"A CustomerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomerValue Attribute Type",
				"While creating a CustomerValue value, an invalid attribute value was detected. "+
					"A CustomerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomerValue Attribute Value",
				"While creating a CustomerValue value, an extra attribute value was detected. "+
					"A CustomerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomerValueUnknown(), diags
	}

	accountTypeAttribute, ok := attributes["account_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_type is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	accountTypeVal, ok := accountTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_type expected to be basetypes.StringValue, was: %T`, accountTypeAttribute))
	}

	addressLine1Attribute, ok := attributes["address_line1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line1 is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	addressLine1Val, ok := addressLine1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line1 expected to be basetypes.StringValue, was: %T`, addressLine1Attribute))
	}

	addressLine2Attribute, ok := attributes["address_line2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line2 is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	addressLine2Val, ok := addressLine2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line2 expected to be basetypes.StringValue, was: %T`, addressLine2Attribute))
	}

	applicableTimezoneAttribute, ok := attributes["applicable_timezone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applicable_timezone is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	applicableTimezoneVal, ok := applicableTimezoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applicable_timezone expected to be basetypes.StringValue, was: %T`, applicableTimezoneAttribute))
	}

	billingConfigurationAttribute, ok := attributes["billing_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billing_configuration is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	billingConfigurationVal, ok := billingConfigurationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billing_configuration expected to be basetypes.ObjectValue, was: %T`, billingConfigurationAttribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	customerTypeAttribute, ok := attributes["customer_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_type is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	customerTypeVal, ok := customerTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_type expected to be basetypes.StringValue, was: %T`, customerTypeAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	externalIdAttribute, ok := attributes["external_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_id is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	externalIdVal, ok := externalIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_id expected to be basetypes.StringValue, was: %T`, externalIdAttribute))
	}

	finalizeZeroAmountInvoiceAttribute, ok := attributes["finalize_zero_amount_invoice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`finalize_zero_amount_invoice is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	finalizeZeroAmountInvoiceVal, ok := finalizeZeroAmountInvoiceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`finalize_zero_amount_invoice expected to be basetypes.StringValue, was: %T`, finalizeZeroAmountInvoiceAttribute))
	}

	firstnameAttribute, ok := attributes["firstname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`firstname is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	firstnameVal, ok := firstnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`firstname expected to be basetypes.StringValue, was: %T`, firstnameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lastnameAttribute, ok := attributes["lastname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lastname is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	lastnameVal, ok := lastnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lastname expected to be basetypes.StringValue, was: %T`, lastnameAttribute))
	}

	legalNameAttribute, ok := attributes["legal_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legal_name is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	legalNameVal, ok := legalNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legal_name expected to be basetypes.StringValue, was: %T`, legalNameAttribute))
	}

	legalNumberAttribute, ok := attributes["legal_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legal_number is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	legalNumberVal, ok := legalNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legal_number expected to be basetypes.StringValue, was: %T`, legalNumberAttribute))
	}

	logoUrlAttribute, ok := attributes["logo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`logo_url is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	logoUrlVal, ok := logoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`logo_url expected to be basetypes.StringValue, was: %T`, logoUrlAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ListValue, was: %T`, metadataAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	netPaymentTermAttribute, ok := attributes["net_payment_term"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_payment_term is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	netPaymentTermVal, ok := netPaymentTermAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_payment_term expected to be basetypes.Int64Value, was: %T`, netPaymentTermAttribute))
	}

	phoneAttribute, ok := attributes["phone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phone is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	phoneVal, ok := phoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phone expected to be basetypes.StringValue, was: %T`, phoneAttribute))
	}

	sequentialIdAttribute, ok := attributes["sequential_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sequential_id is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	sequentialIdVal, ok := sequentialIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sequential_id expected to be basetypes.Int64Value, was: %T`, sequentialIdAttribute))
	}

	shippingAddressAttribute, ok := attributes["shipping_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`shipping_address is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	shippingAddressVal, ok := shippingAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`shipping_address expected to be basetypes.ObjectValue, was: %T`, shippingAddressAttribute))
	}

	skipInvoiceCustomSectionsAttribute, ok := attributes["skip_invoice_custom_sections"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_invoice_custom_sections is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	skipInvoiceCustomSectionsVal, ok := skipInvoiceCustomSectionsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_invoice_custom_sections expected to be basetypes.BoolValue, was: %T`, skipInvoiceCustomSectionsAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	taxIdentificationNumberAttribute, ok := attributes["tax_identification_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_identification_number is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	taxIdentificationNumberVal, ok := taxIdentificationNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_identification_number expected to be basetypes.StringValue, was: %T`, taxIdentificationNumberAttribute))
	}

	timezoneAttribute, ok := attributes["timezone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timezone is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	timezoneVal, ok := timezoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timezone expected to be basetypes.StringValue, was: %T`, timezoneAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	zipcodeAttribute, ok := attributes["zipcode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zipcode is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	zipcodeVal, ok := zipcodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zipcode expected to be basetypes.StringValue, was: %T`, zipcodeAttribute))
	}

	if diags.HasError() {
		return NewCustomerValueUnknown(), diags
	}

	return CustomerValue{
		AccountType:               accountTypeVal,
		AddressLine1:              addressLine1Val,
		AddressLine2:              addressLine2Val,
		ApplicableTimezone:        applicableTimezoneVal,
		BillingConfiguration:      billingConfigurationVal,
		City:                      cityVal,
		Country:                   countryVal,
		CreatedAt:                 createdAtVal,
		Currency:                  currencyVal,
		CustomerType:              customerTypeVal,
		Email:                     emailVal,
		ExternalId:                externalIdVal,
		FinalizeZeroAmountInvoice: finalizeZeroAmountInvoiceVal,
		Firstname:                 firstnameVal,
		LagoId:                    lagoIdVal,
		Lastname:                  lastnameVal,
		LegalName:                 legalNameVal,
		LegalNumber:               legalNumberVal,
		LogoUrl:                   logoUrlVal,
		Metadata:                  metadataVal,
		Name:                      nameVal,
		NetPaymentTerm:            netPaymentTermVal,
		Phone:                     phoneVal,
		SequentialId:              sequentialIdVal,
		ShippingAddress:           shippingAddressVal,
		SkipInvoiceCustomSections: skipInvoiceCustomSectionsVal,
		Slug:                      slugVal,
		State:                     stateVal,
		TaxIdentificationNumber:   taxIdentificationNumberVal,
		Timezone:                  timezoneVal,
		UpdatedAt:                 updatedAtVal,
		Url:                       urlVal,
		Zipcode:                   zipcodeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewCustomerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomerValue {
	object, diags := NewCustomerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomerValueMust(CustomerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomerType) ValueType(ctx context.Context) attr.Value {
	return CustomerValue{}
}

var _ basetypes.ObjectValuable = CustomerValue{}

type CustomerValue struct {
	AccountType               basetypes.StringValue `tfsdk:"account_type"`
	AddressLine1              basetypes.StringValue `tfsdk:"address_line1"`
	AddressLine2              basetypes.StringValue `tfsdk:"address_line2"`
	ApplicableTimezone        basetypes.StringValue `tfsdk:"applicable_timezone"`
	BillingConfiguration      basetypes.ObjectValue `tfsdk:"billing_configuration"`
	City                      basetypes.StringValue `tfsdk:"city"`
	Country                   basetypes.StringValue `tfsdk:"country"`
	CreatedAt                 basetypes.StringValue `tfsdk:"created_at"`
	Currency                  basetypes.StringValue `tfsdk:"currency"`
	CustomerType              basetypes.StringValue `tfsdk:"customer_type"`
	Email                     basetypes.StringValue `tfsdk:"email"`
	ExternalId                basetypes.StringValue `tfsdk:"external_id"`
	FinalizeZeroAmountInvoice basetypes.StringValue `tfsdk:"finalize_zero_amount_invoice"`
	Firstname                 basetypes.StringValue `tfsdk:"firstname"`
	LagoId                    basetypes.StringValue `tfsdk:"lago_id"`
	Lastname                  basetypes.StringValue `tfsdk:"lastname"`
	LegalName                 basetypes.StringValue `tfsdk:"legal_name"`
	LegalNumber               basetypes.StringValue `tfsdk:"legal_number"`
	LogoUrl                   basetypes.StringValue `tfsdk:"logo_url"`
	Metadata                  basetypes.ListValue   `tfsdk:"metadata"`
	Name                      basetypes.StringValue `tfsdk:"name"`
	NetPaymentTerm            basetypes.Int64Value  `tfsdk:"net_payment_term"`
	Phone                     basetypes.StringValue `tfsdk:"phone"`
	SequentialId              basetypes.Int64Value  `tfsdk:"sequential_id"`
	ShippingAddress           basetypes.ObjectValue `tfsdk:"shipping_address"`
	SkipInvoiceCustomSections basetypes.BoolValue   `tfsdk:"skip_invoice_custom_sections"`
	Slug                      basetypes.StringValue `tfsdk:"slug"`
	State                     basetypes.StringValue `tfsdk:"state"`
	TaxIdentificationNumber   basetypes.StringValue `tfsdk:"tax_identification_number"`
	Timezone                  basetypes.StringValue `tfsdk:"timezone"`
	UpdatedAt                 basetypes.StringValue `tfsdk:"updated_at"`
	Url                       basetypes.StringValue `tfsdk:"url"`
	Zipcode                   basetypes.StringValue `tfsdk:"zipcode"`
	state                     attr.ValueState
}

func (v CustomerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 33)

	var val tftypes.Value
	var err error

	attrTypes["account_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["address_line1"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["address_line2"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["applicable_timezone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["billing_configuration"] = basetypes.ObjectType{
		AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["city"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["country"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["finalize_zero_amount_invoice"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["firstname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lastname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["legal_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["legal_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["logo_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ListType{
		ElemType: MetadataValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["net_payment_term"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["phone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sequential_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["shipping_address"] = basetypes.ObjectType{
		AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["skip_invoice_custom_sections"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tax_identification_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timezone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["zipcode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 33)

		val, err = v.AccountType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["account_type"] = val

		val, err = v.AddressLine1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_line1"] = val

		val, err = v.AddressLine2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_line2"] = val

		val, err = v.ApplicableTimezone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["applicable_timezone"] = val

		val, err = v.BillingConfiguration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billing_configuration"] = val

		val, err = v.City.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["city"] = val

		val, err = v.Country.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Currency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["currency"] = val

		val, err = v.CustomerType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_type"] = val

		val, err = v.Email.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email"] = val

		val, err = v.ExternalId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_id"] = val

		val, err = v.FinalizeZeroAmountInvoice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["finalize_zero_amount_invoice"] = val

		val, err = v.Firstname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["firstname"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Lastname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lastname"] = val

		val, err = v.LegalName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["legal_name"] = val

		val, err = v.LegalNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["legal_number"] = val

		val, err = v.LogoUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["logo_url"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NetPaymentTerm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["net_payment_term"] = val

		val, err = v.Phone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phone"] = val

		val, err = v.SequentialId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sequential_id"] = val

		val, err = v.ShippingAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["shipping_address"] = val

		val, err = v.SkipInvoiceCustomSections.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["skip_invoice_custom_sections"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.TaxIdentificationNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_identification_number"] = val

		val, err = v.Timezone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timezone"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Zipcode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["zipcode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomerValue) String() string {
	return "CustomerValue"
}

func (v CustomerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var billingConfiguration basetypes.ObjectValue

	if v.BillingConfiguration.IsNull() {
		billingConfiguration = types.ObjectNull(
			BillingConfigurationValue{}.AttributeTypes(ctx),
		)
	}

	if v.BillingConfiguration.IsUnknown() {
		billingConfiguration = types.ObjectUnknown(
			BillingConfigurationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BillingConfiguration.IsNull() && !v.BillingConfiguration.IsUnknown() {
		billingConfiguration = types.ObjectValueMust(
			BillingConfigurationValue{}.AttributeTypes(ctx),
			v.BillingConfiguration.Attributes(),
		)
	}

	metadata := types.ListValueMust(
		MetadataType{
			basetypes.ObjectType{
				AttrTypes: MetadataValue{}.AttributeTypes(ctx),
			},
		},
		v.Metadata.Elements(),
	)

	if v.Metadata.IsNull() {
		metadata = types.ListNull(
			MetadataType{
				basetypes.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ListUnknown(
			MetadataType{
				basetypes.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var shippingAddress basetypes.ObjectValue

	if v.ShippingAddress.IsNull() {
		shippingAddress = types.ObjectNull(
			ShippingAddressValue{}.AttributeTypes(ctx),
		)
	}

	if v.ShippingAddress.IsUnknown() {
		shippingAddress = types.ObjectUnknown(
			ShippingAddressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ShippingAddress.IsNull() && !v.ShippingAddress.IsUnknown() {
		shippingAddress = types.ObjectValueMust(
			ShippingAddressValue{}.AttributeTypes(ctx),
			v.ShippingAddress.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"account_type":        basetypes.StringType{},
		"address_line1":       basetypes.StringType{},
		"address_line2":       basetypes.StringType{},
		"applicable_timezone": basetypes.StringType{},
		"billing_configuration": basetypes.ObjectType{
			AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
		},
		"city":                         basetypes.StringType{},
		"country":                      basetypes.StringType{},
		"created_at":                   basetypes.StringType{},
		"currency":                     basetypes.StringType{},
		"customer_type":                basetypes.StringType{},
		"email":                        basetypes.StringType{},
		"external_id":                  basetypes.StringType{},
		"finalize_zero_amount_invoice": basetypes.StringType{},
		"firstname":                    basetypes.StringType{},
		"lago_id":                      basetypes.StringType{},
		"lastname":                     basetypes.StringType{},
		"legal_name":                   basetypes.StringType{},
		"legal_number":                 basetypes.StringType{},
		"logo_url":                     basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: MetadataValue{}.Type(ctx),
		},
		"name":             basetypes.StringType{},
		"net_payment_term": basetypes.Int64Type{},
		"phone":            basetypes.StringType{},
		"sequential_id":    basetypes.Int64Type{},
		"shipping_address": basetypes.ObjectType{
			AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
		},
		"skip_invoice_custom_sections": basetypes.BoolType{},
		"slug":                         basetypes.StringType{},
		"state":                        basetypes.StringType{},
		"tax_identification_number":    basetypes.StringType{},
		"timezone":                     basetypes.StringType{},
		"updated_at":                   basetypes.StringType{},
		"url":                          basetypes.StringType{},
		"zipcode":                      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"account_type":                 v.AccountType,
			"address_line1":                v.AddressLine1,
			"address_line2":                v.AddressLine2,
			"applicable_timezone":          v.ApplicableTimezone,
			"billing_configuration":        billingConfiguration,
			"city":                         v.City,
			"country":                      v.Country,
			"created_at":                   v.CreatedAt,
			"currency":                     v.Currency,
			"customer_type":                v.CustomerType,
			"email":                        v.Email,
			"external_id":                  v.ExternalId,
			"finalize_zero_amount_invoice": v.FinalizeZeroAmountInvoice,
			"firstname":                    v.Firstname,
			"lago_id":                      v.LagoId,
			"lastname":                     v.Lastname,
			"legal_name":                   v.LegalName,
			"legal_number":                 v.LegalNumber,
			"logo_url":                     v.LogoUrl,
			"metadata":                     metadata,
			"name":                         v.Name,
			"net_payment_term":             v.NetPaymentTerm,
			"phone":                        v.Phone,
			"sequential_id":                v.SequentialId,
			"shipping_address":             shippingAddress,
			"skip_invoice_custom_sections": v.SkipInvoiceCustomSections,
			"slug":                         v.Slug,
			"state":                        v.State,
			"tax_identification_number":    v.TaxIdentificationNumber,
			"timezone":                     v.Timezone,
			"updated_at":                   v.UpdatedAt,
			"url":                          v.Url,
			"zipcode":                      v.Zipcode,
		})

	return objVal, diags
}

func (v CustomerValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccountType.Equal(other.AccountType) {
		return false
	}

	if !v.AddressLine1.Equal(other.AddressLine1) {
		return false
	}

	if !v.AddressLine2.Equal(other.AddressLine2) {
		return false
	}

	if !v.ApplicableTimezone.Equal(other.ApplicableTimezone) {
		return false
	}

	if !v.BillingConfiguration.Equal(other.BillingConfiguration) {
		return false
	}

	if !v.City.Equal(other.City) {
		return false
	}

	if !v.Country.Equal(other.Country) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Currency.Equal(other.Currency) {
		return false
	}

	if !v.CustomerType.Equal(other.CustomerType) {
		return false
	}

	if !v.Email.Equal(other.Email) {
		return false
	}

	if !v.ExternalId.Equal(other.ExternalId) {
		return false
	}

	if !v.FinalizeZeroAmountInvoice.Equal(other.FinalizeZeroAmountInvoice) {
		return false
	}

	if !v.Firstname.Equal(other.Firstname) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Lastname.Equal(other.Lastname) {
		return false
	}

	if !v.LegalName.Equal(other.LegalName) {
		return false
	}

	if !v.LegalNumber.Equal(other.LegalNumber) {
		return false
	}

	if !v.LogoUrl.Equal(other.LogoUrl) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NetPaymentTerm.Equal(other.NetPaymentTerm) {
		return false
	}

	if !v.Phone.Equal(other.Phone) {
		return false
	}

	if !v.SequentialId.Equal(other.SequentialId) {
		return false
	}

	if !v.ShippingAddress.Equal(other.ShippingAddress) {
		return false
	}

	if !v.SkipInvoiceCustomSections.Equal(other.SkipInvoiceCustomSections) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.TaxIdentificationNumber.Equal(other.TaxIdentificationNumber) {
		return false
	}

	if !v.Timezone.Equal(other.Timezone) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Zipcode.Equal(other.Zipcode) {
		return false
	}

	return true
}

func (v CustomerValue) Type(ctx context.Context) attr.Type {
	return CustomerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"account_type":        basetypes.StringType{},
		"address_line1":       basetypes.StringType{},
		"address_line2":       basetypes.StringType{},
		"applicable_timezone": basetypes.StringType{},
		"billing_configuration": basetypes.ObjectType{
			AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
		},
		"city":                         basetypes.StringType{},
		"country":                      basetypes.StringType{},
		"created_at":                   basetypes.StringType{},
		"currency":                     basetypes.StringType{},
		"customer_type":                basetypes.StringType{},
		"email":                        basetypes.StringType{},
		"external_id":                  basetypes.StringType{},
		"finalize_zero_amount_invoice": basetypes.StringType{},
		"firstname":                    basetypes.StringType{},
		"lago_id":                      basetypes.StringType{},
		"lastname":                     basetypes.StringType{},
		"legal_name":                   basetypes.StringType{},
		"legal_number":                 basetypes.StringType{},
		"logo_url":                     basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: MetadataValue{}.Type(ctx),
		},
		"name":             basetypes.StringType{},
		"net_payment_term": basetypes.Int64Type{},
		"phone":            basetypes.StringType{},
		"sequential_id":    basetypes.Int64Type{},
		"shipping_address": basetypes.ObjectType{
			AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
		},
		"skip_invoice_custom_sections": basetypes.BoolType{},
		"slug":                         basetypes.StringType{},
		"state":                        basetypes.StringType{},
		"tax_identification_number":    basetypes.StringType{},
		"timezone":                     basetypes.StringType{},
		"updated_at":                   basetypes.StringType{},
		"url":                          basetypes.StringType{},
		"zipcode":                      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BillingConfigurationType{}

type BillingConfigurationType struct {
	basetypes.ObjectType
}

func (t BillingConfigurationType) Equal(o attr.Type) bool {
	other, ok := o.(BillingConfigurationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BillingConfigurationType) String() string {
	return "BillingConfigurationType"
}

func (t BillingConfigurationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	documentLocaleAttribute, ok := attributes["document_locale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`document_locale is missing from object`)

		return nil, diags
	}

	documentLocaleVal, ok := documentLocaleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`document_locale expected to be basetypes.StringValue, was: %T`, documentLocaleAttribute))
	}

	invoiceGracePeriodAttribute, ok := attributes["invoice_grace_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_grace_period is missing from object`)

		return nil, diags
	}

	invoiceGracePeriodVal, ok := invoiceGracePeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_grace_period expected to be basetypes.Int64Value, was: %T`, invoiceGracePeriodAttribute))
	}

	paymentProviderAttribute, ok := attributes["payment_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_provider is missing from object`)

		return nil, diags
	}

	paymentProviderVal, ok := paymentProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_provider expected to be basetypes.StringValue, was: %T`, paymentProviderAttribute))
	}

	paymentProviderCodeAttribute, ok := attributes["payment_provider_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_provider_code is missing from object`)

		return nil, diags
	}

	paymentProviderCodeVal, ok := paymentProviderCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_provider_code expected to be basetypes.StringValue, was: %T`, paymentProviderCodeAttribute))
	}

	providerCustomerIdAttribute, ok := attributes["provider_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_customer_id is missing from object`)

		return nil, diags
	}

	providerCustomerIdVal, ok := providerCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_customer_id expected to be basetypes.StringValue, was: %T`, providerCustomerIdAttribute))
	}

	providerPaymentMethodsAttribute, ok := attributes["provider_payment_methods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_payment_methods is missing from object`)

		return nil, diags
	}

	providerPaymentMethodsVal, ok := providerPaymentMethodsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_payment_methods expected to be basetypes.ListValue, was: %T`, providerPaymentMethodsAttribute))
	}

	syncAttribute, ok := attributes["sync"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync is missing from object`)

		return nil, diags
	}

	syncVal, ok := syncAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync expected to be basetypes.BoolValue, was: %T`, syncAttribute))
	}

	syncWithProviderAttribute, ok := attributes["sync_with_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync_with_provider is missing from object`)

		return nil, diags
	}

	syncWithProviderVal, ok := syncWithProviderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync_with_provider expected to be basetypes.BoolValue, was: %T`, syncWithProviderAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BillingConfigurationValue{
		DocumentLocale:         documentLocaleVal,
		InvoiceGracePeriod:     invoiceGracePeriodVal,
		PaymentProvider:        paymentProviderVal,
		PaymentProviderCode:    paymentProviderCodeVal,
		ProviderCustomerId:     providerCustomerIdVal,
		ProviderPaymentMethods: providerPaymentMethodsVal,
		Sync:                   syncVal,
		SyncWithProvider:       syncWithProviderVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBillingConfigurationValueNull() BillingConfigurationValue {
	return BillingConfigurationValue{
		state: attr.ValueStateNull,
	}
}

func NewBillingConfigurationValueUnknown() BillingConfigurationValue {
	return BillingConfigurationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBillingConfigurationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BillingConfigurationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BillingConfigurationValue Attribute Value",
				"While creating a BillingConfigurationValue value, a missing attribute value was detected. "+
					"A BillingConfigurationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BillingConfigurationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BillingConfigurationValue Attribute Type",
				"While creating a BillingConfigurationValue value, an invalid attribute value was detected. "+
					"A BillingConfigurationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BillingConfigurationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BillingConfigurationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BillingConfigurationValue Attribute Value",
				"While creating a BillingConfigurationValue value, an extra attribute value was detected. "+
					"A BillingConfigurationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BillingConfigurationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBillingConfigurationValueUnknown(), diags
	}

	documentLocaleAttribute, ok := attributes["document_locale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`document_locale is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	documentLocaleVal, ok := documentLocaleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`document_locale expected to be basetypes.StringValue, was: %T`, documentLocaleAttribute))
	}

	invoiceGracePeriodAttribute, ok := attributes["invoice_grace_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_grace_period is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	invoiceGracePeriodVal, ok := invoiceGracePeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_grace_period expected to be basetypes.Int64Value, was: %T`, invoiceGracePeriodAttribute))
	}

	paymentProviderAttribute, ok := attributes["payment_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_provider is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	paymentProviderVal, ok := paymentProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_provider expected to be basetypes.StringValue, was: %T`, paymentProviderAttribute))
	}

	paymentProviderCodeAttribute, ok := attributes["payment_provider_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_provider_code is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	paymentProviderCodeVal, ok := paymentProviderCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_provider_code expected to be basetypes.StringValue, was: %T`, paymentProviderCodeAttribute))
	}

	providerCustomerIdAttribute, ok := attributes["provider_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_customer_id is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	providerCustomerIdVal, ok := providerCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_customer_id expected to be basetypes.StringValue, was: %T`, providerCustomerIdAttribute))
	}

	providerPaymentMethodsAttribute, ok := attributes["provider_payment_methods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_payment_methods is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	providerPaymentMethodsVal, ok := providerPaymentMethodsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_payment_methods expected to be basetypes.ListValue, was: %T`, providerPaymentMethodsAttribute))
	}

	syncAttribute, ok := attributes["sync"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	syncVal, ok := syncAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync expected to be basetypes.BoolValue, was: %T`, syncAttribute))
	}

	syncWithProviderAttribute, ok := attributes["sync_with_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync_with_provider is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	syncWithProviderVal, ok := syncWithProviderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync_with_provider expected to be basetypes.BoolValue, was: %T`, syncWithProviderAttribute))
	}

	if diags.HasError() {
		return NewBillingConfigurationValueUnknown(), diags
	}

	return BillingConfigurationValue{
		DocumentLocale:         documentLocaleVal,
		InvoiceGracePeriod:     invoiceGracePeriodVal,
		PaymentProvider:        paymentProviderVal,
		PaymentProviderCode:    paymentProviderCodeVal,
		ProviderCustomerId:     providerCustomerIdVal,
		ProviderPaymentMethods: providerPaymentMethodsVal,
		Sync:                   syncVal,
		SyncWithProvider:       syncWithProviderVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBillingConfigurationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BillingConfigurationValue {
	object, diags := NewBillingConfigurationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBillingConfigurationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BillingConfigurationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBillingConfigurationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBillingConfigurationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBillingConfigurationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBillingConfigurationValueMust(BillingConfigurationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BillingConfigurationType) ValueType(ctx context.Context) attr.Value {
	return BillingConfigurationValue{}
}

var _ basetypes.ObjectValuable = BillingConfigurationValue{}

type BillingConfigurationValue struct {
	DocumentLocale         basetypes.StringValue `tfsdk:"document_locale"`
	InvoiceGracePeriod     basetypes.Int64Value  `tfsdk:"invoice_grace_period"`
	PaymentProvider        basetypes.StringValue `tfsdk:"payment_provider"`
	PaymentProviderCode    basetypes.StringValue `tfsdk:"payment_provider_code"`
	ProviderCustomerId     basetypes.StringValue `tfsdk:"provider_customer_id"`
	ProviderPaymentMethods basetypes.ListValue   `tfsdk:"provider_payment_methods"`
	Sync                   basetypes.BoolValue   `tfsdk:"sync"`
	SyncWithProvider       basetypes.BoolValue   `tfsdk:"sync_with_provider"`
	state                  attr.ValueState
}

func (v BillingConfigurationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["document_locale"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_grace_period"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["payment_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["payment_provider_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["provider_customer_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["provider_payment_methods"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["sync"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sync_with_provider"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.DocumentLocale.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["document_locale"] = val

		val, err = v.InvoiceGracePeriod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_grace_period"] = val

		val, err = v.PaymentProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_provider"] = val

		val, err = v.PaymentProviderCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_provider_code"] = val

		val, err = v.ProviderCustomerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provider_customer_id"] = val

		val, err = v.ProviderPaymentMethods.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provider_payment_methods"] = val

		val, err = v.Sync.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sync"] = val

		val, err = v.SyncWithProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sync_with_provider"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BillingConfigurationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BillingConfigurationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BillingConfigurationValue) String() string {
	return "BillingConfigurationValue"
}

func (v BillingConfigurationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var providerPaymentMethodsVal basetypes.ListValue
	switch {
	case v.ProviderPaymentMethods.IsUnknown():
		providerPaymentMethodsVal = types.ListUnknown(types.StringType)
	case v.ProviderPaymentMethods.IsNull():
		providerPaymentMethodsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		providerPaymentMethodsVal, d = types.ListValue(types.StringType, v.ProviderPaymentMethods.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"document_locale":       basetypes.StringType{},
			"invoice_grace_period":  basetypes.Int64Type{},
			"payment_provider":      basetypes.StringType{},
			"payment_provider_code": basetypes.StringType{},
			"provider_customer_id":  basetypes.StringType{},
			"provider_payment_methods": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sync":               basetypes.BoolType{},
			"sync_with_provider": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"document_locale":       basetypes.StringType{},
		"invoice_grace_period":  basetypes.Int64Type{},
		"payment_provider":      basetypes.StringType{},
		"payment_provider_code": basetypes.StringType{},
		"provider_customer_id":  basetypes.StringType{},
		"provider_payment_methods": basetypes.ListType{
			ElemType: types.StringType,
		},
		"sync":               basetypes.BoolType{},
		"sync_with_provider": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"document_locale":          v.DocumentLocale,
			"invoice_grace_period":     v.InvoiceGracePeriod,
			"payment_provider":         v.PaymentProvider,
			"payment_provider_code":    v.PaymentProviderCode,
			"provider_customer_id":     v.ProviderCustomerId,
			"provider_payment_methods": providerPaymentMethodsVal,
			"sync":                     v.Sync,
			"sync_with_provider":       v.SyncWithProvider,
		})

	return objVal, diags
}

func (v BillingConfigurationValue) Equal(o attr.Value) bool {
	other, ok := o.(BillingConfigurationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DocumentLocale.Equal(other.DocumentLocale) {
		return false
	}

	if !v.InvoiceGracePeriod.Equal(other.InvoiceGracePeriod) {
		return false
	}

	if !v.PaymentProvider.Equal(other.PaymentProvider) {
		return false
	}

	if !v.PaymentProviderCode.Equal(other.PaymentProviderCode) {
		return false
	}

	if !v.ProviderCustomerId.Equal(other.ProviderCustomerId) {
		return false
	}

	if !v.ProviderPaymentMethods.Equal(other.ProviderPaymentMethods) {
		return false
	}

	if !v.Sync.Equal(other.Sync) {
		return false
	}

	if !v.SyncWithProvider.Equal(other.SyncWithProvider) {
		return false
	}

	return true
}

func (v BillingConfigurationValue) Type(ctx context.Context) attr.Type {
	return BillingConfigurationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BillingConfigurationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"document_locale":       basetypes.StringType{},
		"invoice_grace_period":  basetypes.Int64Type{},
		"payment_provider":      basetypes.StringType{},
		"payment_provider_code": basetypes.StringType{},
		"provider_customer_id":  basetypes.StringType{},
		"provider_payment_methods": basetypes.ListType{
			ElemType: types.StringType,
		},
		"sync":               basetypes.BoolType{},
		"sync_with_provider": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	displayInInvoiceAttribute, ok := attributes["display_in_invoice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_in_invoice is missing from object`)

		return nil, diags
	}

	displayInInvoiceVal, ok := displayInInvoiceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_in_invoice expected to be basetypes.BoolValue, was: %T`, displayInInvoiceAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		CreatedAt:        createdAtVal,
		DisplayInInvoice: displayInInvoiceVal,
		Key:              keyVal,
		LagoId:           lagoIdVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	displayInInvoiceAttribute, ok := attributes["display_in_invoice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_in_invoice is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	displayInInvoiceVal, ok := displayInInvoiceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_in_invoice expected to be basetypes.BoolValue, was: %T`, displayInInvoiceAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		CreatedAt:        createdAtVal,
		DisplayInInvoice: displayInInvoiceVal,
		Key:              keyVal,
		LagoId:           lagoIdVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	CreatedAt        basetypes.StringValue `tfsdk:"created_at"`
	DisplayInInvoice basetypes.BoolValue   `tfsdk:"display_in_invoice"`
	Key              basetypes.StringValue `tfsdk:"key"`
	LagoId           basetypes.StringValue `tfsdk:"lago_id"`
	Value            basetypes.StringValue `tfsdk:"value"`
	state            attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display_in_invoice"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.DisplayInInvoice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_in_invoice"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created_at":         basetypes.StringType{},
		"display_in_invoice": basetypes.BoolType{},
		"key":                basetypes.StringType{},
		"lago_id":            basetypes.StringType{},
		"value":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at":         v.CreatedAt,
			"display_in_invoice": v.DisplayInInvoice,
			"key":                v.Key,
			"lago_id":            v.LagoId,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.DisplayInInvoice.Equal(other.DisplayInInvoice) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at":         basetypes.StringType{},
		"display_in_invoice": basetypes.BoolType{},
		"key":                basetypes.StringType{},
		"lago_id":            basetypes.StringType{},
		"value":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ShippingAddressType{}

type ShippingAddressType struct {
	basetypes.ObjectType
}

func (t ShippingAddressType) Equal(o attr.Type) bool {
	other, ok := o.(ShippingAddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ShippingAddressType) String() string {
	return "ShippingAddressType"
}

func (t ShippingAddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressLine1Attribute, ok := attributes["address_line1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line1 is missing from object`)

		return nil, diags
	}

	addressLine1Val, ok := addressLine1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line1 expected to be basetypes.StringValue, was: %T`, addressLine1Attribute))
	}

	addressLine2Attribute, ok := attributes["address_line2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line2 is missing from object`)

		return nil, diags
	}

	addressLine2Val, ok := addressLine2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line2 expected to be basetypes.StringValue, was: %T`, addressLine2Attribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return nil, diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return nil, diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	zipcodeAttribute, ok := attributes["zipcode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zipcode is missing from object`)

		return nil, diags
	}

	zipcodeVal, ok := zipcodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zipcode expected to be basetypes.StringValue, was: %T`, zipcodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ShippingAddressValue{
		AddressLine1: addressLine1Val,
		AddressLine2: addressLine2Val,
		City:         cityVal,
		Country:      countryVal,
		State:        stateVal,
		Zipcode:      zipcodeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewShippingAddressValueNull() ShippingAddressValue {
	return ShippingAddressValue{
		state: attr.ValueStateNull,
	}
}

func NewShippingAddressValueUnknown() ShippingAddressValue {
	return ShippingAddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewShippingAddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ShippingAddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ShippingAddressValue Attribute Value",
				"While creating a ShippingAddressValue value, a missing attribute value was detected. "+
					"A ShippingAddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ShippingAddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ShippingAddressValue Attribute Type",
				"While creating a ShippingAddressValue value, an invalid attribute value was detected. "+
					"A ShippingAddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ShippingAddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ShippingAddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ShippingAddressValue Attribute Value",
				"While creating a ShippingAddressValue value, an extra attribute value was detected. "+
					"A ShippingAddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ShippingAddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewShippingAddressValueUnknown(), diags
	}

	addressLine1Attribute, ok := attributes["address_line1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line1 is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	addressLine1Val, ok := addressLine1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line1 expected to be basetypes.StringValue, was: %T`, addressLine1Attribute))
	}

	addressLine2Attribute, ok := attributes["address_line2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line2 is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	addressLine2Val, ok := addressLine2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line2 expected to be basetypes.StringValue, was: %T`, addressLine2Attribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	zipcodeAttribute, ok := attributes["zipcode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zipcode is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	zipcodeVal, ok := zipcodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zipcode expected to be basetypes.StringValue, was: %T`, zipcodeAttribute))
	}

	if diags.HasError() {
		return NewShippingAddressValueUnknown(), diags
	}

	return ShippingAddressValue{
		AddressLine1: addressLine1Val,
		AddressLine2: addressLine2Val,
		City:         cityVal,
		Country:      countryVal,
		State:        stateVal,
		Zipcode:      zipcodeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewShippingAddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ShippingAddressValue {
	object, diags := NewShippingAddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewShippingAddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ShippingAddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewShippingAddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewShippingAddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewShippingAddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewShippingAddressValueMust(ShippingAddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ShippingAddressType) ValueType(ctx context.Context) attr.Value {
	return ShippingAddressValue{}
}

var _ basetypes.ObjectValuable = ShippingAddressValue{}

type ShippingAddressValue struct {
	AddressLine1 basetypes.StringValue `tfsdk:"address_line1"`
	AddressLine2 basetypes.StringValue `tfsdk:"address_line2"`
	City         basetypes.StringValue `tfsdk:"city"`
	Country      basetypes.StringValue `tfsdk:"country"`
	State        basetypes.StringValue `tfsdk:"state"`
	Zipcode      basetypes.StringValue `tfsdk:"zipcode"`
	state        attr.ValueState
}

func (v ShippingAddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["address_line1"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["address_line2"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["city"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["country"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["zipcode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.AddressLine1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_line1"] = val

		val, err = v.AddressLine2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_line2"] = val

		val, err = v.City.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["city"] = val

		val, err = v.Country.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Zipcode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["zipcode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ShippingAddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ShippingAddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ShippingAddressValue) String() string {
	return "ShippingAddressValue"
}

func (v ShippingAddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"address_line1": basetypes.StringType{},
		"address_line2": basetypes.StringType{},
		"city":          basetypes.StringType{},
		"country":       basetypes.StringType{},
		"state":         basetypes.StringType{},
		"zipcode":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_line1": v.AddressLine1,
			"address_line2": v.AddressLine2,
			"city":          v.City,
			"country":       v.Country,
			"state":         v.State,
			"zipcode":       v.Zipcode,
		})

	return objVal, diags
}

func (v ShippingAddressValue) Equal(o attr.Value) bool {
	other, ok := o.(ShippingAddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressLine1.Equal(other.AddressLine1) {
		return false
	}

	if !v.AddressLine2.Equal(other.AddressLine2) {
		return false
	}

	if !v.City.Equal(other.City) {
		return false
	}

	if !v.Country.Equal(other.Country) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Zipcode.Equal(other.Zipcode) {
		return false
	}

	return true
}

func (v ShippingAddressValue) Type(ctx context.Context) attr.Type {
	return ShippingAddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ShippingAddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_line1": basetypes.StringType{},
		"address_line2": basetypes.StringType{},
		"city":          basetypes.StringType{},
		"country":       basetypes.StringType{},
		"state":         basetypes.StringType{},
		"zipcode":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InvoicesType{}

type InvoicesType struct {
	basetypes.ObjectType
}

func (t InvoicesType) Equal(o attr.Type) bool {
	other, ok := o.(InvoicesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InvoicesType) String() string {
	return "InvoicesType"
}

func (t InvoicesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	couponsAmountCentsAttribute, ok := attributes["coupons_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coupons_amount_cents is missing from object`)

		return nil, diags
	}

	couponsAmountCentsVal, ok := couponsAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coupons_amount_cents expected to be basetypes.Int64Value, was: %T`, couponsAmountCentsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	creditNotesAmountCentsAttribute, ok := attributes["credit_notes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credit_notes_amount_cents is missing from object`)

		return nil, diags
	}

	creditNotesAmountCentsVal, ok := creditNotesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credit_notes_amount_cents expected to be basetypes.Int64Value, was: %T`, creditNotesAmountCentsAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return nil, diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	feesAmountCentsAttribute, ok := attributes["fees_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fees_amount_cents is missing from object`)

		return nil, diags
	}

	feesAmountCentsVal, ok := feesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fees_amount_cents expected to be basetypes.Int64Value, was: %T`, feesAmountCentsAttribute))
	}

	fileUrlAttribute, ok := attributes["file_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file_url is missing from object`)

		return nil, diags
	}

	fileUrlVal, ok := fileUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file_url expected to be basetypes.StringValue, was: %T`, fileUrlAttribute))
	}

	invoiceTypeAttribute, ok := attributes["invoice_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_type is missing from object`)

		return nil, diags
	}

	invoiceTypeVal, ok := invoiceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_type expected to be basetypes.StringValue, was: %T`, invoiceTypeAttribute))
	}

	issuingDateAttribute, ok := attributes["issuing_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`issuing_date is missing from object`)

		return nil, diags
	}

	issuingDateVal, ok := issuingDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`issuing_date expected to be basetypes.StringValue, was: %T`, issuingDateAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	netPaymentTermAttribute, ok := attributes["net_payment_term"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_payment_term is missing from object`)

		return nil, diags
	}

	netPaymentTermVal, ok := netPaymentTermAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_payment_term expected to be basetypes.Int64Value, was: %T`, netPaymentTermAttribute))
	}

	numberAttribute, ok := attributes["number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number is missing from object`)

		return nil, diags
	}

	numberVal, ok := numberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number expected to be basetypes.StringValue, was: %T`, numberAttribute))
	}

	paymentDisputeLostAtAttribute, ok := attributes["payment_dispute_lost_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_dispute_lost_at is missing from object`)

		return nil, diags
	}

	paymentDisputeLostAtVal, ok := paymentDisputeLostAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_dispute_lost_at expected to be basetypes.StringValue, was: %T`, paymentDisputeLostAtAttribute))
	}

	paymentDueDateAttribute, ok := attributes["payment_due_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_due_date is missing from object`)

		return nil, diags
	}

	paymentDueDateVal, ok := paymentDueDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_due_date expected to be basetypes.StringValue, was: %T`, paymentDueDateAttribute))
	}

	paymentOverdueAttribute, ok := attributes["payment_overdue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_overdue is missing from object`)

		return nil, diags
	}

	paymentOverdueVal, ok := paymentOverdueAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_overdue expected to be basetypes.BoolValue, was: %T`, paymentOverdueAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return nil, diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	prepaidCreditAmountCentsAttribute, ok := attributes["prepaid_credit_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepaid_credit_amount_cents is missing from object`)

		return nil, diags
	}

	prepaidCreditAmountCentsVal, ok := prepaidCreditAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepaid_credit_amount_cents expected to be basetypes.Int64Value, was: %T`, prepaidCreditAmountCentsAttribute))
	}

	progressiveBillingCreditAmountCentsAttribute, ok := attributes["progressive_billing_credit_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progressive_billing_credit_amount_cents is missing from object`)

		return nil, diags
	}

	progressiveBillingCreditAmountCentsVal, ok := progressiveBillingCreditAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progressive_billing_credit_amount_cents expected to be basetypes.Int64Value, was: %T`, progressiveBillingCreditAmountCentsAttribute))
	}

	selfBilledAttribute, ok := attributes["self_billed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self_billed is missing from object`)

		return nil, diags
	}

	selfBilledVal, ok := selfBilledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self_billed expected to be basetypes.BoolValue, was: %T`, selfBilledAttribute))
	}

	sequentialIdAttribute, ok := attributes["sequential_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sequential_id is missing from object`)

		return nil, diags
	}

	sequentialIdVal, ok := sequentialIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sequential_id expected to be basetypes.Int64Value, was: %T`, sequentialIdAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	subTotalExcludingTaxesAmountCentsAttribute, ok := attributes["sub_total_excluding_taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_total_excluding_taxes_amount_cents is missing from object`)

		return nil, diags
	}

	subTotalExcludingTaxesAmountCentsVal, ok := subTotalExcludingTaxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_total_excluding_taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, subTotalExcludingTaxesAmountCentsAttribute))
	}

	subTotalIncludingTaxesAmountCentsAttribute, ok := attributes["sub_total_including_taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_total_including_taxes_amount_cents is missing from object`)

		return nil, diags
	}

	subTotalIncludingTaxesAmountCentsVal, ok := subTotalIncludingTaxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_total_including_taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, subTotalIncludingTaxesAmountCentsAttribute))
	}

	taxesAmountCentsAttribute, ok := attributes["taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes_amount_cents is missing from object`)

		return nil, diags
	}

	taxesAmountCentsVal, ok := taxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, taxesAmountCentsAttribute))
	}

	totalAmountCentsAttribute, ok := attributes["total_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_amount_cents is missing from object`)

		return nil, diags
	}

	totalAmountCentsVal, ok := totalAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_amount_cents expected to be basetypes.Int64Value, was: %T`, totalAmountCentsAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	versionNumberAttribute, ok := attributes["version_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version_number is missing from object`)

		return nil, diags
	}

	versionNumberVal, ok := versionNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version_number expected to be basetypes.Int64Value, was: %T`, versionNumberAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InvoicesValue{
		CouponsAmountCents:                  couponsAmountCentsVal,
		CreatedAt:                           createdAtVal,
		CreditNotesAmountCents:              creditNotesAmountCentsVal,
		Currency:                            currencyVal,
		FeesAmountCents:                     feesAmountCentsVal,
		FileUrl:                             fileUrlVal,
		InvoiceType:                         invoiceTypeVal,
		IssuingDate:                         issuingDateVal,
		LagoId:                              lagoIdVal,
		NetPaymentTerm:                      netPaymentTermVal,
		Number:                              numberVal,
		PaymentDisputeLostAt:                paymentDisputeLostAtVal,
		PaymentDueDate:                      paymentDueDateVal,
		PaymentOverdue:                      paymentOverdueVal,
		PaymentStatus:                       paymentStatusVal,
		PrepaidCreditAmountCents:            prepaidCreditAmountCentsVal,
		ProgressiveBillingCreditAmountCents: progressiveBillingCreditAmountCentsVal,
		SelfBilled:                          selfBilledVal,
		SequentialId:                        sequentialIdVal,
		Status:                              statusVal,
		SubTotalExcludingTaxesAmountCents:   subTotalExcludingTaxesAmountCentsVal,
		SubTotalIncludingTaxesAmountCents:   subTotalIncludingTaxesAmountCentsVal,
		TaxesAmountCents:                    taxesAmountCentsVal,
		TotalAmountCents:                    totalAmountCentsVal,
		UpdatedAt:                           updatedAtVal,
		VersionNumber:                       versionNumberVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewInvoicesValueNull() InvoicesValue {
	return InvoicesValue{
		state: attr.ValueStateNull,
	}
}

func NewInvoicesValueUnknown() InvoicesValue {
	return InvoicesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInvoicesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InvoicesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InvoicesValue Attribute Value",
				"While creating a InvoicesValue value, a missing attribute value was detected. "+
					"A InvoicesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InvoicesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InvoicesValue Attribute Type",
				"While creating a InvoicesValue value, an invalid attribute value was detected. "+
					"A InvoicesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InvoicesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InvoicesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InvoicesValue Attribute Value",
				"While creating a InvoicesValue value, an extra attribute value was detected. "+
					"A InvoicesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InvoicesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInvoicesValueUnknown(), diags
	}

	couponsAmountCentsAttribute, ok := attributes["coupons_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coupons_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	couponsAmountCentsVal, ok := couponsAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coupons_amount_cents expected to be basetypes.Int64Value, was: %T`, couponsAmountCentsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	creditNotesAmountCentsAttribute, ok := attributes["credit_notes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credit_notes_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	creditNotesAmountCentsVal, ok := creditNotesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credit_notes_amount_cents expected to be basetypes.Int64Value, was: %T`, creditNotesAmountCentsAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	feesAmountCentsAttribute, ok := attributes["fees_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fees_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	feesAmountCentsVal, ok := feesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fees_amount_cents expected to be basetypes.Int64Value, was: %T`, feesAmountCentsAttribute))
	}

	fileUrlAttribute, ok := attributes["file_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file_url is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	fileUrlVal, ok := fileUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file_url expected to be basetypes.StringValue, was: %T`, fileUrlAttribute))
	}

	invoiceTypeAttribute, ok := attributes["invoice_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_type is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	invoiceTypeVal, ok := invoiceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_type expected to be basetypes.StringValue, was: %T`, invoiceTypeAttribute))
	}

	issuingDateAttribute, ok := attributes["issuing_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`issuing_date is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	issuingDateVal, ok := issuingDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`issuing_date expected to be basetypes.StringValue, was: %T`, issuingDateAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	netPaymentTermAttribute, ok := attributes["net_payment_term"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_payment_term is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	netPaymentTermVal, ok := netPaymentTermAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_payment_term expected to be basetypes.Int64Value, was: %T`, netPaymentTermAttribute))
	}

	numberAttribute, ok := attributes["number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	numberVal, ok := numberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number expected to be basetypes.StringValue, was: %T`, numberAttribute))
	}

	paymentDisputeLostAtAttribute, ok := attributes["payment_dispute_lost_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_dispute_lost_at is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	paymentDisputeLostAtVal, ok := paymentDisputeLostAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_dispute_lost_at expected to be basetypes.StringValue, was: %T`, paymentDisputeLostAtAttribute))
	}

	paymentDueDateAttribute, ok := attributes["payment_due_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_due_date is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	paymentDueDateVal, ok := paymentDueDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_due_date expected to be basetypes.StringValue, was: %T`, paymentDueDateAttribute))
	}

	paymentOverdueAttribute, ok := attributes["payment_overdue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_overdue is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	paymentOverdueVal, ok := paymentOverdueAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_overdue expected to be basetypes.BoolValue, was: %T`, paymentOverdueAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	prepaidCreditAmountCentsAttribute, ok := attributes["prepaid_credit_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepaid_credit_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	prepaidCreditAmountCentsVal, ok := prepaidCreditAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepaid_credit_amount_cents expected to be basetypes.Int64Value, was: %T`, prepaidCreditAmountCentsAttribute))
	}

	progressiveBillingCreditAmountCentsAttribute, ok := attributes["progressive_billing_credit_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progressive_billing_credit_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	progressiveBillingCreditAmountCentsVal, ok := progressiveBillingCreditAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progressive_billing_credit_amount_cents expected to be basetypes.Int64Value, was: %T`, progressiveBillingCreditAmountCentsAttribute))
	}

	selfBilledAttribute, ok := attributes["self_billed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self_billed is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	selfBilledVal, ok := selfBilledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self_billed expected to be basetypes.BoolValue, was: %T`, selfBilledAttribute))
	}

	sequentialIdAttribute, ok := attributes["sequential_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sequential_id is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	sequentialIdVal, ok := sequentialIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sequential_id expected to be basetypes.Int64Value, was: %T`, sequentialIdAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	subTotalExcludingTaxesAmountCentsAttribute, ok := attributes["sub_total_excluding_taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_total_excluding_taxes_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	subTotalExcludingTaxesAmountCentsVal, ok := subTotalExcludingTaxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_total_excluding_taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, subTotalExcludingTaxesAmountCentsAttribute))
	}

	subTotalIncludingTaxesAmountCentsAttribute, ok := attributes["sub_total_including_taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_total_including_taxes_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	subTotalIncludingTaxesAmountCentsVal, ok := subTotalIncludingTaxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_total_including_taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, subTotalIncludingTaxesAmountCentsAttribute))
	}

	taxesAmountCentsAttribute, ok := attributes["taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	taxesAmountCentsVal, ok := taxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, taxesAmountCentsAttribute))
	}

	totalAmountCentsAttribute, ok := attributes["total_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	totalAmountCentsVal, ok := totalAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_amount_cents expected to be basetypes.Int64Value, was: %T`, totalAmountCentsAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	versionNumberAttribute, ok := attributes["version_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version_number is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	versionNumberVal, ok := versionNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version_number expected to be basetypes.Int64Value, was: %T`, versionNumberAttribute))
	}

	if diags.HasError() {
		return NewInvoicesValueUnknown(), diags
	}

	return InvoicesValue{
		CouponsAmountCents:                  couponsAmountCentsVal,
		CreatedAt:                           createdAtVal,
		CreditNotesAmountCents:              creditNotesAmountCentsVal,
		Currency:                            currencyVal,
		FeesAmountCents:                     feesAmountCentsVal,
		FileUrl:                             fileUrlVal,
		InvoiceType:                         invoiceTypeVal,
		IssuingDate:                         issuingDateVal,
		LagoId:                              lagoIdVal,
		NetPaymentTerm:                      netPaymentTermVal,
		Number:                              numberVal,
		PaymentDisputeLostAt:                paymentDisputeLostAtVal,
		PaymentDueDate:                      paymentDueDateVal,
		PaymentOverdue:                      paymentOverdueVal,
		PaymentStatus:                       paymentStatusVal,
		PrepaidCreditAmountCents:            prepaidCreditAmountCentsVal,
		ProgressiveBillingCreditAmountCents: progressiveBillingCreditAmountCentsVal,
		SelfBilled:                          selfBilledVal,
		SequentialId:                        sequentialIdVal,
		Status:                              statusVal,
		SubTotalExcludingTaxesAmountCents:   subTotalExcludingTaxesAmountCentsVal,
		SubTotalIncludingTaxesAmountCents:   subTotalIncludingTaxesAmountCentsVal,
		TaxesAmountCents:                    taxesAmountCentsVal,
		TotalAmountCents:                    totalAmountCentsVal,
		UpdatedAt:                           updatedAtVal,
		VersionNumber:                       versionNumberVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewInvoicesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InvoicesValue {
	object, diags := NewInvoicesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInvoicesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InvoicesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInvoicesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInvoicesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInvoicesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInvoicesValueMust(InvoicesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InvoicesType) ValueType(ctx context.Context) attr.Value {
	return InvoicesValue{}
}

var _ basetypes.ObjectValuable = InvoicesValue{}

type InvoicesValue struct {
	CouponsAmountCents                  basetypes.Int64Value  `tfsdk:"coupons_amount_cents"`
	CreatedAt                           basetypes.StringValue `tfsdk:"created_at"`
	CreditNotesAmountCents              basetypes.Int64Value  `tfsdk:"credit_notes_amount_cents"`
	Currency                            basetypes.StringValue `tfsdk:"currency"`
	FeesAmountCents                     basetypes.Int64Value  `tfsdk:"fees_amount_cents"`
	FileUrl                             basetypes.StringValue `tfsdk:"file_url"`
	InvoiceType                         basetypes.StringValue `tfsdk:"invoice_type"`
	IssuingDate                         basetypes.StringValue `tfsdk:"issuing_date"`
	LagoId                              basetypes.StringValue `tfsdk:"lago_id"`
	NetPaymentTerm                      basetypes.Int64Value  `tfsdk:"net_payment_term"`
	Number                              basetypes.StringValue `tfsdk:"number"`
	PaymentDisputeLostAt                basetypes.StringValue `tfsdk:"payment_dispute_lost_at"`
	PaymentDueDate                      basetypes.StringValue `tfsdk:"payment_due_date"`
	PaymentOverdue                      basetypes.BoolValue   `tfsdk:"payment_overdue"`
	PaymentStatus                       basetypes.StringValue `tfsdk:"payment_status"`
	PrepaidCreditAmountCents            basetypes.Int64Value  `tfsdk:"prepaid_credit_amount_cents"`
	ProgressiveBillingCreditAmountCents basetypes.Int64Value  `tfsdk:"progressive_billing_credit_amount_cents"`
	SelfBilled                          basetypes.BoolValue   `tfsdk:"self_billed"`
	SequentialId                        basetypes.Int64Value  `tfsdk:"sequential_id"`
	Status                              basetypes.StringValue `tfsdk:"status"`
	SubTotalExcludingTaxesAmountCents   basetypes.Int64Value  `tfsdk:"sub_total_excluding_taxes_amount_cents"`
	SubTotalIncludingTaxesAmountCents   basetypes.Int64Value  `tfsdk:"sub_total_including_taxes_amount_cents"`
	TaxesAmountCents                    basetypes.Int64Value  `tfsdk:"taxes_amount_cents"`
	TotalAmountCents                    basetypes.Int64Value  `tfsdk:"total_amount_cents"`
	UpdatedAt                           basetypes.StringValue `tfsdk:"updated_at"`
	VersionNumber                       basetypes.Int64Value  `tfsdk:"version_number"`
	state                               attr.ValueState
}

func (v InvoicesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 26)

	var val tftypes.Value
	var err error

	attrTypes["coupons_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["credit_notes_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fees_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["file_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["issuing_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["net_payment_term"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["payment_dispute_lost_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["payment_due_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["payment_overdue"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["payment_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prepaid_credit_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["progressive_billing_credit_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["self_billed"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sequential_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sub_total_excluding_taxes_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["sub_total_including_taxes_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["taxes_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version_number"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 26)

		val, err = v.CouponsAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coupons_amount_cents"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.CreditNotesAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["credit_notes_amount_cents"] = val

		val, err = v.Currency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["currency"] = val

		val, err = v.FeesAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fees_amount_cents"] = val

		val, err = v.FileUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["file_url"] = val

		val, err = v.InvoiceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_type"] = val

		val, err = v.IssuingDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["issuing_date"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.NetPaymentTerm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["net_payment_term"] = val

		val, err = v.Number.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["number"] = val

		val, err = v.PaymentDisputeLostAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_dispute_lost_at"] = val

		val, err = v.PaymentDueDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_due_date"] = val

		val, err = v.PaymentOverdue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_overdue"] = val

		val, err = v.PaymentStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_status"] = val

		val, err = v.PrepaidCreditAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prepaid_credit_amount_cents"] = val

		val, err = v.ProgressiveBillingCreditAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["progressive_billing_credit_amount_cents"] = val

		val, err = v.SelfBilled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["self_billed"] = val

		val, err = v.SequentialId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sequential_id"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.SubTotalExcludingTaxesAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sub_total_excluding_taxes_amount_cents"] = val

		val, err = v.SubTotalIncludingTaxesAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sub_total_including_taxes_amount_cents"] = val

		val, err = v.TaxesAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taxes_amount_cents"] = val

		val, err = v.TotalAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_amount_cents"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		val, err = v.VersionNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version_number"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InvoicesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InvoicesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InvoicesValue) String() string {
	return "InvoicesValue"
}

func (v InvoicesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"coupons_amount_cents":        basetypes.Int64Type{},
		"created_at":                  basetypes.StringType{},
		"credit_notes_amount_cents":   basetypes.Int64Type{},
		"currency":                    basetypes.StringType{},
		"fees_amount_cents":           basetypes.Int64Type{},
		"file_url":                    basetypes.StringType{},
		"invoice_type":                basetypes.StringType{},
		"issuing_date":                basetypes.StringType{},
		"lago_id":                     basetypes.StringType{},
		"net_payment_term":            basetypes.Int64Type{},
		"number":                      basetypes.StringType{},
		"payment_dispute_lost_at":     basetypes.StringType{},
		"payment_due_date":            basetypes.StringType{},
		"payment_overdue":             basetypes.BoolType{},
		"payment_status":              basetypes.StringType{},
		"prepaid_credit_amount_cents": basetypes.Int64Type{},
		"progressive_billing_credit_amount_cents": basetypes.Int64Type{},
		"self_billed":                            basetypes.BoolType{},
		"sequential_id":                          basetypes.Int64Type{},
		"status":                                 basetypes.StringType{},
		"sub_total_excluding_taxes_amount_cents": basetypes.Int64Type{},
		"sub_total_including_taxes_amount_cents": basetypes.Int64Type{},
		"taxes_amount_cents":                     basetypes.Int64Type{},
		"total_amount_cents":                     basetypes.Int64Type{},
		"updated_at":                             basetypes.StringType{},
		"version_number":                         basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"coupons_amount_cents":        v.CouponsAmountCents,
			"created_at":                  v.CreatedAt,
			"credit_notes_amount_cents":   v.CreditNotesAmountCents,
			"currency":                    v.Currency,
			"fees_amount_cents":           v.FeesAmountCents,
			"file_url":                    v.FileUrl,
			"invoice_type":                v.InvoiceType,
			"issuing_date":                v.IssuingDate,
			"lago_id":                     v.LagoId,
			"net_payment_term":            v.NetPaymentTerm,
			"number":                      v.Number,
			"payment_dispute_lost_at":     v.PaymentDisputeLostAt,
			"payment_due_date":            v.PaymentDueDate,
			"payment_overdue":             v.PaymentOverdue,
			"payment_status":              v.PaymentStatus,
			"prepaid_credit_amount_cents": v.PrepaidCreditAmountCents,
			"progressive_billing_credit_amount_cents": v.ProgressiveBillingCreditAmountCents,
			"self_billed":                            v.SelfBilled,
			"sequential_id":                          v.SequentialId,
			"status":                                 v.Status,
			"sub_total_excluding_taxes_amount_cents": v.SubTotalExcludingTaxesAmountCents,
			"sub_total_including_taxes_amount_cents": v.SubTotalIncludingTaxesAmountCents,
			"taxes_amount_cents":                     v.TaxesAmountCents,
			"total_amount_cents":                     v.TotalAmountCents,
			"updated_at":                             v.UpdatedAt,
			"version_number":                         v.VersionNumber,
		})

	return objVal, diags
}

func (v InvoicesValue) Equal(o attr.Value) bool {
	other, ok := o.(InvoicesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CouponsAmountCents.Equal(other.CouponsAmountCents) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.CreditNotesAmountCents.Equal(other.CreditNotesAmountCents) {
		return false
	}

	if !v.Currency.Equal(other.Currency) {
		return false
	}

	if !v.FeesAmountCents.Equal(other.FeesAmountCents) {
		return false
	}

	if !v.FileUrl.Equal(other.FileUrl) {
		return false
	}

	if !v.InvoiceType.Equal(other.InvoiceType) {
		return false
	}

	if !v.IssuingDate.Equal(other.IssuingDate) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.NetPaymentTerm.Equal(other.NetPaymentTerm) {
		return false
	}

	if !v.Number.Equal(other.Number) {
		return false
	}

	if !v.PaymentDisputeLostAt.Equal(other.PaymentDisputeLostAt) {
		return false
	}

	if !v.PaymentDueDate.Equal(other.PaymentDueDate) {
		return false
	}

	if !v.PaymentOverdue.Equal(other.PaymentOverdue) {
		return false
	}

	if !v.PaymentStatus.Equal(other.PaymentStatus) {
		return false
	}

	if !v.PrepaidCreditAmountCents.Equal(other.PrepaidCreditAmountCents) {
		return false
	}

	if !v.ProgressiveBillingCreditAmountCents.Equal(other.ProgressiveBillingCreditAmountCents) {
		return false
	}

	if !v.SelfBilled.Equal(other.SelfBilled) {
		return false
	}

	if !v.SequentialId.Equal(other.SequentialId) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.SubTotalExcludingTaxesAmountCents.Equal(other.SubTotalExcludingTaxesAmountCents) {
		return false
	}

	if !v.SubTotalIncludingTaxesAmountCents.Equal(other.SubTotalIncludingTaxesAmountCents) {
		return false
	}

	if !v.TaxesAmountCents.Equal(other.TaxesAmountCents) {
		return false
	}

	if !v.TotalAmountCents.Equal(other.TotalAmountCents) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	if !v.VersionNumber.Equal(other.VersionNumber) {
		return false
	}

	return true
}

func (v InvoicesValue) Type(ctx context.Context) attr.Type {
	return InvoicesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InvoicesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"coupons_amount_cents":        basetypes.Int64Type{},
		"created_at":                  basetypes.StringType{},
		"credit_notes_amount_cents":   basetypes.Int64Type{},
		"currency":                    basetypes.StringType{},
		"fees_amount_cents":           basetypes.Int64Type{},
		"file_url":                    basetypes.StringType{},
		"invoice_type":                basetypes.StringType{},
		"issuing_date":                basetypes.StringType{},
		"lago_id":                     basetypes.StringType{},
		"net_payment_term":            basetypes.Int64Type{},
		"number":                      basetypes.StringType{},
		"payment_dispute_lost_at":     basetypes.StringType{},
		"payment_due_date":            basetypes.StringType{},
		"payment_overdue":             basetypes.BoolType{},
		"payment_status":              basetypes.StringType{},
		"prepaid_credit_amount_cents": basetypes.Int64Type{},
		"progressive_billing_credit_amount_cents": basetypes.Int64Type{},
		"self_billed":                            basetypes.BoolType{},
		"sequential_id":                          basetypes.Int64Type{},
		"status":                                 basetypes.StringType{},
		"sub_total_excluding_taxes_amount_cents": basetypes.Int64Type{},
		"sub_total_including_taxes_amount_cents": basetypes.Int64Type{},
		"taxes_amount_cents":                     basetypes.Int64Type{},
		"total_amount_cents":                     basetypes.Int64Type{},
		"updated_at":                             basetypes.StringType{},
		"version_number":                         basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PaymentRequestsType{}

type PaymentRequestsType struct {
	basetypes.ObjectType
}

func (t PaymentRequestsType) Equal(o attr.Type) bool {
	other, ok := o.(PaymentRequestsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PaymentRequestsType) String() string {
	return "PaymentRequestsType"
}

func (t PaymentRequestsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return nil, diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return nil, diags
	}

	customerVal, ok := customerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.ObjectValue, was: %T`, customerAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return nil, diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	invoicesAttribute, ok := attributes["invoices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoices is missing from object`)

		return nil, diags
	}

	invoicesVal, ok := invoicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoices expected to be basetypes.ListValue, was: %T`, invoicesAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return nil, diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PaymentRequestsValue{
		AmountCents:    amountCentsVal,
		AmountCurrency: amountCurrencyVal,
		CreatedAt:      createdAtVal,
		Customer:       customerVal,
		Email:          emailVal,
		Invoices:       invoicesVal,
		LagoId:         lagoIdVal,
		PaymentStatus:  paymentStatusVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPaymentRequestsValueNull() PaymentRequestsValue {
	return PaymentRequestsValue{
		state: attr.ValueStateNull,
	}
}

func NewPaymentRequestsValueUnknown() PaymentRequestsValue {
	return PaymentRequestsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPaymentRequestsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PaymentRequestsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PaymentRequestsValue Attribute Value",
				"While creating a PaymentRequestsValue value, a missing attribute value was detected. "+
					"A PaymentRequestsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PaymentRequestsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PaymentRequestsValue Attribute Type",
				"While creating a PaymentRequestsValue value, an invalid attribute value was detected. "+
					"A PaymentRequestsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PaymentRequestsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PaymentRequestsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PaymentRequestsValue Attribute Value",
				"While creating a PaymentRequestsValue value, an extra attribute value was detected. "+
					"A PaymentRequestsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PaymentRequestsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPaymentRequestsValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewPaymentRequestsValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return NewPaymentRequestsValueUnknown(), diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewPaymentRequestsValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return NewPaymentRequestsValueUnknown(), diags
	}

	customerVal, ok := customerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.ObjectValue, was: %T`, customerAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return NewPaymentRequestsValueUnknown(), diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	invoicesAttribute, ok := attributes["invoices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoices is missing from object`)

		return NewPaymentRequestsValueUnknown(), diags
	}

	invoicesVal, ok := invoicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoices expected to be basetypes.ListValue, was: %T`, invoicesAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewPaymentRequestsValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return NewPaymentRequestsValueUnknown(), diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	if diags.HasError() {
		return NewPaymentRequestsValueUnknown(), diags
	}

	return PaymentRequestsValue{
		AmountCents:    amountCentsVal,
		AmountCurrency: amountCurrencyVal,
		CreatedAt:      createdAtVal,
		Customer:       customerVal,
		Email:          emailVal,
		Invoices:       invoicesVal,
		LagoId:         lagoIdVal,
		PaymentStatus:  paymentStatusVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPaymentRequestsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PaymentRequestsValue {
	object, diags := NewPaymentRequestsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPaymentRequestsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PaymentRequestsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPaymentRequestsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPaymentRequestsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPaymentRequestsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPaymentRequestsValueMust(PaymentRequestsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PaymentRequestsType) ValueType(ctx context.Context) attr.Value {
	return PaymentRequestsValue{}
}

var _ basetypes.ObjectValuable = PaymentRequestsValue{}

type PaymentRequestsValue struct {
	AmountCents    basetypes.Int64Value  `tfsdk:"amount_cents"`
	AmountCurrency basetypes.StringValue `tfsdk:"amount_currency"`
	CreatedAt      basetypes.StringValue `tfsdk:"created_at"`
	Customer       basetypes.ObjectValue `tfsdk:"customer"`
	Email          basetypes.StringValue `tfsdk:"email"`
	Invoices       basetypes.ListValue   `tfsdk:"invoices"`
	LagoId         basetypes.StringValue `tfsdk:"lago_id"`
	PaymentStatus  basetypes.StringValue `tfsdk:"payment_status"`
	state          attr.ValueState
}

func (v PaymentRequestsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["amount_currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer"] = basetypes.ObjectType{
		AttrTypes: CustomerValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoices"] = basetypes.ListType{
		ElemType: InvoicesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["payment_status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.AmountCurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_currency"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Customer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer"] = val

		val, err = v.Email.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email"] = val

		val, err = v.Invoices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoices"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.PaymentStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PaymentRequestsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PaymentRequestsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PaymentRequestsValue) String() string {
	return "PaymentRequestsValue"
}

func (v PaymentRequestsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var customer basetypes.ObjectValue

	if v.Customer.IsNull() {
		customer = types.ObjectNull(
			CustomerValue{}.AttributeTypes(ctx),
		)
	}

	if v.Customer.IsUnknown() {
		customer = types.ObjectUnknown(
			CustomerValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Customer.IsNull() && !v.Customer.IsUnknown() {
		customer = types.ObjectValueMust(
			CustomerValue{}.AttributeTypes(ctx),
			v.Customer.Attributes(),
		)
	}

	invoices := types.ListValueMust(
		InvoicesType{
			basetypes.ObjectType{
				AttrTypes: InvoicesValue{}.AttributeTypes(ctx),
			},
		},
		v.Invoices.Elements(),
	)

	if v.Invoices.IsNull() {
		invoices = types.ListNull(
			InvoicesType{
				basetypes.ObjectType{
					AttrTypes: InvoicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Invoices.IsUnknown() {
		invoices = types.ListUnknown(
			InvoicesType{
				basetypes.ObjectType{
					AttrTypes: InvoicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"created_at":      basetypes.StringType{},
		"customer": basetypes.ObjectType{
			AttrTypes: CustomerValue{}.AttributeTypes(ctx),
		},
		"email": basetypes.StringType{},
		"invoices": basetypes.ListType{
			ElemType: InvoicesValue{}.Type(ctx),
		},
		"lago_id":        basetypes.StringType{},
		"payment_status": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":    v.AmountCents,
			"amount_currency": v.AmountCurrency,
			"created_at":      v.CreatedAt,
			"customer":        customer,
			"email":           v.Email,
			"invoices":        invoices,
			"lago_id":         v.LagoId,
			"payment_status":  v.PaymentStatus,
		})

	return objVal, diags
}

func (v PaymentRequestsValue) Equal(o attr.Value) bool {
	other, ok := o.(PaymentRequestsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.AmountCurrency.Equal(other.AmountCurrency) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Customer.Equal(other.Customer) {
		return false
	}

	if !v.Email.Equal(other.Email) {
		return false
	}

	if !v.Invoices.Equal(other.Invoices) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.PaymentStatus.Equal(other.PaymentStatus) {
		return false
	}

	return true
}

func (v PaymentRequestsValue) Type(ctx context.Context) attr.Type {
	return PaymentRequestsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PaymentRequestsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"created_at":      basetypes.StringType{},
		"customer": basetypes.ObjectType{
			AttrTypes: CustomerValue{}.AttributeTypes(ctx),
		},
		"email": basetypes.StringType{},
		"invoices": basetypes.ListType{
			ElemType: InvoicesValue{}.Type(ctx),
		},
		"lago_id":        basetypes.StringType{},
		"payment_status": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CustomerType{}

type CustomerType struct {
	basetypes.ObjectType
}

func (t CustomerType) Equal(o attr.Type) bool {
	other, ok := o.(CustomerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomerType) String() string {
	return "CustomerType"
}

func (t CustomerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accountTypeAttribute, ok := attributes["account_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_type is missing from object`)

		return nil, diags
	}

	accountTypeVal, ok := accountTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_type expected to be basetypes.StringValue, was: %T`, accountTypeAttribute))
	}

	addressLine1Attribute, ok := attributes["address_line1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line1 is missing from object`)

		return nil, diags
	}

	addressLine1Val, ok := addressLine1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line1 expected to be basetypes.StringValue, was: %T`, addressLine1Attribute))
	}

	addressLine2Attribute, ok := attributes["address_line2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line2 is missing from object`)

		return nil, diags
	}

	addressLine2Val, ok := addressLine2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line2 expected to be basetypes.StringValue, was: %T`, addressLine2Attribute))
	}

	applicableTimezoneAttribute, ok := attributes["applicable_timezone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applicable_timezone is missing from object`)

		return nil, diags
	}

	applicableTimezoneVal, ok := applicableTimezoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applicable_timezone expected to be basetypes.StringValue, was: %T`, applicableTimezoneAttribute))
	}

	billingConfigurationAttribute, ok := attributes["billing_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billing_configuration is missing from object`)

		return nil, diags
	}

	billingConfigurationVal, ok := billingConfigurationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billing_configuration expected to be basetypes.ObjectValue, was: %T`, billingConfigurationAttribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return nil, diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return nil, diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return nil, diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	customerTypeAttribute, ok := attributes["customer_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_type is missing from object`)

		return nil, diags
	}

	customerTypeVal, ok := customerTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_type expected to be basetypes.StringValue, was: %T`, customerTypeAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return nil, diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	externalIdAttribute, ok := attributes["external_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_id is missing from object`)

		return nil, diags
	}

	externalIdVal, ok := externalIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_id expected to be basetypes.StringValue, was: %T`, externalIdAttribute))
	}

	finalizeZeroAmountInvoiceAttribute, ok := attributes["finalize_zero_amount_invoice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`finalize_zero_amount_invoice is missing from object`)

		return nil, diags
	}

	finalizeZeroAmountInvoiceVal, ok := finalizeZeroAmountInvoiceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`finalize_zero_amount_invoice expected to be basetypes.StringValue, was: %T`, finalizeZeroAmountInvoiceAttribute))
	}

	firstnameAttribute, ok := attributes["firstname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`firstname is missing from object`)

		return nil, diags
	}

	firstnameVal, ok := firstnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`firstname expected to be basetypes.StringValue, was: %T`, firstnameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lastnameAttribute, ok := attributes["lastname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lastname is missing from object`)

		return nil, diags
	}

	lastnameVal, ok := lastnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lastname expected to be basetypes.StringValue, was: %T`, lastnameAttribute))
	}

	legalNameAttribute, ok := attributes["legal_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legal_name is missing from object`)

		return nil, diags
	}

	legalNameVal, ok := legalNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legal_name expected to be basetypes.StringValue, was: %T`, legalNameAttribute))
	}

	legalNumberAttribute, ok := attributes["legal_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legal_number is missing from object`)

		return nil, diags
	}

	legalNumberVal, ok := legalNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legal_number expected to be basetypes.StringValue, was: %T`, legalNumberAttribute))
	}

	logoUrlAttribute, ok := attributes["logo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`logo_url is missing from object`)

		return nil, diags
	}

	logoUrlVal, ok := logoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`logo_url expected to be basetypes.StringValue, was: %T`, logoUrlAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ListValue, was: %T`, metadataAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	netPaymentTermAttribute, ok := attributes["net_payment_term"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_payment_term is missing from object`)

		return nil, diags
	}

	netPaymentTermVal, ok := netPaymentTermAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_payment_term expected to be basetypes.Int64Value, was: %T`, netPaymentTermAttribute))
	}

	phoneAttribute, ok := attributes["phone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phone is missing from object`)

		return nil, diags
	}

	phoneVal, ok := phoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phone expected to be basetypes.StringValue, was: %T`, phoneAttribute))
	}

	sequentialIdAttribute, ok := attributes["sequential_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sequential_id is missing from object`)

		return nil, diags
	}

	sequentialIdVal, ok := sequentialIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sequential_id expected to be basetypes.Int64Value, was: %T`, sequentialIdAttribute))
	}

	shippingAddressAttribute, ok := attributes["shipping_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`shipping_address is missing from object`)

		return nil, diags
	}

	shippingAddressVal, ok := shippingAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`shipping_address expected to be basetypes.ObjectValue, was: %T`, shippingAddressAttribute))
	}

	skipInvoiceCustomSectionsAttribute, ok := attributes["skip_invoice_custom_sections"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_invoice_custom_sections is missing from object`)

		return nil, diags
	}

	skipInvoiceCustomSectionsVal, ok := skipInvoiceCustomSectionsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_invoice_custom_sections expected to be basetypes.BoolValue, was: %T`, skipInvoiceCustomSectionsAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	taxIdentificationNumberAttribute, ok := attributes["tax_identification_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_identification_number is missing from object`)

		return nil, diags
	}

	taxIdentificationNumberVal, ok := taxIdentificationNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_identification_number expected to be basetypes.StringValue, was: %T`, taxIdentificationNumberAttribute))
	}

	timezoneAttribute, ok := attributes["timezone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timezone is missing from object`)

		return nil, diags
	}

	timezoneVal, ok := timezoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timezone expected to be basetypes.StringValue, was: %T`, timezoneAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	zipcodeAttribute, ok := attributes["zipcode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zipcode is missing from object`)

		return nil, diags
	}

	zipcodeVal, ok := zipcodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zipcode expected to be basetypes.StringValue, was: %T`, zipcodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomerValue{
		AccountType:               accountTypeVal,
		AddressLine1:              addressLine1Val,
		AddressLine2:              addressLine2Val,
		ApplicableTimezone:        applicableTimezoneVal,
		BillingConfiguration:      billingConfigurationVal,
		City:                      cityVal,
		Country:                   countryVal,
		CreatedAt:                 createdAtVal,
		Currency:                  currencyVal,
		CustomerType:              customerTypeVal,
		Email:                     emailVal,
		ExternalId:                externalIdVal,
		FinalizeZeroAmountInvoice: finalizeZeroAmountInvoiceVal,
		Firstname:                 firstnameVal,
		LagoId:                    lagoIdVal,
		Lastname:                  lastnameVal,
		LegalName:                 legalNameVal,
		LegalNumber:               legalNumberVal,
		LogoUrl:                   logoUrlVal,
		Metadata:                  metadataVal,
		Name:                      nameVal,
		NetPaymentTerm:            netPaymentTermVal,
		Phone:                     phoneVal,
		SequentialId:              sequentialIdVal,
		ShippingAddress:           shippingAddressVal,
		SkipInvoiceCustomSections: skipInvoiceCustomSectionsVal,
		Slug:                      slugVal,
		State:                     stateVal,
		TaxIdentificationNumber:   taxIdentificationNumberVal,
		Timezone:                  timezoneVal,
		UpdatedAt:                 updatedAtVal,
		Url:                       urlVal,
		Zipcode:                   zipcodeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewCustomerValueNull() CustomerValue {
	return CustomerValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomerValueUnknown() CustomerValue {
	return CustomerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomerValue Attribute Value",
				"While creating a CustomerValue value, a missing attribute value was detected. "+
					"A CustomerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomerValue Attribute Type",
				"While creating a CustomerValue value, an invalid attribute value was detected. "+
					"A CustomerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomerValue Attribute Value",
				"While creating a CustomerValue value, an extra attribute value was detected. "+
					"A CustomerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomerValueUnknown(), diags
	}

	accountTypeAttribute, ok := attributes["account_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_type is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	accountTypeVal, ok := accountTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_type expected to be basetypes.StringValue, was: %T`, accountTypeAttribute))
	}

	addressLine1Attribute, ok := attributes["address_line1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line1 is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	addressLine1Val, ok := addressLine1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line1 expected to be basetypes.StringValue, was: %T`, addressLine1Attribute))
	}

	addressLine2Attribute, ok := attributes["address_line2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line2 is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	addressLine2Val, ok := addressLine2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line2 expected to be basetypes.StringValue, was: %T`, addressLine2Attribute))
	}

	applicableTimezoneAttribute, ok := attributes["applicable_timezone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applicable_timezone is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	applicableTimezoneVal, ok := applicableTimezoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applicable_timezone expected to be basetypes.StringValue, was: %T`, applicableTimezoneAttribute))
	}

	billingConfigurationAttribute, ok := attributes["billing_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billing_configuration is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	billingConfigurationVal, ok := billingConfigurationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billing_configuration expected to be basetypes.ObjectValue, was: %T`, billingConfigurationAttribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	customerTypeAttribute, ok := attributes["customer_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_type is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	customerTypeVal, ok := customerTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_type expected to be basetypes.StringValue, was: %T`, customerTypeAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	externalIdAttribute, ok := attributes["external_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_id is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	externalIdVal, ok := externalIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_id expected to be basetypes.StringValue, was: %T`, externalIdAttribute))
	}

	finalizeZeroAmountInvoiceAttribute, ok := attributes["finalize_zero_amount_invoice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`finalize_zero_amount_invoice is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	finalizeZeroAmountInvoiceVal, ok := finalizeZeroAmountInvoiceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`finalize_zero_amount_invoice expected to be basetypes.StringValue, was: %T`, finalizeZeroAmountInvoiceAttribute))
	}

	firstnameAttribute, ok := attributes["firstname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`firstname is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	firstnameVal, ok := firstnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`firstname expected to be basetypes.StringValue, was: %T`, firstnameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	lastnameAttribute, ok := attributes["lastname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lastname is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	lastnameVal, ok := lastnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lastname expected to be basetypes.StringValue, was: %T`, lastnameAttribute))
	}

	legalNameAttribute, ok := attributes["legal_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legal_name is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	legalNameVal, ok := legalNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legal_name expected to be basetypes.StringValue, was: %T`, legalNameAttribute))
	}

	legalNumberAttribute, ok := attributes["legal_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legal_number is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	legalNumberVal, ok := legalNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legal_number expected to be basetypes.StringValue, was: %T`, legalNumberAttribute))
	}

	logoUrlAttribute, ok := attributes["logo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`logo_url is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	logoUrlVal, ok := logoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`logo_url expected to be basetypes.StringValue, was: %T`, logoUrlAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ListValue, was: %T`, metadataAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	netPaymentTermAttribute, ok := attributes["net_payment_term"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_payment_term is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	netPaymentTermVal, ok := netPaymentTermAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_payment_term expected to be basetypes.Int64Value, was: %T`, netPaymentTermAttribute))
	}

	phoneAttribute, ok := attributes["phone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phone is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	phoneVal, ok := phoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phone expected to be basetypes.StringValue, was: %T`, phoneAttribute))
	}

	sequentialIdAttribute, ok := attributes["sequential_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sequential_id is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	sequentialIdVal, ok := sequentialIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sequential_id expected to be basetypes.Int64Value, was: %T`, sequentialIdAttribute))
	}

	shippingAddressAttribute, ok := attributes["shipping_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`shipping_address is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	shippingAddressVal, ok := shippingAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`shipping_address expected to be basetypes.ObjectValue, was: %T`, shippingAddressAttribute))
	}

	skipInvoiceCustomSectionsAttribute, ok := attributes["skip_invoice_custom_sections"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_invoice_custom_sections is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	skipInvoiceCustomSectionsVal, ok := skipInvoiceCustomSectionsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_invoice_custom_sections expected to be basetypes.BoolValue, was: %T`, skipInvoiceCustomSectionsAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	taxIdentificationNumberAttribute, ok := attributes["tax_identification_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_identification_number is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	taxIdentificationNumberVal, ok := taxIdentificationNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_identification_number expected to be basetypes.StringValue, was: %T`, taxIdentificationNumberAttribute))
	}

	timezoneAttribute, ok := attributes["timezone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timezone is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	timezoneVal, ok := timezoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timezone expected to be basetypes.StringValue, was: %T`, timezoneAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	zipcodeAttribute, ok := attributes["zipcode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zipcode is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	zipcodeVal, ok := zipcodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zipcode expected to be basetypes.StringValue, was: %T`, zipcodeAttribute))
	}

	if diags.HasError() {
		return NewCustomerValueUnknown(), diags
	}

	return CustomerValue{
		AccountType:               accountTypeVal,
		AddressLine1:              addressLine1Val,
		AddressLine2:              addressLine2Val,
		ApplicableTimezone:        applicableTimezoneVal,
		BillingConfiguration:      billingConfigurationVal,
		City:                      cityVal,
		Country:                   countryVal,
		CreatedAt:                 createdAtVal,
		Currency:                  currencyVal,
		CustomerType:              customerTypeVal,
		Email:                     emailVal,
		ExternalId:                externalIdVal,
		FinalizeZeroAmountInvoice: finalizeZeroAmountInvoiceVal,
		Firstname:                 firstnameVal,
		LagoId:                    lagoIdVal,
		Lastname:                  lastnameVal,
		LegalName:                 legalNameVal,
		LegalNumber:               legalNumberVal,
		LogoUrl:                   logoUrlVal,
		Metadata:                  metadataVal,
		Name:                      nameVal,
		NetPaymentTerm:            netPaymentTermVal,
		Phone:                     phoneVal,
		SequentialId:              sequentialIdVal,
		ShippingAddress:           shippingAddressVal,
		SkipInvoiceCustomSections: skipInvoiceCustomSectionsVal,
		Slug:                      slugVal,
		State:                     stateVal,
		TaxIdentificationNumber:   taxIdentificationNumberVal,
		Timezone:                  timezoneVal,
		UpdatedAt:                 updatedAtVal,
		Url:                       urlVal,
		Zipcode:                   zipcodeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewCustomerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomerValue {
	object, diags := NewCustomerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomerValueMust(CustomerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomerType) ValueType(ctx context.Context) attr.Value {
	return CustomerValue{}
}

var _ basetypes.ObjectValuable = CustomerValue{}

type CustomerValue struct {
	AccountType               basetypes.StringValue `tfsdk:"account_type"`
	AddressLine1              basetypes.StringValue `tfsdk:"address_line1"`
	AddressLine2              basetypes.StringValue `tfsdk:"address_line2"`
	ApplicableTimezone        basetypes.StringValue `tfsdk:"applicable_timezone"`
	BillingConfiguration      basetypes.ObjectValue `tfsdk:"billing_configuration"`
	City                      basetypes.StringValue `tfsdk:"city"`
	Country                   basetypes.StringValue `tfsdk:"country"`
	CreatedAt                 basetypes.StringValue `tfsdk:"created_at"`
	Currency                  basetypes.StringValue `tfsdk:"currency"`
	CustomerType              basetypes.StringValue `tfsdk:"customer_type"`
	Email                     basetypes.StringValue `tfsdk:"email"`
	ExternalId                basetypes.StringValue `tfsdk:"external_id"`
	FinalizeZeroAmountInvoice basetypes.StringValue `tfsdk:"finalize_zero_amount_invoice"`
	Firstname                 basetypes.StringValue `tfsdk:"firstname"`
	LagoId                    basetypes.StringValue `tfsdk:"lago_id"`
	Lastname                  basetypes.StringValue `tfsdk:"lastname"`
	LegalName                 basetypes.StringValue `tfsdk:"legal_name"`
	LegalNumber               basetypes.StringValue `tfsdk:"legal_number"`
	LogoUrl                   basetypes.StringValue `tfsdk:"logo_url"`
	Metadata                  basetypes.ListValue   `tfsdk:"metadata"`
	Name                      basetypes.StringValue `tfsdk:"name"`
	NetPaymentTerm            basetypes.Int64Value  `tfsdk:"net_payment_term"`
	Phone                     basetypes.StringValue `tfsdk:"phone"`
	SequentialId              basetypes.Int64Value  `tfsdk:"sequential_id"`
	ShippingAddress           basetypes.ObjectValue `tfsdk:"shipping_address"`
	SkipInvoiceCustomSections basetypes.BoolValue   `tfsdk:"skip_invoice_custom_sections"`
	Slug                      basetypes.StringValue `tfsdk:"slug"`
	State                     basetypes.StringValue `tfsdk:"state"`
	TaxIdentificationNumber   basetypes.StringValue `tfsdk:"tax_identification_number"`
	Timezone                  basetypes.StringValue `tfsdk:"timezone"`
	UpdatedAt                 basetypes.StringValue `tfsdk:"updated_at"`
	Url                       basetypes.StringValue `tfsdk:"url"`
	Zipcode                   basetypes.StringValue `tfsdk:"zipcode"`
	state                     attr.ValueState
}

func (v CustomerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 33)

	var val tftypes.Value
	var err error

	attrTypes["account_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["address_line1"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["address_line2"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["applicable_timezone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["billing_configuration"] = basetypes.ObjectType{
		AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["city"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["country"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["finalize_zero_amount_invoice"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["firstname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lastname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["legal_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["legal_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["logo_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ListType{
		ElemType: MetadataValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["net_payment_term"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["phone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sequential_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["shipping_address"] = basetypes.ObjectType{
		AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["skip_invoice_custom_sections"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tax_identification_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timezone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["zipcode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 33)

		val, err = v.AccountType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["account_type"] = val

		val, err = v.AddressLine1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_line1"] = val

		val, err = v.AddressLine2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_line2"] = val

		val, err = v.ApplicableTimezone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["applicable_timezone"] = val

		val, err = v.BillingConfiguration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billing_configuration"] = val

		val, err = v.City.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["city"] = val

		val, err = v.Country.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Currency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["currency"] = val

		val, err = v.CustomerType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_type"] = val

		val, err = v.Email.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email"] = val

		val, err = v.ExternalId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_id"] = val

		val, err = v.FinalizeZeroAmountInvoice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["finalize_zero_amount_invoice"] = val

		val, err = v.Firstname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["firstname"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Lastname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lastname"] = val

		val, err = v.LegalName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["legal_name"] = val

		val, err = v.LegalNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["legal_number"] = val

		val, err = v.LogoUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["logo_url"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NetPaymentTerm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["net_payment_term"] = val

		val, err = v.Phone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phone"] = val

		val, err = v.SequentialId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sequential_id"] = val

		val, err = v.ShippingAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["shipping_address"] = val

		val, err = v.SkipInvoiceCustomSections.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["skip_invoice_custom_sections"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.TaxIdentificationNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_identification_number"] = val

		val, err = v.Timezone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timezone"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Zipcode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["zipcode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomerValue) String() string {
	return "CustomerValue"
}

func (v CustomerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var billingConfiguration basetypes.ObjectValue

	if v.BillingConfiguration.IsNull() {
		billingConfiguration = types.ObjectNull(
			BillingConfigurationValue{}.AttributeTypes(ctx),
		)
	}

	if v.BillingConfiguration.IsUnknown() {
		billingConfiguration = types.ObjectUnknown(
			BillingConfigurationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BillingConfiguration.IsNull() && !v.BillingConfiguration.IsUnknown() {
		billingConfiguration = types.ObjectValueMust(
			BillingConfigurationValue{}.AttributeTypes(ctx),
			v.BillingConfiguration.Attributes(),
		)
	}

	metadata := types.ListValueMust(
		MetadataType{
			basetypes.ObjectType{
				AttrTypes: MetadataValue{}.AttributeTypes(ctx),
			},
		},
		v.Metadata.Elements(),
	)

	if v.Metadata.IsNull() {
		metadata = types.ListNull(
			MetadataType{
				basetypes.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ListUnknown(
			MetadataType{
				basetypes.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var shippingAddress basetypes.ObjectValue

	if v.ShippingAddress.IsNull() {
		shippingAddress = types.ObjectNull(
			ShippingAddressValue{}.AttributeTypes(ctx),
		)
	}

	if v.ShippingAddress.IsUnknown() {
		shippingAddress = types.ObjectUnknown(
			ShippingAddressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ShippingAddress.IsNull() && !v.ShippingAddress.IsUnknown() {
		shippingAddress = types.ObjectValueMust(
			ShippingAddressValue{}.AttributeTypes(ctx),
			v.ShippingAddress.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"account_type":        basetypes.StringType{},
		"address_line1":       basetypes.StringType{},
		"address_line2":       basetypes.StringType{},
		"applicable_timezone": basetypes.StringType{},
		"billing_configuration": basetypes.ObjectType{
			AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
		},
		"city":                         basetypes.StringType{},
		"country":                      basetypes.StringType{},
		"created_at":                   basetypes.StringType{},
		"currency":                     basetypes.StringType{},
		"customer_type":                basetypes.StringType{},
		"email":                        basetypes.StringType{},
		"external_id":                  basetypes.StringType{},
		"finalize_zero_amount_invoice": basetypes.StringType{},
		"firstname":                    basetypes.StringType{},
		"lago_id":                      basetypes.StringType{},
		"lastname":                     basetypes.StringType{},
		"legal_name":                   basetypes.StringType{},
		"legal_number":                 basetypes.StringType{},
		"logo_url":                     basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: MetadataValue{}.Type(ctx),
		},
		"name":             basetypes.StringType{},
		"net_payment_term": basetypes.Int64Type{},
		"phone":            basetypes.StringType{},
		"sequential_id":    basetypes.Int64Type{},
		"shipping_address": basetypes.ObjectType{
			AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
		},
		"skip_invoice_custom_sections": basetypes.BoolType{},
		"slug":                         basetypes.StringType{},
		"state":                        basetypes.StringType{},
		"tax_identification_number":    basetypes.StringType{},
		"timezone":                     basetypes.StringType{},
		"updated_at":                   basetypes.StringType{},
		"url":                          basetypes.StringType{},
		"zipcode":                      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"account_type":                 v.AccountType,
			"address_line1":                v.AddressLine1,
			"address_line2":                v.AddressLine2,
			"applicable_timezone":          v.ApplicableTimezone,
			"billing_configuration":        billingConfiguration,
			"city":                         v.City,
			"country":                      v.Country,
			"created_at":                   v.CreatedAt,
			"currency":                     v.Currency,
			"customer_type":                v.CustomerType,
			"email":                        v.Email,
			"external_id":                  v.ExternalId,
			"finalize_zero_amount_invoice": v.FinalizeZeroAmountInvoice,
			"firstname":                    v.Firstname,
			"lago_id":                      v.LagoId,
			"lastname":                     v.Lastname,
			"legal_name":                   v.LegalName,
			"legal_number":                 v.LegalNumber,
			"logo_url":                     v.LogoUrl,
			"metadata":                     metadata,
			"name":                         v.Name,
			"net_payment_term":             v.NetPaymentTerm,
			"phone":                        v.Phone,
			"sequential_id":                v.SequentialId,
			"shipping_address":             shippingAddress,
			"skip_invoice_custom_sections": v.SkipInvoiceCustomSections,
			"slug":                         v.Slug,
			"state":                        v.State,
			"tax_identification_number":    v.TaxIdentificationNumber,
			"timezone":                     v.Timezone,
			"updated_at":                   v.UpdatedAt,
			"url":                          v.Url,
			"zipcode":                      v.Zipcode,
		})

	return objVal, diags
}

func (v CustomerValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccountType.Equal(other.AccountType) {
		return false
	}

	if !v.AddressLine1.Equal(other.AddressLine1) {
		return false
	}

	if !v.AddressLine2.Equal(other.AddressLine2) {
		return false
	}

	if !v.ApplicableTimezone.Equal(other.ApplicableTimezone) {
		return false
	}

	if !v.BillingConfiguration.Equal(other.BillingConfiguration) {
		return false
	}

	if !v.City.Equal(other.City) {
		return false
	}

	if !v.Country.Equal(other.Country) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Currency.Equal(other.Currency) {
		return false
	}

	if !v.CustomerType.Equal(other.CustomerType) {
		return false
	}

	if !v.Email.Equal(other.Email) {
		return false
	}

	if !v.ExternalId.Equal(other.ExternalId) {
		return false
	}

	if !v.FinalizeZeroAmountInvoice.Equal(other.FinalizeZeroAmountInvoice) {
		return false
	}

	if !v.Firstname.Equal(other.Firstname) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Lastname.Equal(other.Lastname) {
		return false
	}

	if !v.LegalName.Equal(other.LegalName) {
		return false
	}

	if !v.LegalNumber.Equal(other.LegalNumber) {
		return false
	}

	if !v.LogoUrl.Equal(other.LogoUrl) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NetPaymentTerm.Equal(other.NetPaymentTerm) {
		return false
	}

	if !v.Phone.Equal(other.Phone) {
		return false
	}

	if !v.SequentialId.Equal(other.SequentialId) {
		return false
	}

	if !v.ShippingAddress.Equal(other.ShippingAddress) {
		return false
	}

	if !v.SkipInvoiceCustomSections.Equal(other.SkipInvoiceCustomSections) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.TaxIdentificationNumber.Equal(other.TaxIdentificationNumber) {
		return false
	}

	if !v.Timezone.Equal(other.Timezone) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Zipcode.Equal(other.Zipcode) {
		return false
	}

	return true
}

func (v CustomerValue) Type(ctx context.Context) attr.Type {
	return CustomerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"account_type":        basetypes.StringType{},
		"address_line1":       basetypes.StringType{},
		"address_line2":       basetypes.StringType{},
		"applicable_timezone": basetypes.StringType{},
		"billing_configuration": basetypes.ObjectType{
			AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
		},
		"city":                         basetypes.StringType{},
		"country":                      basetypes.StringType{},
		"created_at":                   basetypes.StringType{},
		"currency":                     basetypes.StringType{},
		"customer_type":                basetypes.StringType{},
		"email":                        basetypes.StringType{},
		"external_id":                  basetypes.StringType{},
		"finalize_zero_amount_invoice": basetypes.StringType{},
		"firstname":                    basetypes.StringType{},
		"lago_id":                      basetypes.StringType{},
		"lastname":                     basetypes.StringType{},
		"legal_name":                   basetypes.StringType{},
		"legal_number":                 basetypes.StringType{},
		"logo_url":                     basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: MetadataValue{}.Type(ctx),
		},
		"name":             basetypes.StringType{},
		"net_payment_term": basetypes.Int64Type{},
		"phone":            basetypes.StringType{},
		"sequential_id":    basetypes.Int64Type{},
		"shipping_address": basetypes.ObjectType{
			AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
		},
		"skip_invoice_custom_sections": basetypes.BoolType{},
		"slug":                         basetypes.StringType{},
		"state":                        basetypes.StringType{},
		"tax_identification_number":    basetypes.StringType{},
		"timezone":                     basetypes.StringType{},
		"updated_at":                   basetypes.StringType{},
		"url":                          basetypes.StringType{},
		"zipcode":                      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BillingConfigurationType{}

type BillingConfigurationType struct {
	basetypes.ObjectType
}

func (t BillingConfigurationType) Equal(o attr.Type) bool {
	other, ok := o.(BillingConfigurationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BillingConfigurationType) String() string {
	return "BillingConfigurationType"
}

func (t BillingConfigurationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	documentLocaleAttribute, ok := attributes["document_locale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`document_locale is missing from object`)

		return nil, diags
	}

	documentLocaleVal, ok := documentLocaleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`document_locale expected to be basetypes.StringValue, was: %T`, documentLocaleAttribute))
	}

	invoiceGracePeriodAttribute, ok := attributes["invoice_grace_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_grace_period is missing from object`)

		return nil, diags
	}

	invoiceGracePeriodVal, ok := invoiceGracePeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_grace_period expected to be basetypes.Int64Value, was: %T`, invoiceGracePeriodAttribute))
	}

	paymentProviderAttribute, ok := attributes["payment_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_provider is missing from object`)

		return nil, diags
	}

	paymentProviderVal, ok := paymentProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_provider expected to be basetypes.StringValue, was: %T`, paymentProviderAttribute))
	}

	paymentProviderCodeAttribute, ok := attributes["payment_provider_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_provider_code is missing from object`)

		return nil, diags
	}

	paymentProviderCodeVal, ok := paymentProviderCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_provider_code expected to be basetypes.StringValue, was: %T`, paymentProviderCodeAttribute))
	}

	providerCustomerIdAttribute, ok := attributes["provider_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_customer_id is missing from object`)

		return nil, diags
	}

	providerCustomerIdVal, ok := providerCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_customer_id expected to be basetypes.StringValue, was: %T`, providerCustomerIdAttribute))
	}

	providerPaymentMethodsAttribute, ok := attributes["provider_payment_methods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_payment_methods is missing from object`)

		return nil, diags
	}

	providerPaymentMethodsVal, ok := providerPaymentMethodsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_payment_methods expected to be basetypes.ListValue, was: %T`, providerPaymentMethodsAttribute))
	}

	syncAttribute, ok := attributes["sync"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync is missing from object`)

		return nil, diags
	}

	syncVal, ok := syncAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync expected to be basetypes.BoolValue, was: %T`, syncAttribute))
	}

	syncWithProviderAttribute, ok := attributes["sync_with_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync_with_provider is missing from object`)

		return nil, diags
	}

	syncWithProviderVal, ok := syncWithProviderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync_with_provider expected to be basetypes.BoolValue, was: %T`, syncWithProviderAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BillingConfigurationValue{
		DocumentLocale:         documentLocaleVal,
		InvoiceGracePeriod:     invoiceGracePeriodVal,
		PaymentProvider:        paymentProviderVal,
		PaymentProviderCode:    paymentProviderCodeVal,
		ProviderCustomerId:     providerCustomerIdVal,
		ProviderPaymentMethods: providerPaymentMethodsVal,
		Sync:                   syncVal,
		SyncWithProvider:       syncWithProviderVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBillingConfigurationValueNull() BillingConfigurationValue {
	return BillingConfigurationValue{
		state: attr.ValueStateNull,
	}
}

func NewBillingConfigurationValueUnknown() BillingConfigurationValue {
	return BillingConfigurationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBillingConfigurationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BillingConfigurationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BillingConfigurationValue Attribute Value",
				"While creating a BillingConfigurationValue value, a missing attribute value was detected. "+
					"A BillingConfigurationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BillingConfigurationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BillingConfigurationValue Attribute Type",
				"While creating a BillingConfigurationValue value, an invalid attribute value was detected. "+
					"A BillingConfigurationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BillingConfigurationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BillingConfigurationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BillingConfigurationValue Attribute Value",
				"While creating a BillingConfigurationValue value, an extra attribute value was detected. "+
					"A BillingConfigurationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BillingConfigurationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBillingConfigurationValueUnknown(), diags
	}

	documentLocaleAttribute, ok := attributes["document_locale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`document_locale is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	documentLocaleVal, ok := documentLocaleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`document_locale expected to be basetypes.StringValue, was: %T`, documentLocaleAttribute))
	}

	invoiceGracePeriodAttribute, ok := attributes["invoice_grace_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_grace_period is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	invoiceGracePeriodVal, ok := invoiceGracePeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_grace_period expected to be basetypes.Int64Value, was: %T`, invoiceGracePeriodAttribute))
	}

	paymentProviderAttribute, ok := attributes["payment_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_provider is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	paymentProviderVal, ok := paymentProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_provider expected to be basetypes.StringValue, was: %T`, paymentProviderAttribute))
	}

	paymentProviderCodeAttribute, ok := attributes["payment_provider_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_provider_code is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	paymentProviderCodeVal, ok := paymentProviderCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_provider_code expected to be basetypes.StringValue, was: %T`, paymentProviderCodeAttribute))
	}

	providerCustomerIdAttribute, ok := attributes["provider_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_customer_id is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	providerCustomerIdVal, ok := providerCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_customer_id expected to be basetypes.StringValue, was: %T`, providerCustomerIdAttribute))
	}

	providerPaymentMethodsAttribute, ok := attributes["provider_payment_methods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_payment_methods is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	providerPaymentMethodsVal, ok := providerPaymentMethodsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_payment_methods expected to be basetypes.ListValue, was: %T`, providerPaymentMethodsAttribute))
	}

	syncAttribute, ok := attributes["sync"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	syncVal, ok := syncAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync expected to be basetypes.BoolValue, was: %T`, syncAttribute))
	}

	syncWithProviderAttribute, ok := attributes["sync_with_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync_with_provider is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	syncWithProviderVal, ok := syncWithProviderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync_with_provider expected to be basetypes.BoolValue, was: %T`, syncWithProviderAttribute))
	}

	if diags.HasError() {
		return NewBillingConfigurationValueUnknown(), diags
	}

	return BillingConfigurationValue{
		DocumentLocale:         documentLocaleVal,
		InvoiceGracePeriod:     invoiceGracePeriodVal,
		PaymentProvider:        paymentProviderVal,
		PaymentProviderCode:    paymentProviderCodeVal,
		ProviderCustomerId:     providerCustomerIdVal,
		ProviderPaymentMethods: providerPaymentMethodsVal,
		Sync:                   syncVal,
		SyncWithProvider:       syncWithProviderVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBillingConfigurationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BillingConfigurationValue {
	object, diags := NewBillingConfigurationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBillingConfigurationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BillingConfigurationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBillingConfigurationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBillingConfigurationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBillingConfigurationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBillingConfigurationValueMust(BillingConfigurationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BillingConfigurationType) ValueType(ctx context.Context) attr.Value {
	return BillingConfigurationValue{}
}

var _ basetypes.ObjectValuable = BillingConfigurationValue{}

type BillingConfigurationValue struct {
	DocumentLocale         basetypes.StringValue `tfsdk:"document_locale"`
	InvoiceGracePeriod     basetypes.Int64Value  `tfsdk:"invoice_grace_period"`
	PaymentProvider        basetypes.StringValue `tfsdk:"payment_provider"`
	PaymentProviderCode    basetypes.StringValue `tfsdk:"payment_provider_code"`
	ProviderCustomerId     basetypes.StringValue `tfsdk:"provider_customer_id"`
	ProviderPaymentMethods basetypes.ListValue   `tfsdk:"provider_payment_methods"`
	Sync                   basetypes.BoolValue   `tfsdk:"sync"`
	SyncWithProvider       basetypes.BoolValue   `tfsdk:"sync_with_provider"`
	state                  attr.ValueState
}

func (v BillingConfigurationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["document_locale"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_grace_period"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["payment_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["payment_provider_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["provider_customer_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["provider_payment_methods"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["sync"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sync_with_provider"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.DocumentLocale.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["document_locale"] = val

		val, err = v.InvoiceGracePeriod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_grace_period"] = val

		val, err = v.PaymentProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_provider"] = val

		val, err = v.PaymentProviderCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_provider_code"] = val

		val, err = v.ProviderCustomerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provider_customer_id"] = val

		val, err = v.ProviderPaymentMethods.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provider_payment_methods"] = val

		val, err = v.Sync.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sync"] = val

		val, err = v.SyncWithProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sync_with_provider"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BillingConfigurationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BillingConfigurationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BillingConfigurationValue) String() string {
	return "BillingConfigurationValue"
}

func (v BillingConfigurationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var providerPaymentMethodsVal basetypes.ListValue
	switch {
	case v.ProviderPaymentMethods.IsUnknown():
		providerPaymentMethodsVal = types.ListUnknown(types.StringType)
	case v.ProviderPaymentMethods.IsNull():
		providerPaymentMethodsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		providerPaymentMethodsVal, d = types.ListValue(types.StringType, v.ProviderPaymentMethods.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"document_locale":       basetypes.StringType{},
			"invoice_grace_period":  basetypes.Int64Type{},
			"payment_provider":      basetypes.StringType{},
			"payment_provider_code": basetypes.StringType{},
			"provider_customer_id":  basetypes.StringType{},
			"provider_payment_methods": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sync":               basetypes.BoolType{},
			"sync_with_provider": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"document_locale":       basetypes.StringType{},
		"invoice_grace_period":  basetypes.Int64Type{},
		"payment_provider":      basetypes.StringType{},
		"payment_provider_code": basetypes.StringType{},
		"provider_customer_id":  basetypes.StringType{},
		"provider_payment_methods": basetypes.ListType{
			ElemType: types.StringType,
		},
		"sync":               basetypes.BoolType{},
		"sync_with_provider": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"document_locale":          v.DocumentLocale,
			"invoice_grace_period":     v.InvoiceGracePeriod,
			"payment_provider":         v.PaymentProvider,
			"payment_provider_code":    v.PaymentProviderCode,
			"provider_customer_id":     v.ProviderCustomerId,
			"provider_payment_methods": providerPaymentMethodsVal,
			"sync":                     v.Sync,
			"sync_with_provider":       v.SyncWithProvider,
		})

	return objVal, diags
}

func (v BillingConfigurationValue) Equal(o attr.Value) bool {
	other, ok := o.(BillingConfigurationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DocumentLocale.Equal(other.DocumentLocale) {
		return false
	}

	if !v.InvoiceGracePeriod.Equal(other.InvoiceGracePeriod) {
		return false
	}

	if !v.PaymentProvider.Equal(other.PaymentProvider) {
		return false
	}

	if !v.PaymentProviderCode.Equal(other.PaymentProviderCode) {
		return false
	}

	if !v.ProviderCustomerId.Equal(other.ProviderCustomerId) {
		return false
	}

	if !v.ProviderPaymentMethods.Equal(other.ProviderPaymentMethods) {
		return false
	}

	if !v.Sync.Equal(other.Sync) {
		return false
	}

	if !v.SyncWithProvider.Equal(other.SyncWithProvider) {
		return false
	}

	return true
}

func (v BillingConfigurationValue) Type(ctx context.Context) attr.Type {
	return BillingConfigurationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BillingConfigurationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"document_locale":       basetypes.StringType{},
		"invoice_grace_period":  basetypes.Int64Type{},
		"payment_provider":      basetypes.StringType{},
		"payment_provider_code": basetypes.StringType{},
		"provider_customer_id":  basetypes.StringType{},
		"provider_payment_methods": basetypes.ListType{
			ElemType: types.StringType,
		},
		"sync":               basetypes.BoolType{},
		"sync_with_provider": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	displayInInvoiceAttribute, ok := attributes["display_in_invoice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_in_invoice is missing from object`)

		return nil, diags
	}

	displayInInvoiceVal, ok := displayInInvoiceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_in_invoice expected to be basetypes.BoolValue, was: %T`, displayInInvoiceAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		CreatedAt:        createdAtVal,
		DisplayInInvoice: displayInInvoiceVal,
		Key:              keyVal,
		LagoId:           lagoIdVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	displayInInvoiceAttribute, ok := attributes["display_in_invoice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_in_invoice is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	displayInInvoiceVal, ok := displayInInvoiceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_in_invoice expected to be basetypes.BoolValue, was: %T`, displayInInvoiceAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		CreatedAt:        createdAtVal,
		DisplayInInvoice: displayInInvoiceVal,
		Key:              keyVal,
		LagoId:           lagoIdVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	CreatedAt        basetypes.StringValue `tfsdk:"created_at"`
	DisplayInInvoice basetypes.BoolValue   `tfsdk:"display_in_invoice"`
	Key              basetypes.StringValue `tfsdk:"key"`
	LagoId           basetypes.StringValue `tfsdk:"lago_id"`
	Value            basetypes.StringValue `tfsdk:"value"`
	state            attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["display_in_invoice"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.DisplayInInvoice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_in_invoice"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created_at":         basetypes.StringType{},
		"display_in_invoice": basetypes.BoolType{},
		"key":                basetypes.StringType{},
		"lago_id":            basetypes.StringType{},
		"value":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_at":         v.CreatedAt,
			"display_in_invoice": v.DisplayInInvoice,
			"key":                v.Key,
			"lago_id":            v.LagoId,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.DisplayInInvoice.Equal(other.DisplayInInvoice) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_at":         basetypes.StringType{},
		"display_in_invoice": basetypes.BoolType{},
		"key":                basetypes.StringType{},
		"lago_id":            basetypes.StringType{},
		"value":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ShippingAddressType{}

type ShippingAddressType struct {
	basetypes.ObjectType
}

func (t ShippingAddressType) Equal(o attr.Type) bool {
	other, ok := o.(ShippingAddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ShippingAddressType) String() string {
	return "ShippingAddressType"
}

func (t ShippingAddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressLine1Attribute, ok := attributes["address_line1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line1 is missing from object`)

		return nil, diags
	}

	addressLine1Val, ok := addressLine1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line1 expected to be basetypes.StringValue, was: %T`, addressLine1Attribute))
	}

	addressLine2Attribute, ok := attributes["address_line2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line2 is missing from object`)

		return nil, diags
	}

	addressLine2Val, ok := addressLine2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line2 expected to be basetypes.StringValue, was: %T`, addressLine2Attribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return nil, diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return nil, diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	zipcodeAttribute, ok := attributes["zipcode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zipcode is missing from object`)

		return nil, diags
	}

	zipcodeVal, ok := zipcodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zipcode expected to be basetypes.StringValue, was: %T`, zipcodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ShippingAddressValue{
		AddressLine1: addressLine1Val,
		AddressLine2: addressLine2Val,
		City:         cityVal,
		Country:      countryVal,
		State:        stateVal,
		Zipcode:      zipcodeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewShippingAddressValueNull() ShippingAddressValue {
	return ShippingAddressValue{
		state: attr.ValueStateNull,
	}
}

func NewShippingAddressValueUnknown() ShippingAddressValue {
	return ShippingAddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewShippingAddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ShippingAddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ShippingAddressValue Attribute Value",
				"While creating a ShippingAddressValue value, a missing attribute value was detected. "+
					"A ShippingAddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ShippingAddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ShippingAddressValue Attribute Type",
				"While creating a ShippingAddressValue value, an invalid attribute value was detected. "+
					"A ShippingAddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ShippingAddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ShippingAddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ShippingAddressValue Attribute Value",
				"While creating a ShippingAddressValue value, an extra attribute value was detected. "+
					"A ShippingAddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ShippingAddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewShippingAddressValueUnknown(), diags
	}

	addressLine1Attribute, ok := attributes["address_line1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line1 is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	addressLine1Val, ok := addressLine1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line1 expected to be basetypes.StringValue, was: %T`, addressLine1Attribute))
	}

	addressLine2Attribute, ok := attributes["address_line2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line2 is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	addressLine2Val, ok := addressLine2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line2 expected to be basetypes.StringValue, was: %T`, addressLine2Attribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	zipcodeAttribute, ok := attributes["zipcode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zipcode is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	zipcodeVal, ok := zipcodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zipcode expected to be basetypes.StringValue, was: %T`, zipcodeAttribute))
	}

	if diags.HasError() {
		return NewShippingAddressValueUnknown(), diags
	}

	return ShippingAddressValue{
		AddressLine1: addressLine1Val,
		AddressLine2: addressLine2Val,
		City:         cityVal,
		Country:      countryVal,
		State:        stateVal,
		Zipcode:      zipcodeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewShippingAddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ShippingAddressValue {
	object, diags := NewShippingAddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewShippingAddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ShippingAddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewShippingAddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewShippingAddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewShippingAddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewShippingAddressValueMust(ShippingAddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ShippingAddressType) ValueType(ctx context.Context) attr.Value {
	return ShippingAddressValue{}
}

var _ basetypes.ObjectValuable = ShippingAddressValue{}

type ShippingAddressValue struct {
	AddressLine1 basetypes.StringValue `tfsdk:"address_line1"`
	AddressLine2 basetypes.StringValue `tfsdk:"address_line2"`
	City         basetypes.StringValue `tfsdk:"city"`
	Country      basetypes.StringValue `tfsdk:"country"`
	State        basetypes.StringValue `tfsdk:"state"`
	Zipcode      basetypes.StringValue `tfsdk:"zipcode"`
	state        attr.ValueState
}

func (v ShippingAddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["address_line1"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["address_line2"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["city"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["country"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["zipcode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.AddressLine1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_line1"] = val

		val, err = v.AddressLine2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_line2"] = val

		val, err = v.City.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["city"] = val

		val, err = v.Country.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Zipcode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["zipcode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ShippingAddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ShippingAddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ShippingAddressValue) String() string {
	return "ShippingAddressValue"
}

func (v ShippingAddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"address_line1": basetypes.StringType{},
		"address_line2": basetypes.StringType{},
		"city":          basetypes.StringType{},
		"country":       basetypes.StringType{},
		"state":         basetypes.StringType{},
		"zipcode":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_line1": v.AddressLine1,
			"address_line2": v.AddressLine2,
			"city":          v.City,
			"country":       v.Country,
			"state":         v.State,
			"zipcode":       v.Zipcode,
		})

	return objVal, diags
}

func (v ShippingAddressValue) Equal(o attr.Value) bool {
	other, ok := o.(ShippingAddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressLine1.Equal(other.AddressLine1) {
		return false
	}

	if !v.AddressLine2.Equal(other.AddressLine2) {
		return false
	}

	if !v.City.Equal(other.City) {
		return false
	}

	if !v.Country.Equal(other.Country) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Zipcode.Equal(other.Zipcode) {
		return false
	}

	return true
}

func (v ShippingAddressValue) Type(ctx context.Context) attr.Type {
	return ShippingAddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ShippingAddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_line1": basetypes.StringType{},
		"address_line2": basetypes.StringType{},
		"city":          basetypes.StringType{},
		"country":       basetypes.StringType{},
		"state":         basetypes.StringType{},
		"zipcode":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InvoicesType{}

type InvoicesType struct {
	basetypes.ObjectType
}

func (t InvoicesType) Equal(o attr.Type) bool {
	other, ok := o.(InvoicesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InvoicesType) String() string {
	return "InvoicesType"
}

func (t InvoicesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	couponsAmountCentsAttribute, ok := attributes["coupons_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coupons_amount_cents is missing from object`)

		return nil, diags
	}

	couponsAmountCentsVal, ok := couponsAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coupons_amount_cents expected to be basetypes.Int64Value, was: %T`, couponsAmountCentsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	creditNotesAmountCentsAttribute, ok := attributes["credit_notes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credit_notes_amount_cents is missing from object`)

		return nil, diags
	}

	creditNotesAmountCentsVal, ok := creditNotesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credit_notes_amount_cents expected to be basetypes.Int64Value, was: %T`, creditNotesAmountCentsAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return nil, diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	feesAmountCentsAttribute, ok := attributes["fees_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fees_amount_cents is missing from object`)

		return nil, diags
	}

	feesAmountCentsVal, ok := feesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fees_amount_cents expected to be basetypes.Int64Value, was: %T`, feesAmountCentsAttribute))
	}

	fileUrlAttribute, ok := attributes["file_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file_url is missing from object`)

		return nil, diags
	}

	fileUrlVal, ok := fileUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file_url expected to be basetypes.StringValue, was: %T`, fileUrlAttribute))
	}

	invoiceTypeAttribute, ok := attributes["invoice_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_type is missing from object`)

		return nil, diags
	}

	invoiceTypeVal, ok := invoiceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_type expected to be basetypes.StringValue, was: %T`, invoiceTypeAttribute))
	}

	issuingDateAttribute, ok := attributes["issuing_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`issuing_date is missing from object`)

		return nil, diags
	}

	issuingDateVal, ok := issuingDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`issuing_date expected to be basetypes.StringValue, was: %T`, issuingDateAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	netPaymentTermAttribute, ok := attributes["net_payment_term"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_payment_term is missing from object`)

		return nil, diags
	}

	netPaymentTermVal, ok := netPaymentTermAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_payment_term expected to be basetypes.Int64Value, was: %T`, netPaymentTermAttribute))
	}

	numberAttribute, ok := attributes["number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number is missing from object`)

		return nil, diags
	}

	numberVal, ok := numberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number expected to be basetypes.StringValue, was: %T`, numberAttribute))
	}

	paymentDisputeLostAtAttribute, ok := attributes["payment_dispute_lost_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_dispute_lost_at is missing from object`)

		return nil, diags
	}

	paymentDisputeLostAtVal, ok := paymentDisputeLostAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_dispute_lost_at expected to be basetypes.StringValue, was: %T`, paymentDisputeLostAtAttribute))
	}

	paymentDueDateAttribute, ok := attributes["payment_due_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_due_date is missing from object`)

		return nil, diags
	}

	paymentDueDateVal, ok := paymentDueDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_due_date expected to be basetypes.StringValue, was: %T`, paymentDueDateAttribute))
	}

	paymentOverdueAttribute, ok := attributes["payment_overdue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_overdue is missing from object`)

		return nil, diags
	}

	paymentOverdueVal, ok := paymentOverdueAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_overdue expected to be basetypes.BoolValue, was: %T`, paymentOverdueAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return nil, diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	prepaidCreditAmountCentsAttribute, ok := attributes["prepaid_credit_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepaid_credit_amount_cents is missing from object`)

		return nil, diags
	}

	prepaidCreditAmountCentsVal, ok := prepaidCreditAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepaid_credit_amount_cents expected to be basetypes.Int64Value, was: %T`, prepaidCreditAmountCentsAttribute))
	}

	progressiveBillingCreditAmountCentsAttribute, ok := attributes["progressive_billing_credit_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progressive_billing_credit_amount_cents is missing from object`)

		return nil, diags
	}

	progressiveBillingCreditAmountCentsVal, ok := progressiveBillingCreditAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progressive_billing_credit_amount_cents expected to be basetypes.Int64Value, was: %T`, progressiveBillingCreditAmountCentsAttribute))
	}

	selfBilledAttribute, ok := attributes["self_billed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self_billed is missing from object`)

		return nil, diags
	}

	selfBilledVal, ok := selfBilledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self_billed expected to be basetypes.BoolValue, was: %T`, selfBilledAttribute))
	}

	sequentialIdAttribute, ok := attributes["sequential_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sequential_id is missing from object`)

		return nil, diags
	}

	sequentialIdVal, ok := sequentialIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sequential_id expected to be basetypes.Int64Value, was: %T`, sequentialIdAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	subTotalExcludingTaxesAmountCentsAttribute, ok := attributes["sub_total_excluding_taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_total_excluding_taxes_amount_cents is missing from object`)

		return nil, diags
	}

	subTotalExcludingTaxesAmountCentsVal, ok := subTotalExcludingTaxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_total_excluding_taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, subTotalExcludingTaxesAmountCentsAttribute))
	}

	subTotalIncludingTaxesAmountCentsAttribute, ok := attributes["sub_total_including_taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_total_including_taxes_amount_cents is missing from object`)

		return nil, diags
	}

	subTotalIncludingTaxesAmountCentsVal, ok := subTotalIncludingTaxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_total_including_taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, subTotalIncludingTaxesAmountCentsAttribute))
	}

	taxesAmountCentsAttribute, ok := attributes["taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes_amount_cents is missing from object`)

		return nil, diags
	}

	taxesAmountCentsVal, ok := taxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, taxesAmountCentsAttribute))
	}

	totalAmountCentsAttribute, ok := attributes["total_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_amount_cents is missing from object`)

		return nil, diags
	}

	totalAmountCentsVal, ok := totalAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_amount_cents expected to be basetypes.Int64Value, was: %T`, totalAmountCentsAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return nil, diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	versionNumberAttribute, ok := attributes["version_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version_number is missing from object`)

		return nil, diags
	}

	versionNumberVal, ok := versionNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version_number expected to be basetypes.Int64Value, was: %T`, versionNumberAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InvoicesValue{
		CouponsAmountCents:                  couponsAmountCentsVal,
		CreatedAt:                           createdAtVal,
		CreditNotesAmountCents:              creditNotesAmountCentsVal,
		Currency:                            currencyVal,
		FeesAmountCents:                     feesAmountCentsVal,
		FileUrl:                             fileUrlVal,
		InvoiceType:                         invoiceTypeVal,
		IssuingDate:                         issuingDateVal,
		LagoId:                              lagoIdVal,
		NetPaymentTerm:                      netPaymentTermVal,
		Number:                              numberVal,
		PaymentDisputeLostAt:                paymentDisputeLostAtVal,
		PaymentDueDate:                      paymentDueDateVal,
		PaymentOverdue:                      paymentOverdueVal,
		PaymentStatus:                       paymentStatusVal,
		PrepaidCreditAmountCents:            prepaidCreditAmountCentsVal,
		ProgressiveBillingCreditAmountCents: progressiveBillingCreditAmountCentsVal,
		SelfBilled:                          selfBilledVal,
		SequentialId:                        sequentialIdVal,
		Status:                              statusVal,
		SubTotalExcludingTaxesAmountCents:   subTotalExcludingTaxesAmountCentsVal,
		SubTotalIncludingTaxesAmountCents:   subTotalIncludingTaxesAmountCentsVal,
		TaxesAmountCents:                    taxesAmountCentsVal,
		TotalAmountCents:                    totalAmountCentsVal,
		UpdatedAt:                           updatedAtVal,
		VersionNumber:                       versionNumberVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewInvoicesValueNull() InvoicesValue {
	return InvoicesValue{
		state: attr.ValueStateNull,
	}
}

func NewInvoicesValueUnknown() InvoicesValue {
	return InvoicesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInvoicesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InvoicesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InvoicesValue Attribute Value",
				"While creating a InvoicesValue value, a missing attribute value was detected. "+
					"A InvoicesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InvoicesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InvoicesValue Attribute Type",
				"While creating a InvoicesValue value, an invalid attribute value was detected. "+
					"A InvoicesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InvoicesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InvoicesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InvoicesValue Attribute Value",
				"While creating a InvoicesValue value, an extra attribute value was detected. "+
					"A InvoicesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InvoicesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInvoicesValueUnknown(), diags
	}

	couponsAmountCentsAttribute, ok := attributes["coupons_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coupons_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	couponsAmountCentsVal, ok := couponsAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coupons_amount_cents expected to be basetypes.Int64Value, was: %T`, couponsAmountCentsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	creditNotesAmountCentsAttribute, ok := attributes["credit_notes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`credit_notes_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	creditNotesAmountCentsVal, ok := creditNotesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`credit_notes_amount_cents expected to be basetypes.Int64Value, was: %T`, creditNotesAmountCentsAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	feesAmountCentsAttribute, ok := attributes["fees_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fees_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	feesAmountCentsVal, ok := feesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fees_amount_cents expected to be basetypes.Int64Value, was: %T`, feesAmountCentsAttribute))
	}

	fileUrlAttribute, ok := attributes["file_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file_url is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	fileUrlVal, ok := fileUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file_url expected to be basetypes.StringValue, was: %T`, fileUrlAttribute))
	}

	invoiceTypeAttribute, ok := attributes["invoice_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_type is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	invoiceTypeVal, ok := invoiceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_type expected to be basetypes.StringValue, was: %T`, invoiceTypeAttribute))
	}

	issuingDateAttribute, ok := attributes["issuing_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`issuing_date is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	issuingDateVal, ok := issuingDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`issuing_date expected to be basetypes.StringValue, was: %T`, issuingDateAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	netPaymentTermAttribute, ok := attributes["net_payment_term"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_payment_term is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	netPaymentTermVal, ok := netPaymentTermAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_payment_term expected to be basetypes.Int64Value, was: %T`, netPaymentTermAttribute))
	}

	numberAttribute, ok := attributes["number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`number is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	numberVal, ok := numberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`number expected to be basetypes.StringValue, was: %T`, numberAttribute))
	}

	paymentDisputeLostAtAttribute, ok := attributes["payment_dispute_lost_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_dispute_lost_at is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	paymentDisputeLostAtVal, ok := paymentDisputeLostAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_dispute_lost_at expected to be basetypes.StringValue, was: %T`, paymentDisputeLostAtAttribute))
	}

	paymentDueDateAttribute, ok := attributes["payment_due_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_due_date is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	paymentDueDateVal, ok := paymentDueDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_due_date expected to be basetypes.StringValue, was: %T`, paymentDueDateAttribute))
	}

	paymentOverdueAttribute, ok := attributes["payment_overdue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_overdue is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	paymentOverdueVal, ok := paymentOverdueAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_overdue expected to be basetypes.BoolValue, was: %T`, paymentOverdueAttribute))
	}

	paymentStatusAttribute, ok := attributes["payment_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_status is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	paymentStatusVal, ok := paymentStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_status expected to be basetypes.StringValue, was: %T`, paymentStatusAttribute))
	}

	prepaidCreditAmountCentsAttribute, ok := attributes["prepaid_credit_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepaid_credit_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	prepaidCreditAmountCentsVal, ok := prepaidCreditAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepaid_credit_amount_cents expected to be basetypes.Int64Value, was: %T`, prepaidCreditAmountCentsAttribute))
	}

	progressiveBillingCreditAmountCentsAttribute, ok := attributes["progressive_billing_credit_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progressive_billing_credit_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	progressiveBillingCreditAmountCentsVal, ok := progressiveBillingCreditAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progressive_billing_credit_amount_cents expected to be basetypes.Int64Value, was: %T`, progressiveBillingCreditAmountCentsAttribute))
	}

	selfBilledAttribute, ok := attributes["self_billed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`self_billed is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	selfBilledVal, ok := selfBilledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`self_billed expected to be basetypes.BoolValue, was: %T`, selfBilledAttribute))
	}

	sequentialIdAttribute, ok := attributes["sequential_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sequential_id is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	sequentialIdVal, ok := sequentialIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sequential_id expected to be basetypes.Int64Value, was: %T`, sequentialIdAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	subTotalExcludingTaxesAmountCentsAttribute, ok := attributes["sub_total_excluding_taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_total_excluding_taxes_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	subTotalExcludingTaxesAmountCentsVal, ok := subTotalExcludingTaxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_total_excluding_taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, subTotalExcludingTaxesAmountCentsAttribute))
	}

	subTotalIncludingTaxesAmountCentsAttribute, ok := attributes["sub_total_including_taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_total_including_taxes_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	subTotalIncludingTaxesAmountCentsVal, ok := subTotalIncludingTaxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_total_including_taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, subTotalIncludingTaxesAmountCentsAttribute))
	}

	taxesAmountCentsAttribute, ok := attributes["taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	taxesAmountCentsVal, ok := taxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, taxesAmountCentsAttribute))
	}

	totalAmountCentsAttribute, ok := attributes["total_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_amount_cents is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	totalAmountCentsVal, ok := totalAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_amount_cents expected to be basetypes.Int64Value, was: %T`, totalAmountCentsAttribute))
	}

	updatedAtAttribute, ok := attributes["updated_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`updated_at is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	updatedAtVal, ok := updatedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`updated_at expected to be basetypes.StringValue, was: %T`, updatedAtAttribute))
	}

	versionNumberAttribute, ok := attributes["version_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version_number is missing from object`)

		return NewInvoicesValueUnknown(), diags
	}

	versionNumberVal, ok := versionNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version_number expected to be basetypes.Int64Value, was: %T`, versionNumberAttribute))
	}

	if diags.HasError() {
		return NewInvoicesValueUnknown(), diags
	}

	return InvoicesValue{
		CouponsAmountCents:                  couponsAmountCentsVal,
		CreatedAt:                           createdAtVal,
		CreditNotesAmountCents:              creditNotesAmountCentsVal,
		Currency:                            currencyVal,
		FeesAmountCents:                     feesAmountCentsVal,
		FileUrl:                             fileUrlVal,
		InvoiceType:                         invoiceTypeVal,
		IssuingDate:                         issuingDateVal,
		LagoId:                              lagoIdVal,
		NetPaymentTerm:                      netPaymentTermVal,
		Number:                              numberVal,
		PaymentDisputeLostAt:                paymentDisputeLostAtVal,
		PaymentDueDate:                      paymentDueDateVal,
		PaymentOverdue:                      paymentOverdueVal,
		PaymentStatus:                       paymentStatusVal,
		PrepaidCreditAmountCents:            prepaidCreditAmountCentsVal,
		ProgressiveBillingCreditAmountCents: progressiveBillingCreditAmountCentsVal,
		SelfBilled:                          selfBilledVal,
		SequentialId:                        sequentialIdVal,
		Status:                              statusVal,
		SubTotalExcludingTaxesAmountCents:   subTotalExcludingTaxesAmountCentsVal,
		SubTotalIncludingTaxesAmountCents:   subTotalIncludingTaxesAmountCentsVal,
		TaxesAmountCents:                    taxesAmountCentsVal,
		TotalAmountCents:                    totalAmountCentsVal,
		UpdatedAt:                           updatedAtVal,
		VersionNumber:                       versionNumberVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewInvoicesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InvoicesValue {
	object, diags := NewInvoicesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInvoicesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InvoicesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInvoicesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInvoicesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInvoicesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInvoicesValueMust(InvoicesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InvoicesType) ValueType(ctx context.Context) attr.Value {
	return InvoicesValue{}
}

var _ basetypes.ObjectValuable = InvoicesValue{}

type InvoicesValue struct {
	CouponsAmountCents                  basetypes.Int64Value  `tfsdk:"coupons_amount_cents"`
	CreatedAt                           basetypes.StringValue `tfsdk:"created_at"`
	CreditNotesAmountCents              basetypes.Int64Value  `tfsdk:"credit_notes_amount_cents"`
	Currency                            basetypes.StringValue `tfsdk:"currency"`
	FeesAmountCents                     basetypes.Int64Value  `tfsdk:"fees_amount_cents"`
	FileUrl                             basetypes.StringValue `tfsdk:"file_url"`
	InvoiceType                         basetypes.StringValue `tfsdk:"invoice_type"`
	IssuingDate                         basetypes.StringValue `tfsdk:"issuing_date"`
	LagoId                              basetypes.StringValue `tfsdk:"lago_id"`
	NetPaymentTerm                      basetypes.Int64Value  `tfsdk:"net_payment_term"`
	Number                              basetypes.StringValue `tfsdk:"number"`
	PaymentDisputeLostAt                basetypes.StringValue `tfsdk:"payment_dispute_lost_at"`
	PaymentDueDate                      basetypes.StringValue `tfsdk:"payment_due_date"`
	PaymentOverdue                      basetypes.BoolValue   `tfsdk:"payment_overdue"`
	PaymentStatus                       basetypes.StringValue `tfsdk:"payment_status"`
	PrepaidCreditAmountCents            basetypes.Int64Value  `tfsdk:"prepaid_credit_amount_cents"`
	ProgressiveBillingCreditAmountCents basetypes.Int64Value  `tfsdk:"progressive_billing_credit_amount_cents"`
	SelfBilled                          basetypes.BoolValue   `tfsdk:"self_billed"`
	SequentialId                        basetypes.Int64Value  `tfsdk:"sequential_id"`
	Status                              basetypes.StringValue `tfsdk:"status"`
	SubTotalExcludingTaxesAmountCents   basetypes.Int64Value  `tfsdk:"sub_total_excluding_taxes_amount_cents"`
	SubTotalIncludingTaxesAmountCents   basetypes.Int64Value  `tfsdk:"sub_total_including_taxes_amount_cents"`
	TaxesAmountCents                    basetypes.Int64Value  `tfsdk:"taxes_amount_cents"`
	TotalAmountCents                    basetypes.Int64Value  `tfsdk:"total_amount_cents"`
	UpdatedAt                           basetypes.StringValue `tfsdk:"updated_at"`
	VersionNumber                       basetypes.Int64Value  `tfsdk:"version_number"`
	state                               attr.ValueState
}

func (v InvoicesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 26)

	var val tftypes.Value
	var err error

	attrTypes["coupons_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["credit_notes_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fees_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["file_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["issuing_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["net_payment_term"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["payment_dispute_lost_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["payment_due_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["payment_overdue"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["payment_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prepaid_credit_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["progressive_billing_credit_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["self_billed"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sequential_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sub_total_excluding_taxes_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["sub_total_including_taxes_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["taxes_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["updated_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version_number"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 26)

		val, err = v.CouponsAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coupons_amount_cents"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.CreditNotesAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["credit_notes_amount_cents"] = val

		val, err = v.Currency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["currency"] = val

		val, err = v.FeesAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fees_amount_cents"] = val

		val, err = v.FileUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["file_url"] = val

		val, err = v.InvoiceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_type"] = val

		val, err = v.IssuingDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["issuing_date"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.NetPaymentTerm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["net_payment_term"] = val

		val, err = v.Number.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["number"] = val

		val, err = v.PaymentDisputeLostAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_dispute_lost_at"] = val

		val, err = v.PaymentDueDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_due_date"] = val

		val, err = v.PaymentOverdue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_overdue"] = val

		val, err = v.PaymentStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_status"] = val

		val, err = v.PrepaidCreditAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prepaid_credit_amount_cents"] = val

		val, err = v.ProgressiveBillingCreditAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["progressive_billing_credit_amount_cents"] = val

		val, err = v.SelfBilled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["self_billed"] = val

		val, err = v.SequentialId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sequential_id"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.SubTotalExcludingTaxesAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sub_total_excluding_taxes_amount_cents"] = val

		val, err = v.SubTotalIncludingTaxesAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sub_total_including_taxes_amount_cents"] = val

		val, err = v.TaxesAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taxes_amount_cents"] = val

		val, err = v.TotalAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_amount_cents"] = val

		val, err = v.UpdatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["updated_at"] = val

		val, err = v.VersionNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version_number"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InvoicesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InvoicesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InvoicesValue) String() string {
	return "InvoicesValue"
}

func (v InvoicesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"coupons_amount_cents":        basetypes.Int64Type{},
		"created_at":                  basetypes.StringType{},
		"credit_notes_amount_cents":   basetypes.Int64Type{},
		"currency":                    basetypes.StringType{},
		"fees_amount_cents":           basetypes.Int64Type{},
		"file_url":                    basetypes.StringType{},
		"invoice_type":                basetypes.StringType{},
		"issuing_date":                basetypes.StringType{},
		"lago_id":                     basetypes.StringType{},
		"net_payment_term":            basetypes.Int64Type{},
		"number":                      basetypes.StringType{},
		"payment_dispute_lost_at":     basetypes.StringType{},
		"payment_due_date":            basetypes.StringType{},
		"payment_overdue":             basetypes.BoolType{},
		"payment_status":              basetypes.StringType{},
		"prepaid_credit_amount_cents": basetypes.Int64Type{},
		"progressive_billing_credit_amount_cents": basetypes.Int64Type{},
		"self_billed":                            basetypes.BoolType{},
		"sequential_id":                          basetypes.Int64Type{},
		"status":                                 basetypes.StringType{},
		"sub_total_excluding_taxes_amount_cents": basetypes.Int64Type{},
		"sub_total_including_taxes_amount_cents": basetypes.Int64Type{},
		"taxes_amount_cents":                     basetypes.Int64Type{},
		"total_amount_cents":                     basetypes.Int64Type{},
		"updated_at":                             basetypes.StringType{},
		"version_number":                         basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"coupons_amount_cents":        v.CouponsAmountCents,
			"created_at":                  v.CreatedAt,
			"credit_notes_amount_cents":   v.CreditNotesAmountCents,
			"currency":                    v.Currency,
			"fees_amount_cents":           v.FeesAmountCents,
			"file_url":                    v.FileUrl,
			"invoice_type":                v.InvoiceType,
			"issuing_date":                v.IssuingDate,
			"lago_id":                     v.LagoId,
			"net_payment_term":            v.NetPaymentTerm,
			"number":                      v.Number,
			"payment_dispute_lost_at":     v.PaymentDisputeLostAt,
			"payment_due_date":            v.PaymentDueDate,
			"payment_overdue":             v.PaymentOverdue,
			"payment_status":              v.PaymentStatus,
			"prepaid_credit_amount_cents": v.PrepaidCreditAmountCents,
			"progressive_billing_credit_amount_cents": v.ProgressiveBillingCreditAmountCents,
			"self_billed":                            v.SelfBilled,
			"sequential_id":                          v.SequentialId,
			"status":                                 v.Status,
			"sub_total_excluding_taxes_amount_cents": v.SubTotalExcludingTaxesAmountCents,
			"sub_total_including_taxes_amount_cents": v.SubTotalIncludingTaxesAmountCents,
			"taxes_amount_cents":                     v.TaxesAmountCents,
			"total_amount_cents":                     v.TotalAmountCents,
			"updated_at":                             v.UpdatedAt,
			"version_number":                         v.VersionNumber,
		})

	return objVal, diags
}

func (v InvoicesValue) Equal(o attr.Value) bool {
	other, ok := o.(InvoicesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CouponsAmountCents.Equal(other.CouponsAmountCents) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.CreditNotesAmountCents.Equal(other.CreditNotesAmountCents) {
		return false
	}

	if !v.Currency.Equal(other.Currency) {
		return false
	}

	if !v.FeesAmountCents.Equal(other.FeesAmountCents) {
		return false
	}

	if !v.FileUrl.Equal(other.FileUrl) {
		return false
	}

	if !v.InvoiceType.Equal(other.InvoiceType) {
		return false
	}

	if !v.IssuingDate.Equal(other.IssuingDate) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.NetPaymentTerm.Equal(other.NetPaymentTerm) {
		return false
	}

	if !v.Number.Equal(other.Number) {
		return false
	}

	if !v.PaymentDisputeLostAt.Equal(other.PaymentDisputeLostAt) {
		return false
	}

	if !v.PaymentDueDate.Equal(other.PaymentDueDate) {
		return false
	}

	if !v.PaymentOverdue.Equal(other.PaymentOverdue) {
		return false
	}

	if !v.PaymentStatus.Equal(other.PaymentStatus) {
		return false
	}

	if !v.PrepaidCreditAmountCents.Equal(other.PrepaidCreditAmountCents) {
		return false
	}

	if !v.ProgressiveBillingCreditAmountCents.Equal(other.ProgressiveBillingCreditAmountCents) {
		return false
	}

	if !v.SelfBilled.Equal(other.SelfBilled) {
		return false
	}

	if !v.SequentialId.Equal(other.SequentialId) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.SubTotalExcludingTaxesAmountCents.Equal(other.SubTotalExcludingTaxesAmountCents) {
		return false
	}

	if !v.SubTotalIncludingTaxesAmountCents.Equal(other.SubTotalIncludingTaxesAmountCents) {
		return false
	}

	if !v.TaxesAmountCents.Equal(other.TaxesAmountCents) {
		return false
	}

	if !v.TotalAmountCents.Equal(other.TotalAmountCents) {
		return false
	}

	if !v.UpdatedAt.Equal(other.UpdatedAt) {
		return false
	}

	if !v.VersionNumber.Equal(other.VersionNumber) {
		return false
	}

	return true
}

func (v InvoicesValue) Type(ctx context.Context) attr.Type {
	return InvoicesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InvoicesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"coupons_amount_cents":        basetypes.Int64Type{},
		"created_at":                  basetypes.StringType{},
		"credit_notes_amount_cents":   basetypes.Int64Type{},
		"currency":                    basetypes.StringType{},
		"fees_amount_cents":           basetypes.Int64Type{},
		"file_url":                    basetypes.StringType{},
		"invoice_type":                basetypes.StringType{},
		"issuing_date":                basetypes.StringType{},
		"lago_id":                     basetypes.StringType{},
		"net_payment_term":            basetypes.Int64Type{},
		"number":                      basetypes.StringType{},
		"payment_dispute_lost_at":     basetypes.StringType{},
		"payment_due_date":            basetypes.StringType{},
		"payment_overdue":             basetypes.BoolType{},
		"payment_status":              basetypes.StringType{},
		"prepaid_credit_amount_cents": basetypes.Int64Type{},
		"progressive_billing_credit_amount_cents": basetypes.Int64Type{},
		"self_billed":                            basetypes.BoolType{},
		"sequential_id":                          basetypes.Int64Type{},
		"status":                                 basetypes.StringType{},
		"sub_total_excluding_taxes_amount_cents": basetypes.Int64Type{},
		"sub_total_including_taxes_amount_cents": basetypes.Int64Type{},
		"taxes_amount_cents":                     basetypes.Int64Type{},
		"total_amount_cents":                     basetypes.Int64Type{},
		"updated_at":                             basetypes.StringType{},
		"version_number":                         basetypes.Int64Type{},
	}
}
