// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_add_ons

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func AddOnsResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"add_on": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"amount_cents": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "The cost of the add-on in cents, excluding any applicable taxes, that is billed to a customer. By creating a one-off invoice, you will be able to override this value.",
						MarkdownDescription: "The cost of the add-on in cents, excluding any applicable taxes, that is billed to a customer. By creating a one-off invoice, you will be able to override this value.",
					},
					"amount_currency": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AED",
								"AFN",
								"ALL",
								"AMD",
								"ANG",
								"AOA",
								"ARS",
								"AUD",
								"AWG",
								"AZN",
								"BAM",
								"BBD",
								"BDT",
								"BGN",
								"BIF",
								"BMD",
								"BND",
								"BOB",
								"BRL",
								"BSD",
								"BWP",
								"BYN",
								"BZD",
								"CAD",
								"CDF",
								"CHF",
								"CLF",
								"CLP",
								"CNY",
								"COP",
								"CRC",
								"CVE",
								"CZK",
								"DJF",
								"DKK",
								"DOP",
								"DZD",
								"EGP",
								"ETB",
								"EUR",
								"FJD",
								"FKP",
								"GBP",
								"GEL",
								"GIP",
								"GMD",
								"GNF",
								"GTQ",
								"GYD",
								"HKD",
								"HNL",
								"HRK",
								"HTG",
								"HUF",
								"IDR",
								"ILS",
								"INR",
								"ISK",
								"JMD",
								"JPY",
								"KES",
								"KGS",
								"KHR",
								"KMF",
								"KRW",
								"KYD",
								"KZT",
								"LAK",
								"LBP",
								"LKR",
								"LRD",
								"LSL",
								"MAD",
								"MDL",
								"MGA",
								"MKD",
								"MMK",
								"MNT",
								"MOP",
								"MRO",
								"MUR",
								"MVR",
								"MWK",
								"MXN",
								"MYR",
								"MZN",
								"NAD",
								"NGN",
								"NIO",
								"NOK",
								"NPR",
								"NZD",
								"PAB",
								"PEN",
								"PGK",
								"PHP",
								"PKR",
								"PLN",
								"PYG",
								"QAR",
								"RON",
								"RSD",
								"RUB",
								"RWF",
								"SAR",
								"SBD",
								"SCR",
								"SEK",
								"SGD",
								"SHP",
								"SLL",
								"SOS",
								"SRD",
								"STD",
								"SZL",
								"THB",
								"TJS",
								"TOP",
								"TRY",
								"TTD",
								"TWD",
								"TZS",
								"UAH",
								"UGX",
								"USD",
								"UYU",
								"UZS",
								"VND",
								"VUV",
								"WST",
								"XAF",
								"XCD",
								"XOF",
								"XPF",
								"YER",
								"ZAR",
								"ZMW",
							),
						},
					},
					"code": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Unique code used to identify the add-on.",
						MarkdownDescription: "Unique code used to identify the add-on.",
					},
					"created_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date and time when the add-on was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the add-on was initially created.",
						MarkdownDescription: "The date and time when the add-on was created. It is expressed in UTC format according to the ISO 8601 datetime standard. This field provides the timestamp for the exact moment when the add-on was initially created.",
					},
					"description": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The description of the add-on.",
						MarkdownDescription: "The description of the add-on.",
					},
					"invoice_display_name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
						MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
					},
					"lago_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier of the add-on, created by Lago.",
						MarkdownDescription: "Unique identifier of the add-on, created by Lago.",
					},
					"name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The name of the add-on.",
						MarkdownDescription: "The name of the add-on.",
					},
					"tax_codes": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "List of unique code used to identify the taxes.",
						MarkdownDescription: "List of unique code used to identify the taxes.",
					},
					"taxes": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"applied_to_organization": schema.BoolAttribute{
									Computed:            true,
									Description:         "Set to `true` if the tax is used as one of the organization's default",
									MarkdownDescription: "Set to `true` if the tax is used as one of the organization's default",
								},
								"code": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique code used to identify the tax associated with the API request.",
									MarkdownDescription: "Unique code used to identify the tax associated with the API request.",
								},
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "Creation date of the tax.",
									MarkdownDescription: "Creation date of the tax.",
								},
								"description": schema.StringAttribute{
									Computed:            true,
									Description:         "Internal description of the taxe",
									MarkdownDescription: "Internal description of the taxe",
								},
								"lago_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Unique identifier of the tax, created by Lago.",
									MarkdownDescription: "Unique identifier of the tax, created by Lago.",
								},
								"name": schema.StringAttribute{
									Computed:            true,
									Description:         "Name of the tax.",
									MarkdownDescription: "Name of the tax.",
								},
								"rate": schema.NumberAttribute{
									Computed:            true,
									Description:         "The percentage rate of the tax",
									MarkdownDescription: "The percentage rate of the tax",
								},
							},
							CustomType: TaxesType{
								ObjectType: types.ObjectType{
									AttrTypes: TaxesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "All taxes applied to the add-on.",
						MarkdownDescription: "All taxes applied to the add-on.",
					},
				},
				CustomType: AddOnType{
					ObjectType: types.ObjectType{
						AttrTypes: AddOnValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"code": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Unique code used to identify the add-on.",
				MarkdownDescription: "Unique code used to identify the add-on.",
			},
		},
	}
}

type AddOnsModel struct {
	AddOn AddOnValue   `tfsdk:"add_on"`
	Code  types.String `tfsdk:"code"`
}

var _ basetypes.ObjectTypable = AddOnType{}

type AddOnType struct {
	basetypes.ObjectType
}

func (t AddOnType) Equal(o attr.Type) bool {
	other, ok := o.(AddOnType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AddOnType) String() string {
	return "AddOnType"
}

func (t AddOnType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return nil, diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return nil, diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	taxesAttribute, ok := attributes["taxes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes is missing from object`)

		return nil, diags
	}

	taxesVal, ok := taxesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes expected to be basetypes.ListValue, was: %T`, taxesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AddOnValue{
		AmountCents:        amountCentsVal,
		AmountCurrency:     amountCurrencyVal,
		Code:               codeVal,
		CreatedAt:          createdAtVal,
		Description:        descriptionVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		LagoId:             lagoIdVal,
		Name:               nameVal,
		TaxCodes:           taxCodesVal,
		Taxes:              taxesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewAddOnValueNull() AddOnValue {
	return AddOnValue{
		state: attr.ValueStateNull,
	}
}

func NewAddOnValueUnknown() AddOnValue {
	return AddOnValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAddOnValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AddOnValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AddOnValue Attribute Value",
				"While creating a AddOnValue value, a missing attribute value was detected. "+
					"A AddOnValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AddOnValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AddOnValue Attribute Type",
				"While creating a AddOnValue value, an invalid attribute value was detected. "+
					"A AddOnValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AddOnValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AddOnValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AddOnValue Attribute Value",
				"While creating a AddOnValue value, an extra attribute value was detected. "+
					"A AddOnValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AddOnValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAddOnValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewAddOnValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return NewAddOnValueUnknown(), diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewAddOnValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewAddOnValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewAddOnValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewAddOnValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewAddOnValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAddOnValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return NewAddOnValueUnknown(), diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	taxesAttribute, ok := attributes["taxes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes is missing from object`)

		return NewAddOnValueUnknown(), diags
	}

	taxesVal, ok := taxesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes expected to be basetypes.ListValue, was: %T`, taxesAttribute))
	}

	if diags.HasError() {
		return NewAddOnValueUnknown(), diags
	}

	return AddOnValue{
		AmountCents:        amountCentsVal,
		AmountCurrency:     amountCurrencyVal,
		Code:               codeVal,
		CreatedAt:          createdAtVal,
		Description:        descriptionVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		LagoId:             lagoIdVal,
		Name:               nameVal,
		TaxCodes:           taxCodesVal,
		Taxes:              taxesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewAddOnValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AddOnValue {
	object, diags := NewAddOnValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAddOnValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AddOnType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAddOnValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAddOnValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAddOnValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAddOnValueMust(AddOnValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AddOnType) ValueType(ctx context.Context) attr.Value {
	return AddOnValue{}
}

var _ basetypes.ObjectValuable = AddOnValue{}

type AddOnValue struct {
	AmountCents        basetypes.Int64Value  `tfsdk:"amount_cents"`
	AmountCurrency     basetypes.StringValue `tfsdk:"amount_currency"`
	Code               basetypes.StringValue `tfsdk:"code"`
	CreatedAt          basetypes.StringValue `tfsdk:"created_at"`
	Description        basetypes.StringValue `tfsdk:"description"`
	InvoiceDisplayName basetypes.StringValue `tfsdk:"invoice_display_name"`
	LagoId             basetypes.StringValue `tfsdk:"lago_id"`
	Name               basetypes.StringValue `tfsdk:"name"`
	TaxCodes           basetypes.ListValue   `tfsdk:"tax_codes"`
	Taxes              basetypes.ListValue   `tfsdk:"taxes"`
	state              attr.ValueState
}

func (v AddOnValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["amount_currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tax_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["taxes"] = basetypes.ListType{
		ElemType: TaxesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.AmountCurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_currency"] = val

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.TaxCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_codes"] = val

		val, err = v.Taxes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taxes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AddOnValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AddOnValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AddOnValue) String() string {
	return "AddOnValue"
}

func (v AddOnValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	taxes := types.ListValueMust(
		TaxesType{
			basetypes.ObjectType{
				AttrTypes: TaxesValue{}.AttributeTypes(ctx),
			},
		},
		v.Taxes.Elements(),
	)

	if v.Taxes.IsNull() {
		taxes = types.ListNull(
			TaxesType{
				basetypes.ObjectType{
					AttrTypes: TaxesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Taxes.IsUnknown() {
		taxes = types.ListUnknown(
			TaxesType{
				basetypes.ObjectType{
					AttrTypes: TaxesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var taxCodesVal basetypes.ListValue
	switch {
	case v.TaxCodes.IsUnknown():
		taxCodesVal = types.ListUnknown(types.StringType)
	case v.TaxCodes.IsNull():
		taxCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		taxCodesVal, d = types.ListValue(types.StringType, v.TaxCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount_cents":         basetypes.Int64Type{},
			"amount_currency":      basetypes.StringType{},
			"code":                 basetypes.StringType{},
			"created_at":           basetypes.StringType{},
			"description":          basetypes.StringType{},
			"invoice_display_name": basetypes.StringType{},
			"lago_id":              basetypes.StringType{},
			"name":                 basetypes.StringType{},
			"tax_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"taxes": basetypes.ListType{
				ElemType: TaxesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":         basetypes.Int64Type{},
		"amount_currency":      basetypes.StringType{},
		"code":                 basetypes.StringType{},
		"created_at":           basetypes.StringType{},
		"description":          basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"lago_id":              basetypes.StringType{},
		"name":                 basetypes.StringType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"taxes": basetypes.ListType{
			ElemType: TaxesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":         v.AmountCents,
			"amount_currency":      v.AmountCurrency,
			"code":                 v.Code,
			"created_at":           v.CreatedAt,
			"description":          v.Description,
			"invoice_display_name": v.InvoiceDisplayName,
			"lago_id":              v.LagoId,
			"name":                 v.Name,
			"tax_codes":            taxCodesVal,
			"taxes":                taxes,
		})

	return objVal, diags
}

func (v AddOnValue) Equal(o attr.Value) bool {
	other, ok := o.(AddOnValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.AmountCurrency.Equal(other.AmountCurrency) {
		return false
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.TaxCodes.Equal(other.TaxCodes) {
		return false
	}

	if !v.Taxes.Equal(other.Taxes) {
		return false
	}

	return true
}

func (v AddOnValue) Type(ctx context.Context) attr.Type {
	return AddOnType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AddOnValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":         basetypes.Int64Type{},
		"amount_currency":      basetypes.StringType{},
		"code":                 basetypes.StringType{},
		"created_at":           basetypes.StringType{},
		"description":          basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"lago_id":              basetypes.StringType{},
		"name":                 basetypes.StringType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"taxes": basetypes.ListType{
			ElemType: TaxesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = TaxesType{}

type TaxesType struct {
	basetypes.ObjectType
}

func (t TaxesType) Equal(o attr.Type) bool {
	other, ok := o.(TaxesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TaxesType) String() string {
	return "TaxesType"
}

func (t TaxesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appliedToOrganizationAttribute, ok := attributes["applied_to_organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applied_to_organization is missing from object`)

		return nil, diags
	}

	appliedToOrganizationVal, ok := appliedToOrganizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applied_to_organization expected to be basetypes.BoolValue, was: %T`, appliedToOrganizationAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.NumberValue, was: %T`, rateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TaxesValue{
		AppliedToOrganization: appliedToOrganizationVal,
		Code:                  codeVal,
		CreatedAt:             createdAtVal,
		Description:           descriptionVal,
		LagoId:                lagoIdVal,
		Name:                  nameVal,
		Rate:                  rateVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewTaxesValueNull() TaxesValue {
	return TaxesValue{
		state: attr.ValueStateNull,
	}
}

func NewTaxesValueUnknown() TaxesValue {
	return TaxesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTaxesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TaxesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TaxesValue Attribute Value",
				"While creating a TaxesValue value, a missing attribute value was detected. "+
					"A TaxesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TaxesValue Attribute Type",
				"While creating a TaxesValue value, an invalid attribute value was detected. "+
					"A TaxesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TaxesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TaxesValue Attribute Value",
				"While creating a TaxesValue value, an extra attribute value was detected. "+
					"A TaxesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TaxesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTaxesValueUnknown(), diags
	}

	appliedToOrganizationAttribute, ok := attributes["applied_to_organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`applied_to_organization is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	appliedToOrganizationVal, ok := appliedToOrganizationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`applied_to_organization expected to be basetypes.BoolValue, was: %T`, appliedToOrganizationAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewTaxesValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.NumberValue, was: %T`, rateAttribute))
	}

	if diags.HasError() {
		return NewTaxesValueUnknown(), diags
	}

	return TaxesValue{
		AppliedToOrganization: appliedToOrganizationVal,
		Code:                  codeVal,
		CreatedAt:             createdAtVal,
		Description:           descriptionVal,
		LagoId:                lagoIdVal,
		Name:                  nameVal,
		Rate:                  rateVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewTaxesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TaxesValue {
	object, diags := NewTaxesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTaxesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TaxesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTaxesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTaxesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTaxesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTaxesValueMust(TaxesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TaxesType) ValueType(ctx context.Context) attr.Value {
	return TaxesValue{}
}

var _ basetypes.ObjectValuable = TaxesValue{}

type TaxesValue struct {
	AppliedToOrganization basetypes.BoolValue   `tfsdk:"applied_to_organization"`
	Code                  basetypes.StringValue `tfsdk:"code"`
	CreatedAt             basetypes.StringValue `tfsdk:"created_at"`
	Description           basetypes.StringValue `tfsdk:"description"`
	LagoId                basetypes.StringValue `tfsdk:"lago_id"`
	Name                  basetypes.StringValue `tfsdk:"name"`
	Rate                  basetypes.NumberValue `tfsdk:"rate"`
	state                 attr.ValueState
}

func (v TaxesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["applied_to_organization"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AppliedToOrganization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["applied_to_organization"] = val

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TaxesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TaxesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TaxesValue) String() string {
	return "TaxesValue"
}

func (v TaxesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"applied_to_organization": basetypes.BoolType{},
		"code":                    basetypes.StringType{},
		"created_at":              basetypes.StringType{},
		"description":             basetypes.StringType{},
		"lago_id":                 basetypes.StringType{},
		"name":                    basetypes.StringType{},
		"rate":                    basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"applied_to_organization": v.AppliedToOrganization,
			"code":                    v.Code,
			"created_at":              v.CreatedAt,
			"description":             v.Description,
			"lago_id":                 v.LagoId,
			"name":                    v.Name,
			"rate":                    v.Rate,
		})

	return objVal, diags
}

func (v TaxesValue) Equal(o attr.Value) bool {
	other, ok := o.(TaxesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AppliedToOrganization.Equal(other.AppliedToOrganization) {
		return false
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	return true
}

func (v TaxesValue) Type(ctx context.Context) attr.Type {
	return TaxesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TaxesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"applied_to_organization": basetypes.BoolType{},
		"code":                    basetypes.StringType{},
		"created_at":              basetypes.StringType{},
		"description":             basetypes.StringType{},
		"lago_id":                 basetypes.StringType{},
		"name":                    basetypes.StringType{},
		"rate":                    basetypes.NumberType{},
	}
}
