// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_customers

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func CustomersResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"billable_metric_code": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Billable metric code filter to apply to the charge usage",
				MarkdownDescription: "Billable metric code filter to apply to the charge usage",
			},
			"customer": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"account_type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The type of the account. It can have one of the following values:\n- `customer`: the account is a customer, default value.\n- `partner`: the account is a partner.",
						MarkdownDescription: "The type of the account. It can have one of the following values:\n- `customer`: the account is a customer, default value.\n- `partner`: the account is a partner.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"customer",
								"partner",
							),
						},
					},
					"address_line1": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The first line of the billing address",
						MarkdownDescription: "The first line of the billing address",
					},
					"address_line2": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The second line of the billing address",
						MarkdownDescription: "The second line of the billing address",
					},
					"billing_configuration": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"document_locale": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The document locale, specified in the ISO 639-1 format. This field represents the language or locale used for the documents issued by Lago",
								MarkdownDescription: "The document locale, specified in the ISO 639-1 format. This field represents the language or locale used for the documents issued by Lago",
							},
							"invoice_grace_period": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "The grace period, expressed in days, for the invoice. This period refers to the additional time granted to the customer beyond the invoice due date to adjust usage and line items",
								MarkdownDescription: "The grace period, expressed in days, for the invoice. This period refers to the additional time granted to the customer beyond the invoice due date to adjust usage and line items",
							},
							"payment_provider": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The payment provider utilized to initiate payments for invoices issued by Lago.\nAccepted values: `stripe`, `adyen`, `gocardless` or null. This field is required if you intend to assign a `provider_customer_id`.",
								MarkdownDescription: "The payment provider utilized to initiate payments for invoices issued by Lago.\nAccepted values: `stripe`, `adyen`, `gocardless` or null. This field is required if you intend to assign a `provider_customer_id`.",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"stripe",
										"adyen",
										"gocardless",
									),
								},
							},
							"payment_provider_code": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Unique code used to identify a payment provider connection.",
								MarkdownDescription: "Unique code used to identify a payment provider connection.",
							},
							"provider_customer_id": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The customer ID within the payment provider's system. If this field is not provided, Lago has the option to create a new customer record within the payment provider's system on behalf of the customer",
								MarkdownDescription: "The customer ID within the payment provider's system. If this field is not provided, Lago has the option to create a new customer record within the payment provider's system on behalf of the customer",
							},
							"provider_payment_methods": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "Specifies the available payment methods that can be used for this customer when `payment_provider` is set to `stripe`. The `provider_payment_methods` field is an array that allows multiple payment options to be defined. If this field is not explicitly set, the payment methods will be set to `card`. For now, possible values are `card`, `sepa_debit`, `us_bank_account`, `bacs_debit`, `boleto`, `link`, `crypto` and `customer_balance`. Note that when `link` is selected, `card` should also be provided in the array. When `customer_balance` is selected, no other payment can be selected.",
								MarkdownDescription: "Specifies the available payment methods that can be used for this customer when `payment_provider` is set to `stripe`. The `provider_payment_methods` field is an array that allows multiple payment options to be defined. If this field is not explicitly set, the payment methods will be set to `card`. For now, possible values are `card`, `sepa_debit`, `us_bank_account`, `bacs_debit`, `boleto`, `link`, `crypto` and `customer_balance`. Note that when `link` is selected, `card` should also be provided in the array. When `customer_balance` is selected, no other payment can be selected.",
							},
							"sync": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Set this field to `true` if you want to create the customer in the payment provider synchronously with the customer creation process in Lago. This option is applicable only when the `provider_customer_id` is `null` and the customer is automatically created in the payment provider through Lago. By default, the value is set to `false`",
								MarkdownDescription: "Set this field to `true` if you want to create the customer in the payment provider synchronously with the customer creation process in Lago. This option is applicable only when the `provider_customer_id` is `null` and the customer is automatically created in the payment provider through Lago. By default, the value is set to `false`",
							},
							"sync_with_provider": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Set this field to `true` if you want to create a customer record in the payment provider's system. This option is applicable only when the `provider_customer_id` is null and the `sync_with_provider` field is set to `true`. By default, the value is set to `false`",
								MarkdownDescription: "Set this field to `true` if you want to create a customer record in the payment provider's system. This option is applicable only when the `provider_customer_id` is null and the `sync_with_provider` field is set to `true`. By default, the value is set to `false`",
							},
						},
						CustomType: BillingConfigurationType{
							ObjectType: types.ObjectType{
								AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.",
						MarkdownDescription: "Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.",
					},
					"city": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The city of the customer's billing address",
						MarkdownDescription: "The city of the customer's billing address",
					},
					"country": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AD",
								"AE",
								"AF",
								"AG",
								"AI",
								"AL",
								"AM",
								"AO",
								"AQ",
								"AR",
								"AS",
								"AT",
								"AU",
								"AW",
								"AX",
								"AZ",
								"BA",
								"BB",
								"BD",
								"BE",
								"BF",
								"BG",
								"BH",
								"BI",
								"BJ",
								"BL",
								"BM",
								"BN",
								"BO",
								"BQ",
								"BR",
								"BS",
								"BT",
								"BV",
								"BW",
								"BY",
								"BZ",
								"CA",
								"CC",
								"CD",
								"CF",
								"CG",
								"CH",
								"CI",
								"CK",
								"CL",
								"CM",
								"CN",
								"CO",
								"CR",
								"CU",
								"CV",
								"CW",
								"CX",
								"CY",
								"CZ",
								"DE",
								"DJ",
								"DK",
								"DM",
								"DO",
								"DZ",
								"EC",
								"EE",
								"EG",
								"EH",
								"ER",
								"ES",
								"ET",
								"FI",
								"FJ",
								"FK",
								"FM",
								"FO",
								"FR",
								"GA",
								"GB",
								"GD",
								"GE",
								"GF",
								"GG",
								"GH",
								"GI",
								"GL",
								"GM",
								"GN",
								"GP",
								"GQ",
								"GR",
								"GS",
								"GT",
								"GU",
								"GW",
								"GY",
								"HK",
								"HM",
								"HN",
								"HR",
								"HT",
								"HU",
								"ID",
								"IE",
								"IL",
								"IM",
								"IN",
								"IO",
								"IQ",
								"IR",
								"IS",
								"IT",
								"JE",
								"JM",
								"JO",
								"JP",
								"KE",
								"KG",
								"KH",
								"KI",
								"KM",
								"KN",
								"KP",
								"KR",
								"KW",
								"KY",
								"KZ",
								"LA",
								"LB",
								"LC",
								"LI",
								"LK",
								"LR",
								"LS",
								"LT",
								"LU",
								"LV",
								"LY",
								"MA",
								"MC",
								"MD",
								"ME",
								"MF",
								"MG",
								"MH",
								"MK",
								"ML",
								"MM",
								"MN",
								"MO",
								"MP",
								"MQ",
								"MR",
								"MS",
								"MT",
								"MU",
								"MV",
								"MW",
								"MX",
								"MY",
								"MZ",
								"NA",
								"NC",
								"NE",
								"NF",
								"NG",
								"NI",
								"NL",
								"NO",
								"NP",
								"NR",
								"NU",
								"NZ",
								"OM",
								"PA",
								"PE",
								"PF",
								"PG",
								"PH",
								"PK",
								"PL",
								"PM",
								"PN",
								"PR",
								"PS",
								"PT",
								"PW",
								"PY",
								"QA",
								"RE",
								"RO",
								"RS",
								"RU",
								"RW",
								"SA",
								"SB",
								"SC",
								"SD",
								"SE",
								"SG",
								"SH",
								"SI",
								"SJ",
								"SK",
								"SL",
								"SM",
								"SN",
								"SO",
								"SR",
								"SS",
								"ST",
								"SV",
								"SX",
								"SY",
								"SZ",
								"TC",
								"TD",
								"TF",
								"TG",
								"TH",
								"TJ",
								"TK",
								"TL",
								"TM",
								"TN",
								"TO",
								"TR",
								"TT",
								"TV",
								"TW",
								"TZ",
								"UA",
								"UG",
								"UM",
								"US",
								"UY",
								"UZ",
								"VA",
								"VC",
								"VE",
								"VG",
								"VI",
								"VN",
								"VU",
								"WF",
								"WS",
								"YE",
								"YT",
								"ZA",
								"ZM",
								"ZW",
							),
						},
					},
					"currency": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AED",
								"AFN",
								"ALL",
								"AMD",
								"ANG",
								"AOA",
								"ARS",
								"AUD",
								"AWG",
								"AZN",
								"BAM",
								"BBD",
								"BDT",
								"BGN",
								"BIF",
								"BMD",
								"BND",
								"BOB",
								"BRL",
								"BSD",
								"BWP",
								"BYN",
								"BZD",
								"CAD",
								"CDF",
								"CHF",
								"CLF",
								"CLP",
								"CNY",
								"COP",
								"CRC",
								"CVE",
								"CZK",
								"DJF",
								"DKK",
								"DOP",
								"DZD",
								"EGP",
								"ETB",
								"EUR",
								"FJD",
								"FKP",
								"GBP",
								"GEL",
								"GIP",
								"GMD",
								"GNF",
								"GTQ",
								"GYD",
								"HKD",
								"HNL",
								"HRK",
								"HTG",
								"HUF",
								"IDR",
								"ILS",
								"INR",
								"ISK",
								"JMD",
								"JPY",
								"KES",
								"KGS",
								"KHR",
								"KMF",
								"KRW",
								"KYD",
								"KZT",
								"LAK",
								"LBP",
								"LKR",
								"LRD",
								"LSL",
								"MAD",
								"MDL",
								"MGA",
								"MKD",
								"MMK",
								"MNT",
								"MOP",
								"MRO",
								"MUR",
								"MVR",
								"MWK",
								"MXN",
								"MYR",
								"MZN",
								"NAD",
								"NGN",
								"NIO",
								"NOK",
								"NPR",
								"NZD",
								"PAB",
								"PEN",
								"PGK",
								"PHP",
								"PKR",
								"PLN",
								"PYG",
								"QAR",
								"RON",
								"RSD",
								"RUB",
								"RWF",
								"SAR",
								"SBD",
								"SCR",
								"SEK",
								"SGD",
								"SHP",
								"SLL",
								"SOS",
								"SRD",
								"STD",
								"SZL",
								"THB",
								"TJS",
								"TOP",
								"TRY",
								"TTD",
								"TWD",
								"TZS",
								"UAH",
								"UGX",
								"USD",
								"UYU",
								"UZS",
								"VND",
								"VUV",
								"WST",
								"XAF",
								"XCD",
								"XOF",
								"XPF",
								"YER",
								"ZAR",
								"ZMW",
							),
						},
					},
					"customer_type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The type of the customer. It can have one of the following values:\n- `company`: the customer is a company.\n- `individual`: the customer is an individual.",
						MarkdownDescription: "The type of the customer. It can have one of the following values:\n- `company`: the customer is a company.\n- `individual`: the customer is an individual.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"company",
								"individual",
							),
						},
					},
					"email": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The email of the customer",
						MarkdownDescription: "The email of the customer",
					},
					"external_id": schema.StringAttribute{
						Required:            true,
						Description:         "The customer external unique identifier (provided by your own application)",
						MarkdownDescription: "The customer external unique identifier (provided by your own application)",
					},
					"finalize_zero_amount_invoice": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Specifies how invoices with a zero total amount should be handled:\n- `inherit`: (Default) Follows the organization-level configuration.\n- `finalize`: Invoices are issued and finalized even if the total amount is zero.\n- `skip`: Invoices with a total amount of zero are not finalized.",
						MarkdownDescription: "Specifies how invoices with a zero total amount should be handled:\n- `inherit`: (Default) Follows the organization-level configuration.\n- `finalize`: Invoices are issued and finalized even if the total amount is zero.\n- `skip`: Invoices with a total amount of zero are not finalized.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"inherit",
								"skip",
								"finalize",
							),
						},
					},
					"firstname": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "First name of the customer",
						MarkdownDescription: "First name of the customer",
					},
					"integration_customers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"external_customer_id": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The customer ID within the integration's system. If this field is not provided, Lago has the option to create a new customer record within the integration's system on behalf of the customer.",
									MarkdownDescription: "The customer ID within the integration's system. If this field is not provided, Lago has the option to create a new customer record within the integration's system on behalf of the customer.",
								},
								"id": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "A unique identifier for the integration customer object in the Lago application.",
									MarkdownDescription: "A unique identifier for the integration customer object in the Lago application.",
								},
								"integration_code": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Unique code used to identify an integration connection.",
									MarkdownDescription: "Unique code used to identify an integration connection.",
								},
								"integration_type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "The integration type used for accounting and tax syncs.\nAccepted values: `netsuite, anrok, xero`.",
									MarkdownDescription: "The integration type used for accounting and tax syncs.\nAccepted values: `netsuite, anrok, xero`.",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"netsuite",
											"anrok",
											"xero",
										),
									},
								},
								"subsidiary_id": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "This optional field is needed only when working with `netsuite` connection.",
									MarkdownDescription: "This optional field is needed only when working with `netsuite` connection.",
								},
								"sync_with_provider": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Set this field to `true` if you want to create a customer record in the integration's system. This option is applicable only when the `external_customer_id` is null and the `sync_with_provider` field is set to `true`. By default, the value is set to `false`",
									MarkdownDescription: "Set this field to `true` if you want to create a customer record in the integration's system. This option is applicable only when the `external_customer_id` is null and the `sync_with_provider` field is set to `true`. By default, the value is set to `false`",
								},
							},
							CustomType: IntegrationCustomersType{
								ObjectType: types.ObjectType{
									AttrTypes: IntegrationCustomersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
					},
					"invoice_custom_section_codes": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "List of unique codes identifying the invoice custom sections.",
						MarkdownDescription: "List of unique codes identifying the invoice custom sections.",
					},
					"lastname": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Last name of the customer",
						MarkdownDescription: "Last name of the customer",
					},
					"legal_name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The legal company name of the customer",
						MarkdownDescription: "The legal company name of the customer",
					},
					"legal_number": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The legal company number of the customer",
						MarkdownDescription: "The legal company number of the customer",
					},
					"logo_url": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The logo URL of the customer",
						MarkdownDescription: "The logo URL of the customer",
					},
					"metadata": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"display_in_invoice": schema.BoolAttribute{
									Required:            true,
									Description:         "Determines whether the item or information should be displayed in the invoice. If set to true, the item or information will be included and visible in the generated invoice. If set to false, the item or information will be excluded and not displayed in the invoice.",
									MarkdownDescription: "Determines whether the item or information should be displayed in the invoice. If set to true, the item or information will be included and visible in the generated invoice. If set to false, the item or information will be excluded and not displayed in the invoice.",
								},
								"id": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Identifier for the metadata object, only required when updating a key-value pair",
									MarkdownDescription: "Identifier for the metadata object, only required when updating a key-value pair",
								},
								"key": schema.StringAttribute{
									Required:            true,
									Description:         "The metadata object key",
									MarkdownDescription: "The metadata object key",
								},
								"value": schema.StringAttribute{
									Required:            true,
									Description:         "The metadata object value",
									MarkdownDescription: "The metadata object value",
								},
							},
							CustomType: MetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: MetadataValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Set of key-value pairs that you can attach to a customer. This can be useful for storing additional information about the customer in a structured format",
						MarkdownDescription: "Set of key-value pairs that you can attach to a customer. This can be useful for storing additional information about the customer in a structured format",
					},
					"name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The full name of the customer",
						MarkdownDescription: "The full name of the customer",
					},
					"net_payment_term": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "The net payment term, expressed in days, specifies the duration within which a customer is expected to remit payment after the invoice is finalized.",
						MarkdownDescription: "The net payment term, expressed in days, specifies the duration within which a customer is expected to remit payment after the invoice is finalized.",
					},
					"phone": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The phone number of the customer",
						MarkdownDescription: "The phone number of the customer",
					},
					"shipping_address": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"address_line1": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The first line of the billing address",
								MarkdownDescription: "The first line of the billing address",
							},
							"address_line2": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The second line of the billing address",
								MarkdownDescription: "The second line of the billing address",
							},
							"city": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The city of the customer's billing address",
								MarkdownDescription: "The city of the customer's billing address",
							},
							"country": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"AD",
										"AE",
										"AF",
										"AG",
										"AI",
										"AL",
										"AM",
										"AO",
										"AQ",
										"AR",
										"AS",
										"AT",
										"AU",
										"AW",
										"AX",
										"AZ",
										"BA",
										"BB",
										"BD",
										"BE",
										"BF",
										"BG",
										"BH",
										"BI",
										"BJ",
										"BL",
										"BM",
										"BN",
										"BO",
										"BQ",
										"BR",
										"BS",
										"BT",
										"BV",
										"BW",
										"BY",
										"BZ",
										"CA",
										"CC",
										"CD",
										"CF",
										"CG",
										"CH",
										"CI",
										"CK",
										"CL",
										"CM",
										"CN",
										"CO",
										"CR",
										"CU",
										"CV",
										"CW",
										"CX",
										"CY",
										"CZ",
										"DE",
										"DJ",
										"DK",
										"DM",
										"DO",
										"DZ",
										"EC",
										"EE",
										"EG",
										"EH",
										"ER",
										"ES",
										"ET",
										"FI",
										"FJ",
										"FK",
										"FM",
										"FO",
										"FR",
										"GA",
										"GB",
										"GD",
										"GE",
										"GF",
										"GG",
										"GH",
										"GI",
										"GL",
										"GM",
										"GN",
										"GP",
										"GQ",
										"GR",
										"GS",
										"GT",
										"GU",
										"GW",
										"GY",
										"HK",
										"HM",
										"HN",
										"HR",
										"HT",
										"HU",
										"ID",
										"IE",
										"IL",
										"IM",
										"IN",
										"IO",
										"IQ",
										"IR",
										"IS",
										"IT",
										"JE",
										"JM",
										"JO",
										"JP",
										"KE",
										"KG",
										"KH",
										"KI",
										"KM",
										"KN",
										"KP",
										"KR",
										"KW",
										"KY",
										"KZ",
										"LA",
										"LB",
										"LC",
										"LI",
										"LK",
										"LR",
										"LS",
										"LT",
										"LU",
										"LV",
										"LY",
										"MA",
										"MC",
										"MD",
										"ME",
										"MF",
										"MG",
										"MH",
										"MK",
										"ML",
										"MM",
										"MN",
										"MO",
										"MP",
										"MQ",
										"MR",
										"MS",
										"MT",
										"MU",
										"MV",
										"MW",
										"MX",
										"MY",
										"MZ",
										"NA",
										"NC",
										"NE",
										"NF",
										"NG",
										"NI",
										"NL",
										"NO",
										"NP",
										"NR",
										"NU",
										"NZ",
										"OM",
										"PA",
										"PE",
										"PF",
										"PG",
										"PH",
										"PK",
										"PL",
										"PM",
										"PN",
										"PR",
										"PS",
										"PT",
										"PW",
										"PY",
										"QA",
										"RE",
										"RO",
										"RS",
										"RU",
										"RW",
										"SA",
										"SB",
										"SC",
										"SD",
										"SE",
										"SG",
										"SH",
										"SI",
										"SJ",
										"SK",
										"SL",
										"SM",
										"SN",
										"SO",
										"SR",
										"SS",
										"ST",
										"SV",
										"SX",
										"SY",
										"SZ",
										"TC",
										"TD",
										"TF",
										"TG",
										"TH",
										"TJ",
										"TK",
										"TL",
										"TM",
										"TN",
										"TO",
										"TR",
										"TT",
										"TV",
										"TW",
										"TZ",
										"UA",
										"UG",
										"UM",
										"US",
										"UY",
										"UZ",
										"VA",
										"VC",
										"VE",
										"VG",
										"VI",
										"VN",
										"VU",
										"WF",
										"WS",
										"YE",
										"YT",
										"ZA",
										"ZM",
										"ZW",
									),
								},
							},
							"state": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The state of the customer's billing address",
								MarkdownDescription: "The state of the customer's billing address",
							},
							"zipcode": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The zipcode of the customer's billing address",
								MarkdownDescription: "The zipcode of the customer's billing address",
							},
						},
						CustomType: ShippingAddressType{
							ObjectType: types.ObjectType{
								AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.",
						MarkdownDescription: "Configuration specific to the payment provider, utilized for billing the customer. This object contains settings and parameters necessary for processing payments and invoicing the customer.",
					},
					"skip_invoice_custom_sections": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Set to `true` to exclude all invoice custom sections from PDF generation for this customer only. False by default",
						MarkdownDescription: "Set to `true` to exclude all invoice custom sections from PDF generation for this customer only. False by default",
					},
					"state": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The state of the customer's billing address",
						MarkdownDescription: "The state of the customer's billing address",
					},
					"tax_codes": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "List of unique code used to identify the taxes.",
						MarkdownDescription: "List of unique code used to identify the taxes.",
					},
					"tax_identification_number": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The tax identification number of the customer",
						MarkdownDescription: "The tax identification number of the customer",
					},
					"timezone": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"UTC",
								"Africa/Algiers",
								"Africa/Cairo",
								"Africa/Casablanca",
								"Africa/Harare",
								"Africa/Johannesburg",
								"Africa/Monrovia",
								"Africa/Nairobi",
								"America/Argentina/Buenos_Aires",
								"America/Bogota",
								"America/Caracas",
								"America/Chicago",
								"America/Chihuahua",
								"America/Denver",
								"America/Godthab",
								"America/Guatemala",
								"America/Guyana",
								"America/Halifax",
								"America/Indiana/Indianapolis",
								"America/Juneau",
								"America/La_Paz",
								"America/Lima",
								"America/Los_Angeles",
								"America/Mazatlan",
								"America/Mexico_City",
								"America/Monterrey",
								"America/Montevideo",
								"America/New_York",
								"America/Phoenix",
								"America/Puerto_Rico",
								"America/Regina",
								"America/Santiago",
								"America/Sao_Paulo",
								"America/St_Johns",
								"America/Tijuana",
								"Asia/Almaty",
								"Asia/Baghdad",
								"Asia/Baku",
								"Asia/Bangkok",
								"Asia/Chongqing",
								"Asia/Colombo",
								"Asia/Dhaka",
								"Asia/Hong_Kong",
								"Asia/Irkutsk",
								"Asia/Jakarta",
								"Asia/Jerusalem",
								"Asia/Kabul",
								"Asia/Kamchatka",
								"Asia/Karachi",
								"Asia/Kathmandu",
								"Asia/Kolkata",
								"Asia/Krasnoyarsk",
								"Asia/Kuala_Lumpur",
								"Asia/Kuwait",
								"Asia/Magadan",
								"Asia/Muscat",
								"Asia/Novosibirsk",
								"Asia/Rangoon",
								"Asia/Riyadh",
								"Asia/Seoul",
								"Asia/Shanghai",
								"Asia/Singapore",
								"Asia/Srednekolymsk",
								"Asia/Taipei",
								"Asia/Tashkent",
								"Asia/Tbilisi",
								"Asia/Tehran",
								"Asia/Tokyo",
								"Asia/Ulaanbaatar",
								"Asia/Urumqi",
								"Asia/Vladivostok",
								"Asia/Yakutsk",
								"Asia/Yekaterinburg",
								"Asia/Yerevan",
								"Atlantic/Azores",
								"Atlantic/Cape_Verde",
								"Atlantic/South_Georgia",
								"Australia/Adelaide",
								"Australia/Brisbane",
								"Australia/Darwin",
								"Australia/Hobart",
								"Australia/Melbourne",
								"Australia/Perth",
								"Australia/Sydney",
								"Europe/Amsterdam",
								"Europe/Athens",
								"Europe/Belgrade",
								"Europe/Berlin",
								"Europe/Bratislava",
								"Europe/Brussels",
								"Europe/Bucharest",
								"Europe/Budapest",
								"Europe/Copenhagen",
								"Europe/Dublin",
								"Europe/Helsinki",
								"Europe/Istanbul",
								"Europe/Kaliningrad",
								"Europe/Kiev",
								"Europe/Lisbon",
								"Europe/Ljubljana",
								"Europe/London",
								"Europe/Madrid",
								"Europe/Minsk",
								"Europe/Moscow",
								"Europe/Paris",
								"Europe/Prague",
								"Europe/Riga",
								"Europe/Rome",
								"Europe/Samara",
								"Europe/Sarajevo",
								"Europe/Skopje",
								"Europe/Sofia",
								"Europe/Stockholm",
								"Europe/Tallinn",
								"Europe/Vienna",
								"Europe/Vilnius",
								"Europe/Volgograd",
								"Europe/Warsaw",
								"Europe/Zagreb",
								"Europe/Zurich",
								"GMT+12",
								"Pacific/Apia",
								"Pacific/Auckland",
								"Pacific/Chatham",
								"Pacific/Fakaofo",
								"Pacific/Fiji",
								"Pacific/Guadalcanal",
								"Pacific/Guam",
								"Pacific/Honolulu",
								"Pacific/Majuro",
								"Pacific/Midway",
								"Pacific/Noumea",
								"Pacific/Pago_Pago",
								"Pacific/Port_Moresby",
								"Pacific/Tongatapu",
							),
						},
					},
					"url": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The custom website URL of the customer",
						MarkdownDescription: "The custom website URL of the customer",
					},
					"zipcode": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The zipcode of the customer's billing address",
						MarkdownDescription: "The zipcode of the customer's billing address",
					},
				},
				CustomType: CustomerType{
					ObjectType: types.ObjectType{
						AttrTypes: CustomerValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"external_customer_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The customer external unique identifier (provided by your own application).",
				MarkdownDescription: "The customer external unique identifier (provided by your own application).",
			},
			"external_subscription_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The unique identifier of the subscription within your application.",
				MarkdownDescription: "The unique identifier of the subscription within your application.",
			},
			"meta": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"current_page": schema.Int64Attribute{
						Computed:            true,
						Description:         "Current page.",
						MarkdownDescription: "Current page.",
					},
					"next_page": schema.Int64Attribute{
						Computed:            true,
						Description:         "Next page.",
						MarkdownDescription: "Next page.",
					},
					"prev_page": schema.Int64Attribute{
						Computed:            true,
						Description:         "Previous page.",
						MarkdownDescription: "Previous page.",
					},
					"total_count": schema.Int64Attribute{
						Computed:            true,
						Description:         "Total number of records.",
						MarkdownDescription: "Total number of records.",
					},
					"total_pages": schema.Int64Attribute{
						Computed:            true,
						Description:         "Total number of pages.",
						MarkdownDescription: "Total number of pages.",
					},
				},
				CustomType: MetaType{
					ObjectType: types.ObjectType{
						AttrTypes: MetaValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"page": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Page number.",
				MarkdownDescription: "Page number.",
			},
			"per_page": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of records per page.",
				MarkdownDescription: "Number of records per page.",
			},
			"periods_count": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of past billing period to returns in the result",
				MarkdownDescription: "Number of past billing period to returns in the result",
			},
			"usage_periods": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"customer_usage": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "The amount in cents, tax excluded.",
									MarkdownDescription: "The amount in cents, tax excluded.",
								},
								"charges_usage": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"amount_cents": schema.Int64Attribute{
												Computed:            true,
												Description:         "The amount in cents, tax excluded, consumed by the customer for a specific charge item.",
												MarkdownDescription: "The amount in cents, tax excluded, consumed by the customer for a specific charge item.",
											},
											"amount_currency": schema.StringAttribute{
												Computed: true,
											},
											"billable_metric": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"aggregation_type": schema.StringAttribute{
														Computed:            true,
														Description:         "The aggregation type of the billable metric used for this charge. Possible values are `count_agg`, `sum_agg`, `max_agg` or `unique_count_agg`.",
														MarkdownDescription: "The aggregation type of the billable metric used for this charge. Possible values are `count_agg`, `sum_agg`, `max_agg` or `unique_count_agg`.",
													},
													"code": schema.StringAttribute{
														Computed:            true,
														Description:         "The code of the billable metric used for this charge.",
														MarkdownDescription: "The code of the billable metric used for this charge.",
													},
													"lago_id": schema.StringAttribute{
														Computed:            true,
														Description:         "Unique identifier assigned to the billable metric within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the billable metric's record within the Lago system.",
														MarkdownDescription: "Unique identifier assigned to the billable metric within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the billable metric's record within the Lago system.",
													},
													"name": schema.StringAttribute{
														Computed:            true,
														Description:         "The name of the billable metric used for this charge.",
														MarkdownDescription: "The name of the billable metric used for this charge.",
													},
												},
												CustomType: BillableMetricType{
													ObjectType: types.ObjectType{
														AttrTypes: BillableMetricValue{}.AttributeTypes(ctx),
													},
												},
												Computed:            true,
												Description:         "The related billable metric object.",
												MarkdownDescription: "The related billable metric object.",
											},
											"charge": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"charge_model": schema.StringAttribute{
														Computed:            true,
														Description:         "The pricing model applied to this charge. Possible values are standard, `graduated`, `percentage`, `package` or `volume`.",
														MarkdownDescription: "The pricing model applied to this charge. Possible values are standard, `graduated`, `percentage`, `package` or `volume`.",
													},
													"invoice_display_name": schema.StringAttribute{
														Computed:            true,
														Description:         "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
														MarkdownDescription: "Specifies the name that will be displayed on an invoice. If no value is set for this field, the name of the actual charge will be used as the default display name.",
													},
													"lago_id": schema.StringAttribute{
														Computed:            true,
														Description:         "Unique identifier assigned to the charge within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the charge's record within the Lago system.",
														MarkdownDescription: "Unique identifier assigned to the charge within the Lago application. This ID is exclusively created by Lago and serves as a unique identifier for the charge's record within the Lago system.",
													},
												},
												CustomType: ChargeType{
													ObjectType: types.ObjectType{
														AttrTypes: ChargeValue{}.AttributeTypes(ctx),
													},
												},
												Computed:            true,
												Description:         "Object listing all the properties for a specific charge item.",
												MarkdownDescription: "Object listing all the properties for a specific charge item.",
											},
											"events_count": schema.Int64Attribute{
												Computed:            true,
												Description:         "The quantity of usage events that have been recorded for a particular charge during the specified time period. These events may also be referred to as the number of transactions in some contexts.",
												MarkdownDescription: "The quantity of usage events that have been recorded for a particular charge during the specified time period. These events may also be referred to as the number of transactions in some contexts.",
											},
											"filters": schema.ListNestedAttribute{
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"amount_cents": schema.Int64Attribute{
															Computed:            true,
															Description:         "The amount in cents, tax excluded, consumed for a specific charge filter related to a charge item.",
															MarkdownDescription: "The amount in cents, tax excluded, consumed for a specific charge filter related to a charge item.",
														},
														"events_count": schema.Int64Attribute{
															Computed:            true,
															Description:         "The quantity of usage events that have been recorded for a particular charge filter during the specified time period. These events may also be referred to as the number of transactions in some contexts.",
															MarkdownDescription: "The quantity of usage events that have been recorded for a particular charge filter during the specified time period. These events may also be referred to as the number of transactions in some contexts.",
														},
														"invoice_display_name": schema.StringAttribute{
															Computed:            true,
															Description:         "Specifies the name that will be displayed on an invoice.",
															MarkdownDescription: "Specifies the name that will be displayed on an invoice.",
														},
														"units": schema.StringAttribute{
															Computed:            true,
															Description:         "The number of units consumed for a specific charge filter related to a charge item.",
															MarkdownDescription: "The number of units consumed for a specific charge filter related to a charge item.",
														},
														"values": schema.MapAttribute{
															ElementType:         types.StringType,
															Computed:            true,
															Description:         "List of filter values applied to the usage.",
															MarkdownDescription: "List of filter values applied to the usage.",
														},
													},
													CustomType: FiltersType{
														ObjectType: types.ObjectType{
															AttrTypes: FiltersValue{}.AttributeTypes(ctx),
														},
													},
												},
												Computed:            true,
												Description:         "Array of filter object, representing multiple dimensions for a charge item.",
												MarkdownDescription: "Array of filter object, representing multiple dimensions for a charge item.",
											},
											"grouped_usage": schema.ListNestedAttribute{
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"amount_cents": schema.Int64Attribute{
															Computed:            true,
															Description:         "The amount in cents, tax excluded, consumed for a specific group related to a charge item.",
															MarkdownDescription: "The amount in cents, tax excluded, consumed for a specific group related to a charge item.",
														},
														"events_count": schema.Int64Attribute{
															Computed:            true,
															Description:         "The quantity of usage events that have been recorded for a particular charge during the specified time period. These events may also be referred to as the number of transactions in some contexts.",
															MarkdownDescription: "The quantity of usage events that have been recorded for a particular charge during the specified time period. These events may also be referred to as the number of transactions in some contexts.",
														},
														"filters": schema.ListNestedAttribute{
															NestedObject: schema.NestedAttributeObject{
																Attributes: map[string]schema.Attribute{
																	"amount_cents": schema.Int64Attribute{
																		Computed:            true,
																		Description:         "The amount in cents, tax excluded, consumed for a specific charge filter related to a charge item.",
																		MarkdownDescription: "The amount in cents, tax excluded, consumed for a specific charge filter related to a charge item.",
																	},
																	"events_count": schema.Int64Attribute{
																		Computed:            true,
																		Description:         "The quantity of usage events that have been recorded for a particular charge filter during the specified time period. These events may also be referred to as the number of transactions in some contexts.",
																		MarkdownDescription: "The quantity of usage events that have been recorded for a particular charge filter during the specified time period. These events may also be referred to as the number of transactions in some contexts.",
																	},
																	"invoice_display_name": schema.StringAttribute{
																		Computed:            true,
																		Description:         "Specifies the name that will be displayed on an invoice.",
																		MarkdownDescription: "Specifies the name that will be displayed on an invoice.",
																	},
																	"units": schema.StringAttribute{
																		Computed:            true,
																		Description:         "The number of units consumed for a specific charge filter related to a charge item.",
																		MarkdownDescription: "The number of units consumed for a specific charge filter related to a charge item.",
																	},
																	"values": schema.MapAttribute{
																		ElementType:         types.StringType,
																		Computed:            true,
																		Description:         "List of filter values applied to the usage.",
																		MarkdownDescription: "List of filter values applied to the usage.",
																	},
																},
																CustomType: FiltersType{
																	ObjectType: types.ObjectType{
																		AttrTypes: FiltersValue{}.AttributeTypes(ctx),
																	},
																},
															},
															Computed:            true,
															Description:         "Array of filter object, representing multiple dimensions for a charge item.",
															MarkdownDescription: "Array of filter object, representing multiple dimensions for a charge item.",
														},
														"grouped_by": schema.MapAttribute{
															ElementType:         types.StringType,
															Computed:            true,
															Description:         "Key value list of event properties aggregated by the charge model",
															MarkdownDescription: "Key value list of event properties aggregated by the charge model",
														},
														"units": schema.StringAttribute{
															Computed:            true,
															Description:         "The number of units consumed for a specific group related to a charge item.",
															MarkdownDescription: "The number of units consumed for a specific group related to a charge item.",
														},
													},
													CustomType: GroupedUsageType{
														ObjectType: types.ObjectType{
															AttrTypes: GroupedUsageValue{}.AttributeTypes(ctx),
														},
													},
												},
												Computed:            true,
												Description:         "Array of aggregated fees, grouped by the event properties defined in a `standard` charge model.",
												MarkdownDescription: "Array of aggregated fees, grouped by the event properties defined in a `standard` charge model.",
											},
											"units": schema.StringAttribute{
												Computed:            true,
												Description:         "The number of units consumed by the customer for a specific charge item.",
												MarkdownDescription: "The number of units consumed by the customer for a specific charge item.",
											},
										},
										CustomType: ChargesUsageType{
											ObjectType: types.ObjectType{
												AttrTypes: ChargesUsageValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "Array of charges that comprise the current usage. It contains detailed information about individual charge items associated with the usage.",
									MarkdownDescription: "Array of charges that comprise the current usage. It contains detailed information about individual charge items associated with the usage.",
								},
								"currency": schema.StringAttribute{
									Computed: true,
								},
								"from_datetime": schema.StringAttribute{
									Computed:            true,
									Description:         "The lower bound of the billing period, expressed in the ISO 8601 datetime format in Coordinated Universal Time (UTC).",
									MarkdownDescription: "The lower bound of the billing period, expressed in the ISO 8601 datetime format in Coordinated Universal Time (UTC).",
								},
								"issuing_date": schema.StringAttribute{
									Computed:            true,
									Description:         "The date of creation of the invoice.",
									MarkdownDescription: "The date of creation of the invoice.",
								},
								"lago_invoice_id": schema.StringAttribute{
									Computed:            true,
									Description:         "A unique identifier associated with the invoice related to this particular usage record.",
									MarkdownDescription: "A unique identifier associated with the invoice related to this particular usage record.",
								},
								"taxes_amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "The tax amount in cents.",
									MarkdownDescription: "The tax amount in cents.",
								},
								"to_datetime": schema.StringAttribute{
									Computed:            true,
									Description:         "The upper bound of the billing period, expressed in the ISO 8601 datetime format in Coordinated Universal Time (UTC).",
									MarkdownDescription: "The upper bound of the billing period, expressed in the ISO 8601 datetime format in Coordinated Universal Time (UTC).",
								},
								"total_amount_cents": schema.Int64Attribute{
									Computed:            true,
									Description:         "The total amount in cents, tax included.",
									MarkdownDescription: "The total amount in cents, tax included.",
								},
							},
							CustomType: CustomerUsageType{
								ObjectType: types.ObjectType{
									AttrTypes: CustomerUsageValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
					},
					CustomType: UsagePeriodsType{
						ObjectType: types.ObjectType{
							AttrTypes: UsagePeriodsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
		},
	}
}

type CustomersModel struct {
	BillableMetricCode     types.String  `tfsdk:"billable_metric_code"`
	Customer               CustomerValue `tfsdk:"customer"`
	ExternalCustomerId     types.String  `tfsdk:"external_customer_id"`
	ExternalSubscriptionId types.String  `tfsdk:"external_subscription_id"`
	Meta                   MetaValue     `tfsdk:"meta"`
	Page                   types.Int64   `tfsdk:"page"`
	PerPage                types.Int64   `tfsdk:"per_page"`
	PeriodsCount           types.Int64   `tfsdk:"periods_count"`
	UsagePeriods           types.List    `tfsdk:"usage_periods"`
}

var _ basetypes.ObjectTypable = CustomerType{}

type CustomerType struct {
	basetypes.ObjectType
}

func (t CustomerType) Equal(o attr.Type) bool {
	other, ok := o.(CustomerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomerType) String() string {
	return "CustomerType"
}

func (t CustomerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accountTypeAttribute, ok := attributes["account_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_type is missing from object`)

		return nil, diags
	}

	accountTypeVal, ok := accountTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_type expected to be basetypes.StringValue, was: %T`, accountTypeAttribute))
	}

	addressLine1Attribute, ok := attributes["address_line1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line1 is missing from object`)

		return nil, diags
	}

	addressLine1Val, ok := addressLine1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line1 expected to be basetypes.StringValue, was: %T`, addressLine1Attribute))
	}

	addressLine2Attribute, ok := attributes["address_line2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line2 is missing from object`)

		return nil, diags
	}

	addressLine2Val, ok := addressLine2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line2 expected to be basetypes.StringValue, was: %T`, addressLine2Attribute))
	}

	billingConfigurationAttribute, ok := attributes["billing_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billing_configuration is missing from object`)

		return nil, diags
	}

	billingConfigurationVal, ok := billingConfigurationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billing_configuration expected to be basetypes.ObjectValue, was: %T`, billingConfigurationAttribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return nil, diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return nil, diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return nil, diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	customerTypeAttribute, ok := attributes["customer_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_type is missing from object`)

		return nil, diags
	}

	customerTypeVal, ok := customerTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_type expected to be basetypes.StringValue, was: %T`, customerTypeAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return nil, diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	externalIdAttribute, ok := attributes["external_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_id is missing from object`)

		return nil, diags
	}

	externalIdVal, ok := externalIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_id expected to be basetypes.StringValue, was: %T`, externalIdAttribute))
	}

	finalizeZeroAmountInvoiceAttribute, ok := attributes["finalize_zero_amount_invoice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`finalize_zero_amount_invoice is missing from object`)

		return nil, diags
	}

	finalizeZeroAmountInvoiceVal, ok := finalizeZeroAmountInvoiceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`finalize_zero_amount_invoice expected to be basetypes.StringValue, was: %T`, finalizeZeroAmountInvoiceAttribute))
	}

	firstnameAttribute, ok := attributes["firstname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`firstname is missing from object`)

		return nil, diags
	}

	firstnameVal, ok := firstnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`firstname expected to be basetypes.StringValue, was: %T`, firstnameAttribute))
	}

	integrationCustomersAttribute, ok := attributes["integration_customers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`integration_customers is missing from object`)

		return nil, diags
	}

	integrationCustomersVal, ok := integrationCustomersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`integration_customers expected to be basetypes.ListValue, was: %T`, integrationCustomersAttribute))
	}

	invoiceCustomSectionCodesAttribute, ok := attributes["invoice_custom_section_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_custom_section_codes is missing from object`)

		return nil, diags
	}

	invoiceCustomSectionCodesVal, ok := invoiceCustomSectionCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_custom_section_codes expected to be basetypes.ListValue, was: %T`, invoiceCustomSectionCodesAttribute))
	}

	lastnameAttribute, ok := attributes["lastname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lastname is missing from object`)

		return nil, diags
	}

	lastnameVal, ok := lastnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lastname expected to be basetypes.StringValue, was: %T`, lastnameAttribute))
	}

	legalNameAttribute, ok := attributes["legal_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legal_name is missing from object`)

		return nil, diags
	}

	legalNameVal, ok := legalNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legal_name expected to be basetypes.StringValue, was: %T`, legalNameAttribute))
	}

	legalNumberAttribute, ok := attributes["legal_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legal_number is missing from object`)

		return nil, diags
	}

	legalNumberVal, ok := legalNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legal_number expected to be basetypes.StringValue, was: %T`, legalNumberAttribute))
	}

	logoUrlAttribute, ok := attributes["logo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`logo_url is missing from object`)

		return nil, diags
	}

	logoUrlVal, ok := logoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`logo_url expected to be basetypes.StringValue, was: %T`, logoUrlAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ListValue, was: %T`, metadataAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	netPaymentTermAttribute, ok := attributes["net_payment_term"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_payment_term is missing from object`)

		return nil, diags
	}

	netPaymentTermVal, ok := netPaymentTermAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_payment_term expected to be basetypes.Int64Value, was: %T`, netPaymentTermAttribute))
	}

	phoneAttribute, ok := attributes["phone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phone is missing from object`)

		return nil, diags
	}

	phoneVal, ok := phoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phone expected to be basetypes.StringValue, was: %T`, phoneAttribute))
	}

	shippingAddressAttribute, ok := attributes["shipping_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`shipping_address is missing from object`)

		return nil, diags
	}

	shippingAddressVal, ok := shippingAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`shipping_address expected to be basetypes.ObjectValue, was: %T`, shippingAddressAttribute))
	}

	skipInvoiceCustomSectionsAttribute, ok := attributes["skip_invoice_custom_sections"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_invoice_custom_sections is missing from object`)

		return nil, diags
	}

	skipInvoiceCustomSectionsVal, ok := skipInvoiceCustomSectionsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_invoice_custom_sections expected to be basetypes.BoolValue, was: %T`, skipInvoiceCustomSectionsAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return nil, diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	taxIdentificationNumberAttribute, ok := attributes["tax_identification_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_identification_number is missing from object`)

		return nil, diags
	}

	taxIdentificationNumberVal, ok := taxIdentificationNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_identification_number expected to be basetypes.StringValue, was: %T`, taxIdentificationNumberAttribute))
	}

	timezoneAttribute, ok := attributes["timezone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timezone is missing from object`)

		return nil, diags
	}

	timezoneVal, ok := timezoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timezone expected to be basetypes.StringValue, was: %T`, timezoneAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	zipcodeAttribute, ok := attributes["zipcode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zipcode is missing from object`)

		return nil, diags
	}

	zipcodeVal, ok := zipcodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zipcode expected to be basetypes.StringValue, was: %T`, zipcodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomerValue{
		AccountType:               accountTypeVal,
		AddressLine1:              addressLine1Val,
		AddressLine2:              addressLine2Val,
		BillingConfiguration:      billingConfigurationVal,
		City:                      cityVal,
		Country:                   countryVal,
		Currency:                  currencyVal,
		CustomerType:              customerTypeVal,
		Email:                     emailVal,
		ExternalId:                externalIdVal,
		FinalizeZeroAmountInvoice: finalizeZeroAmountInvoiceVal,
		Firstname:                 firstnameVal,
		IntegrationCustomers:      integrationCustomersVal,
		InvoiceCustomSectionCodes: invoiceCustomSectionCodesVal,
		Lastname:                  lastnameVal,
		LegalName:                 legalNameVal,
		LegalNumber:               legalNumberVal,
		LogoUrl:                   logoUrlVal,
		Metadata:                  metadataVal,
		Name:                      nameVal,
		NetPaymentTerm:            netPaymentTermVal,
		Phone:                     phoneVal,
		ShippingAddress:           shippingAddressVal,
		SkipInvoiceCustomSections: skipInvoiceCustomSectionsVal,
		State:                     stateVal,
		TaxCodes:                  taxCodesVal,
		TaxIdentificationNumber:   taxIdentificationNumberVal,
		Timezone:                  timezoneVal,
		Url:                       urlVal,
		Zipcode:                   zipcodeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewCustomerValueNull() CustomerValue {
	return CustomerValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomerValueUnknown() CustomerValue {
	return CustomerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomerValue Attribute Value",
				"While creating a CustomerValue value, a missing attribute value was detected. "+
					"A CustomerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomerValue Attribute Type",
				"While creating a CustomerValue value, an invalid attribute value was detected. "+
					"A CustomerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomerValue Attribute Value",
				"While creating a CustomerValue value, an extra attribute value was detected. "+
					"A CustomerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomerValueUnknown(), diags
	}

	accountTypeAttribute, ok := attributes["account_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`account_type is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	accountTypeVal, ok := accountTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`account_type expected to be basetypes.StringValue, was: %T`, accountTypeAttribute))
	}

	addressLine1Attribute, ok := attributes["address_line1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line1 is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	addressLine1Val, ok := addressLine1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line1 expected to be basetypes.StringValue, was: %T`, addressLine1Attribute))
	}

	addressLine2Attribute, ok := attributes["address_line2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line2 is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	addressLine2Val, ok := addressLine2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line2 expected to be basetypes.StringValue, was: %T`, addressLine2Attribute))
	}

	billingConfigurationAttribute, ok := attributes["billing_configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billing_configuration is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	billingConfigurationVal, ok := billingConfigurationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billing_configuration expected to be basetypes.ObjectValue, was: %T`, billingConfigurationAttribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	customerTypeAttribute, ok := attributes["customer_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_type is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	customerTypeVal, ok := customerTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_type expected to be basetypes.StringValue, was: %T`, customerTypeAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	externalIdAttribute, ok := attributes["external_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_id is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	externalIdVal, ok := externalIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_id expected to be basetypes.StringValue, was: %T`, externalIdAttribute))
	}

	finalizeZeroAmountInvoiceAttribute, ok := attributes["finalize_zero_amount_invoice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`finalize_zero_amount_invoice is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	finalizeZeroAmountInvoiceVal, ok := finalizeZeroAmountInvoiceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`finalize_zero_amount_invoice expected to be basetypes.StringValue, was: %T`, finalizeZeroAmountInvoiceAttribute))
	}

	firstnameAttribute, ok := attributes["firstname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`firstname is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	firstnameVal, ok := firstnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`firstname expected to be basetypes.StringValue, was: %T`, firstnameAttribute))
	}

	integrationCustomersAttribute, ok := attributes["integration_customers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`integration_customers is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	integrationCustomersVal, ok := integrationCustomersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`integration_customers expected to be basetypes.ListValue, was: %T`, integrationCustomersAttribute))
	}

	invoiceCustomSectionCodesAttribute, ok := attributes["invoice_custom_section_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_custom_section_codes is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	invoiceCustomSectionCodesVal, ok := invoiceCustomSectionCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_custom_section_codes expected to be basetypes.ListValue, was: %T`, invoiceCustomSectionCodesAttribute))
	}

	lastnameAttribute, ok := attributes["lastname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lastname is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	lastnameVal, ok := lastnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lastname expected to be basetypes.StringValue, was: %T`, lastnameAttribute))
	}

	legalNameAttribute, ok := attributes["legal_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legal_name is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	legalNameVal, ok := legalNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legal_name expected to be basetypes.StringValue, was: %T`, legalNameAttribute))
	}

	legalNumberAttribute, ok := attributes["legal_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legal_number is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	legalNumberVal, ok := legalNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legal_number expected to be basetypes.StringValue, was: %T`, legalNumberAttribute))
	}

	logoUrlAttribute, ok := attributes["logo_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`logo_url is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	logoUrlVal, ok := logoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`logo_url expected to be basetypes.StringValue, was: %T`, logoUrlAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ListValue, was: %T`, metadataAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	netPaymentTermAttribute, ok := attributes["net_payment_term"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_payment_term is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	netPaymentTermVal, ok := netPaymentTermAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_payment_term expected to be basetypes.Int64Value, was: %T`, netPaymentTermAttribute))
	}

	phoneAttribute, ok := attributes["phone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`phone is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	phoneVal, ok := phoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`phone expected to be basetypes.StringValue, was: %T`, phoneAttribute))
	}

	shippingAddressAttribute, ok := attributes["shipping_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`shipping_address is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	shippingAddressVal, ok := shippingAddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`shipping_address expected to be basetypes.ObjectValue, was: %T`, shippingAddressAttribute))
	}

	skipInvoiceCustomSectionsAttribute, ok := attributes["skip_invoice_custom_sections"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`skip_invoice_custom_sections is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	skipInvoiceCustomSectionsVal, ok := skipInvoiceCustomSectionsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`skip_invoice_custom_sections expected to be basetypes.BoolValue, was: %T`, skipInvoiceCustomSectionsAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	taxCodesAttribute, ok := attributes["tax_codes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_codes is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	taxCodesVal, ok := taxCodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_codes expected to be basetypes.ListValue, was: %T`, taxCodesAttribute))
	}

	taxIdentificationNumberAttribute, ok := attributes["tax_identification_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tax_identification_number is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	taxIdentificationNumberVal, ok := taxIdentificationNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tax_identification_number expected to be basetypes.StringValue, was: %T`, taxIdentificationNumberAttribute))
	}

	timezoneAttribute, ok := attributes["timezone"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timezone is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	timezoneVal, ok := timezoneAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timezone expected to be basetypes.StringValue, was: %T`, timezoneAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	zipcodeAttribute, ok := attributes["zipcode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zipcode is missing from object`)

		return NewCustomerValueUnknown(), diags
	}

	zipcodeVal, ok := zipcodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zipcode expected to be basetypes.StringValue, was: %T`, zipcodeAttribute))
	}

	if diags.HasError() {
		return NewCustomerValueUnknown(), diags
	}

	return CustomerValue{
		AccountType:               accountTypeVal,
		AddressLine1:              addressLine1Val,
		AddressLine2:              addressLine2Val,
		BillingConfiguration:      billingConfigurationVal,
		City:                      cityVal,
		Country:                   countryVal,
		Currency:                  currencyVal,
		CustomerType:              customerTypeVal,
		Email:                     emailVal,
		ExternalId:                externalIdVal,
		FinalizeZeroAmountInvoice: finalizeZeroAmountInvoiceVal,
		Firstname:                 firstnameVal,
		IntegrationCustomers:      integrationCustomersVal,
		InvoiceCustomSectionCodes: invoiceCustomSectionCodesVal,
		Lastname:                  lastnameVal,
		LegalName:                 legalNameVal,
		LegalNumber:               legalNumberVal,
		LogoUrl:                   logoUrlVal,
		Metadata:                  metadataVal,
		Name:                      nameVal,
		NetPaymentTerm:            netPaymentTermVal,
		Phone:                     phoneVal,
		ShippingAddress:           shippingAddressVal,
		SkipInvoiceCustomSections: skipInvoiceCustomSectionsVal,
		State:                     stateVal,
		TaxCodes:                  taxCodesVal,
		TaxIdentificationNumber:   taxIdentificationNumberVal,
		Timezone:                  timezoneVal,
		Url:                       urlVal,
		Zipcode:                   zipcodeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewCustomerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomerValue {
	object, diags := NewCustomerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomerValueMust(CustomerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomerType) ValueType(ctx context.Context) attr.Value {
	return CustomerValue{}
}

var _ basetypes.ObjectValuable = CustomerValue{}

type CustomerValue struct {
	AccountType               basetypes.StringValue `tfsdk:"account_type"`
	AddressLine1              basetypes.StringValue `tfsdk:"address_line1"`
	AddressLine2              basetypes.StringValue `tfsdk:"address_line2"`
	BillingConfiguration      basetypes.ObjectValue `tfsdk:"billing_configuration"`
	City                      basetypes.StringValue `tfsdk:"city"`
	Country                   basetypes.StringValue `tfsdk:"country"`
	Currency                  basetypes.StringValue `tfsdk:"currency"`
	CustomerType              basetypes.StringValue `tfsdk:"customer_type"`
	Email                     basetypes.StringValue `tfsdk:"email"`
	ExternalId                basetypes.StringValue `tfsdk:"external_id"`
	FinalizeZeroAmountInvoice basetypes.StringValue `tfsdk:"finalize_zero_amount_invoice"`
	Firstname                 basetypes.StringValue `tfsdk:"firstname"`
	IntegrationCustomers      basetypes.ListValue   `tfsdk:"integration_customers"`
	InvoiceCustomSectionCodes basetypes.ListValue   `tfsdk:"invoice_custom_section_codes"`
	Lastname                  basetypes.StringValue `tfsdk:"lastname"`
	LegalName                 basetypes.StringValue `tfsdk:"legal_name"`
	LegalNumber               basetypes.StringValue `tfsdk:"legal_number"`
	LogoUrl                   basetypes.StringValue `tfsdk:"logo_url"`
	Metadata                  basetypes.ListValue   `tfsdk:"metadata"`
	Name                      basetypes.StringValue `tfsdk:"name"`
	NetPaymentTerm            basetypes.Int64Value  `tfsdk:"net_payment_term"`
	Phone                     basetypes.StringValue `tfsdk:"phone"`
	ShippingAddress           basetypes.ObjectValue `tfsdk:"shipping_address"`
	SkipInvoiceCustomSections basetypes.BoolValue   `tfsdk:"skip_invoice_custom_sections"`
	State                     basetypes.StringValue `tfsdk:"state"`
	TaxCodes                  basetypes.ListValue   `tfsdk:"tax_codes"`
	TaxIdentificationNumber   basetypes.StringValue `tfsdk:"tax_identification_number"`
	Timezone                  basetypes.StringValue `tfsdk:"timezone"`
	Url                       basetypes.StringValue `tfsdk:"url"`
	Zipcode                   basetypes.StringValue `tfsdk:"zipcode"`
	state                     attr.ValueState
}

func (v CustomerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 30)

	var val tftypes.Value
	var err error

	attrTypes["account_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["address_line1"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["address_line2"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["billing_configuration"] = basetypes.ObjectType{
		AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["city"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["country"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["finalize_zero_amount_invoice"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["firstname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["integration_customers"] = basetypes.ListType{
		ElemType: IntegrationCustomersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["invoice_custom_section_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["lastname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["legal_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["legal_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["logo_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ListType{
		ElemType: MetadataValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["net_payment_term"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["phone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["shipping_address"] = basetypes.ObjectType{
		AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["skip_invoice_custom_sections"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tax_codes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tax_identification_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timezone"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["zipcode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 30)

		val, err = v.AccountType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["account_type"] = val

		val, err = v.AddressLine1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_line1"] = val

		val, err = v.AddressLine2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_line2"] = val

		val, err = v.BillingConfiguration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billing_configuration"] = val

		val, err = v.City.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["city"] = val

		val, err = v.Country.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country"] = val

		val, err = v.Currency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["currency"] = val

		val, err = v.CustomerType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_type"] = val

		val, err = v.Email.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email"] = val

		val, err = v.ExternalId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_id"] = val

		val, err = v.FinalizeZeroAmountInvoice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["finalize_zero_amount_invoice"] = val

		val, err = v.Firstname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["firstname"] = val

		val, err = v.IntegrationCustomers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["integration_customers"] = val

		val, err = v.InvoiceCustomSectionCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_custom_section_codes"] = val

		val, err = v.Lastname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lastname"] = val

		val, err = v.LegalName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["legal_name"] = val

		val, err = v.LegalNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["legal_number"] = val

		val, err = v.LogoUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["logo_url"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NetPaymentTerm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["net_payment_term"] = val

		val, err = v.Phone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["phone"] = val

		val, err = v.ShippingAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["shipping_address"] = val

		val, err = v.SkipInvoiceCustomSections.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["skip_invoice_custom_sections"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.TaxCodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_codes"] = val

		val, err = v.TaxIdentificationNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tax_identification_number"] = val

		val, err = v.Timezone.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timezone"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Zipcode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["zipcode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomerValue) String() string {
	return "CustomerValue"
}

func (v CustomerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var billingConfiguration basetypes.ObjectValue

	if v.BillingConfiguration.IsNull() {
		billingConfiguration = types.ObjectNull(
			BillingConfigurationValue{}.AttributeTypes(ctx),
		)
	}

	if v.BillingConfiguration.IsUnknown() {
		billingConfiguration = types.ObjectUnknown(
			BillingConfigurationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BillingConfiguration.IsNull() && !v.BillingConfiguration.IsUnknown() {
		billingConfiguration = types.ObjectValueMust(
			BillingConfigurationValue{}.AttributeTypes(ctx),
			v.BillingConfiguration.Attributes(),
		)
	}

	integrationCustomers := types.ListValueMust(
		IntegrationCustomersType{
			basetypes.ObjectType{
				AttrTypes: IntegrationCustomersValue{}.AttributeTypes(ctx),
			},
		},
		v.IntegrationCustomers.Elements(),
	)

	if v.IntegrationCustomers.IsNull() {
		integrationCustomers = types.ListNull(
			IntegrationCustomersType{
				basetypes.ObjectType{
					AttrTypes: IntegrationCustomersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IntegrationCustomers.IsUnknown() {
		integrationCustomers = types.ListUnknown(
			IntegrationCustomersType{
				basetypes.ObjectType{
					AttrTypes: IntegrationCustomersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	metadata := types.ListValueMust(
		MetadataType{
			basetypes.ObjectType{
				AttrTypes: MetadataValue{}.AttributeTypes(ctx),
			},
		},
		v.Metadata.Elements(),
	)

	if v.Metadata.IsNull() {
		metadata = types.ListNull(
			MetadataType{
				basetypes.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ListUnknown(
			MetadataType{
				basetypes.ObjectType{
					AttrTypes: MetadataValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var shippingAddress basetypes.ObjectValue

	if v.ShippingAddress.IsNull() {
		shippingAddress = types.ObjectNull(
			ShippingAddressValue{}.AttributeTypes(ctx),
		)
	}

	if v.ShippingAddress.IsUnknown() {
		shippingAddress = types.ObjectUnknown(
			ShippingAddressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ShippingAddress.IsNull() && !v.ShippingAddress.IsUnknown() {
		shippingAddress = types.ObjectValueMust(
			ShippingAddressValue{}.AttributeTypes(ctx),
			v.ShippingAddress.Attributes(),
		)
	}

	var invoiceCustomSectionCodesVal basetypes.ListValue
	switch {
	case v.InvoiceCustomSectionCodes.IsUnknown():
		invoiceCustomSectionCodesVal = types.ListUnknown(types.StringType)
	case v.InvoiceCustomSectionCodes.IsNull():
		invoiceCustomSectionCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		invoiceCustomSectionCodesVal, d = types.ListValue(types.StringType, v.InvoiceCustomSectionCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"account_type":  basetypes.StringType{},
			"address_line1": basetypes.StringType{},
			"address_line2": basetypes.StringType{},
			"billing_configuration": basetypes.ObjectType{
				AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
			},
			"city":                         basetypes.StringType{},
			"country":                      basetypes.StringType{},
			"currency":                     basetypes.StringType{},
			"customer_type":                basetypes.StringType{},
			"email":                        basetypes.StringType{},
			"external_id":                  basetypes.StringType{},
			"finalize_zero_amount_invoice": basetypes.StringType{},
			"firstname":                    basetypes.StringType{},
			"integration_customers": basetypes.ListType{
				ElemType: IntegrationCustomersValue{}.Type(ctx),
			},
			"invoice_custom_section_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"lastname":     basetypes.StringType{},
			"legal_name":   basetypes.StringType{},
			"legal_number": basetypes.StringType{},
			"logo_url":     basetypes.StringType{},
			"metadata": basetypes.ListType{
				ElemType: MetadataValue{}.Type(ctx),
			},
			"name":             basetypes.StringType{},
			"net_payment_term": basetypes.Int64Type{},
			"phone":            basetypes.StringType{},
			"shipping_address": basetypes.ObjectType{
				AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
			},
			"skip_invoice_custom_sections": basetypes.BoolType{},
			"state":                        basetypes.StringType{},
			"tax_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tax_identification_number": basetypes.StringType{},
			"timezone":                  basetypes.StringType{},
			"url":                       basetypes.StringType{},
			"zipcode":                   basetypes.StringType{},
		}), diags
	}

	var taxCodesVal basetypes.ListValue
	switch {
	case v.TaxCodes.IsUnknown():
		taxCodesVal = types.ListUnknown(types.StringType)
	case v.TaxCodes.IsNull():
		taxCodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		taxCodesVal, d = types.ListValue(types.StringType, v.TaxCodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"account_type":  basetypes.StringType{},
			"address_line1": basetypes.StringType{},
			"address_line2": basetypes.StringType{},
			"billing_configuration": basetypes.ObjectType{
				AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
			},
			"city":                         basetypes.StringType{},
			"country":                      basetypes.StringType{},
			"currency":                     basetypes.StringType{},
			"customer_type":                basetypes.StringType{},
			"email":                        basetypes.StringType{},
			"external_id":                  basetypes.StringType{},
			"finalize_zero_amount_invoice": basetypes.StringType{},
			"firstname":                    basetypes.StringType{},
			"integration_customers": basetypes.ListType{
				ElemType: IntegrationCustomersValue{}.Type(ctx),
			},
			"invoice_custom_section_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"lastname":     basetypes.StringType{},
			"legal_name":   basetypes.StringType{},
			"legal_number": basetypes.StringType{},
			"logo_url":     basetypes.StringType{},
			"metadata": basetypes.ListType{
				ElemType: MetadataValue{}.Type(ctx),
			},
			"name":             basetypes.StringType{},
			"net_payment_term": basetypes.Int64Type{},
			"phone":            basetypes.StringType{},
			"shipping_address": basetypes.ObjectType{
				AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
			},
			"skip_invoice_custom_sections": basetypes.BoolType{},
			"state":                        basetypes.StringType{},
			"tax_codes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tax_identification_number": basetypes.StringType{},
			"timezone":                  basetypes.StringType{},
			"url":                       basetypes.StringType{},
			"zipcode":                   basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"account_type":  basetypes.StringType{},
		"address_line1": basetypes.StringType{},
		"address_line2": basetypes.StringType{},
		"billing_configuration": basetypes.ObjectType{
			AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
		},
		"city":                         basetypes.StringType{},
		"country":                      basetypes.StringType{},
		"currency":                     basetypes.StringType{},
		"customer_type":                basetypes.StringType{},
		"email":                        basetypes.StringType{},
		"external_id":                  basetypes.StringType{},
		"finalize_zero_amount_invoice": basetypes.StringType{},
		"firstname":                    basetypes.StringType{},
		"integration_customers": basetypes.ListType{
			ElemType: IntegrationCustomersValue{}.Type(ctx),
		},
		"invoice_custom_section_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"lastname":     basetypes.StringType{},
		"legal_name":   basetypes.StringType{},
		"legal_number": basetypes.StringType{},
		"logo_url":     basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: MetadataValue{}.Type(ctx),
		},
		"name":             basetypes.StringType{},
		"net_payment_term": basetypes.Int64Type{},
		"phone":            basetypes.StringType{},
		"shipping_address": basetypes.ObjectType{
			AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
		},
		"skip_invoice_custom_sections": basetypes.BoolType{},
		"state":                        basetypes.StringType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"tax_identification_number": basetypes.StringType{},
		"timezone":                  basetypes.StringType{},
		"url":                       basetypes.StringType{},
		"zipcode":                   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"account_type":                 v.AccountType,
			"address_line1":                v.AddressLine1,
			"address_line2":                v.AddressLine2,
			"billing_configuration":        billingConfiguration,
			"city":                         v.City,
			"country":                      v.Country,
			"currency":                     v.Currency,
			"customer_type":                v.CustomerType,
			"email":                        v.Email,
			"external_id":                  v.ExternalId,
			"finalize_zero_amount_invoice": v.FinalizeZeroAmountInvoice,
			"firstname":                    v.Firstname,
			"integration_customers":        integrationCustomers,
			"invoice_custom_section_codes": invoiceCustomSectionCodesVal,
			"lastname":                     v.Lastname,
			"legal_name":                   v.LegalName,
			"legal_number":                 v.LegalNumber,
			"logo_url":                     v.LogoUrl,
			"metadata":                     metadata,
			"name":                         v.Name,
			"net_payment_term":             v.NetPaymentTerm,
			"phone":                        v.Phone,
			"shipping_address":             shippingAddress,
			"skip_invoice_custom_sections": v.SkipInvoiceCustomSections,
			"state":                        v.State,
			"tax_codes":                    taxCodesVal,
			"tax_identification_number":    v.TaxIdentificationNumber,
			"timezone":                     v.Timezone,
			"url":                          v.Url,
			"zipcode":                      v.Zipcode,
		})

	return objVal, diags
}

func (v CustomerValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccountType.Equal(other.AccountType) {
		return false
	}

	if !v.AddressLine1.Equal(other.AddressLine1) {
		return false
	}

	if !v.AddressLine2.Equal(other.AddressLine2) {
		return false
	}

	if !v.BillingConfiguration.Equal(other.BillingConfiguration) {
		return false
	}

	if !v.City.Equal(other.City) {
		return false
	}

	if !v.Country.Equal(other.Country) {
		return false
	}

	if !v.Currency.Equal(other.Currency) {
		return false
	}

	if !v.CustomerType.Equal(other.CustomerType) {
		return false
	}

	if !v.Email.Equal(other.Email) {
		return false
	}

	if !v.ExternalId.Equal(other.ExternalId) {
		return false
	}

	if !v.FinalizeZeroAmountInvoice.Equal(other.FinalizeZeroAmountInvoice) {
		return false
	}

	if !v.Firstname.Equal(other.Firstname) {
		return false
	}

	if !v.IntegrationCustomers.Equal(other.IntegrationCustomers) {
		return false
	}

	if !v.InvoiceCustomSectionCodes.Equal(other.InvoiceCustomSectionCodes) {
		return false
	}

	if !v.Lastname.Equal(other.Lastname) {
		return false
	}

	if !v.LegalName.Equal(other.LegalName) {
		return false
	}

	if !v.LegalNumber.Equal(other.LegalNumber) {
		return false
	}

	if !v.LogoUrl.Equal(other.LogoUrl) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NetPaymentTerm.Equal(other.NetPaymentTerm) {
		return false
	}

	if !v.Phone.Equal(other.Phone) {
		return false
	}

	if !v.ShippingAddress.Equal(other.ShippingAddress) {
		return false
	}

	if !v.SkipInvoiceCustomSections.Equal(other.SkipInvoiceCustomSections) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.TaxCodes.Equal(other.TaxCodes) {
		return false
	}

	if !v.TaxIdentificationNumber.Equal(other.TaxIdentificationNumber) {
		return false
	}

	if !v.Timezone.Equal(other.Timezone) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Zipcode.Equal(other.Zipcode) {
		return false
	}

	return true
}

func (v CustomerValue) Type(ctx context.Context) attr.Type {
	return CustomerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"account_type":  basetypes.StringType{},
		"address_line1": basetypes.StringType{},
		"address_line2": basetypes.StringType{},
		"billing_configuration": basetypes.ObjectType{
			AttrTypes: BillingConfigurationValue{}.AttributeTypes(ctx),
		},
		"city":                         basetypes.StringType{},
		"country":                      basetypes.StringType{},
		"currency":                     basetypes.StringType{},
		"customer_type":                basetypes.StringType{},
		"email":                        basetypes.StringType{},
		"external_id":                  basetypes.StringType{},
		"finalize_zero_amount_invoice": basetypes.StringType{},
		"firstname":                    basetypes.StringType{},
		"integration_customers": basetypes.ListType{
			ElemType: IntegrationCustomersValue{}.Type(ctx),
		},
		"invoice_custom_section_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"lastname":     basetypes.StringType{},
		"legal_name":   basetypes.StringType{},
		"legal_number": basetypes.StringType{},
		"logo_url":     basetypes.StringType{},
		"metadata": basetypes.ListType{
			ElemType: MetadataValue{}.Type(ctx),
		},
		"name":             basetypes.StringType{},
		"net_payment_term": basetypes.Int64Type{},
		"phone":            basetypes.StringType{},
		"shipping_address": basetypes.ObjectType{
			AttrTypes: ShippingAddressValue{}.AttributeTypes(ctx),
		},
		"skip_invoice_custom_sections": basetypes.BoolType{},
		"state":                        basetypes.StringType{},
		"tax_codes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"tax_identification_number": basetypes.StringType{},
		"timezone":                  basetypes.StringType{},
		"url":                       basetypes.StringType{},
		"zipcode":                   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BillingConfigurationType{}

type BillingConfigurationType struct {
	basetypes.ObjectType
}

func (t BillingConfigurationType) Equal(o attr.Type) bool {
	other, ok := o.(BillingConfigurationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BillingConfigurationType) String() string {
	return "BillingConfigurationType"
}

func (t BillingConfigurationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	documentLocaleAttribute, ok := attributes["document_locale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`document_locale is missing from object`)

		return nil, diags
	}

	documentLocaleVal, ok := documentLocaleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`document_locale expected to be basetypes.StringValue, was: %T`, documentLocaleAttribute))
	}

	invoiceGracePeriodAttribute, ok := attributes["invoice_grace_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_grace_period is missing from object`)

		return nil, diags
	}

	invoiceGracePeriodVal, ok := invoiceGracePeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_grace_period expected to be basetypes.Int64Value, was: %T`, invoiceGracePeriodAttribute))
	}

	paymentProviderAttribute, ok := attributes["payment_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_provider is missing from object`)

		return nil, diags
	}

	paymentProviderVal, ok := paymentProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_provider expected to be basetypes.StringValue, was: %T`, paymentProviderAttribute))
	}

	paymentProviderCodeAttribute, ok := attributes["payment_provider_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_provider_code is missing from object`)

		return nil, diags
	}

	paymentProviderCodeVal, ok := paymentProviderCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_provider_code expected to be basetypes.StringValue, was: %T`, paymentProviderCodeAttribute))
	}

	providerCustomerIdAttribute, ok := attributes["provider_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_customer_id is missing from object`)

		return nil, diags
	}

	providerCustomerIdVal, ok := providerCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_customer_id expected to be basetypes.StringValue, was: %T`, providerCustomerIdAttribute))
	}

	providerPaymentMethodsAttribute, ok := attributes["provider_payment_methods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_payment_methods is missing from object`)

		return nil, diags
	}

	providerPaymentMethodsVal, ok := providerPaymentMethodsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_payment_methods expected to be basetypes.ListValue, was: %T`, providerPaymentMethodsAttribute))
	}

	syncAttribute, ok := attributes["sync"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync is missing from object`)

		return nil, diags
	}

	syncVal, ok := syncAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync expected to be basetypes.BoolValue, was: %T`, syncAttribute))
	}

	syncWithProviderAttribute, ok := attributes["sync_with_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync_with_provider is missing from object`)

		return nil, diags
	}

	syncWithProviderVal, ok := syncWithProviderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync_with_provider expected to be basetypes.BoolValue, was: %T`, syncWithProviderAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BillingConfigurationValue{
		DocumentLocale:         documentLocaleVal,
		InvoiceGracePeriod:     invoiceGracePeriodVal,
		PaymentProvider:        paymentProviderVal,
		PaymentProviderCode:    paymentProviderCodeVal,
		ProviderCustomerId:     providerCustomerIdVal,
		ProviderPaymentMethods: providerPaymentMethodsVal,
		Sync:                   syncVal,
		SyncWithProvider:       syncWithProviderVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBillingConfigurationValueNull() BillingConfigurationValue {
	return BillingConfigurationValue{
		state: attr.ValueStateNull,
	}
}

func NewBillingConfigurationValueUnknown() BillingConfigurationValue {
	return BillingConfigurationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBillingConfigurationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BillingConfigurationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BillingConfigurationValue Attribute Value",
				"While creating a BillingConfigurationValue value, a missing attribute value was detected. "+
					"A BillingConfigurationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BillingConfigurationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BillingConfigurationValue Attribute Type",
				"While creating a BillingConfigurationValue value, an invalid attribute value was detected. "+
					"A BillingConfigurationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BillingConfigurationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BillingConfigurationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BillingConfigurationValue Attribute Value",
				"While creating a BillingConfigurationValue value, an extra attribute value was detected. "+
					"A BillingConfigurationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BillingConfigurationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBillingConfigurationValueUnknown(), diags
	}

	documentLocaleAttribute, ok := attributes["document_locale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`document_locale is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	documentLocaleVal, ok := documentLocaleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`document_locale expected to be basetypes.StringValue, was: %T`, documentLocaleAttribute))
	}

	invoiceGracePeriodAttribute, ok := attributes["invoice_grace_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_grace_period is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	invoiceGracePeriodVal, ok := invoiceGracePeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_grace_period expected to be basetypes.Int64Value, was: %T`, invoiceGracePeriodAttribute))
	}

	paymentProviderAttribute, ok := attributes["payment_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_provider is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	paymentProviderVal, ok := paymentProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_provider expected to be basetypes.StringValue, was: %T`, paymentProviderAttribute))
	}

	paymentProviderCodeAttribute, ok := attributes["payment_provider_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`payment_provider_code is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	paymentProviderCodeVal, ok := paymentProviderCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`payment_provider_code expected to be basetypes.StringValue, was: %T`, paymentProviderCodeAttribute))
	}

	providerCustomerIdAttribute, ok := attributes["provider_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_customer_id is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	providerCustomerIdVal, ok := providerCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_customer_id expected to be basetypes.StringValue, was: %T`, providerCustomerIdAttribute))
	}

	providerPaymentMethodsAttribute, ok := attributes["provider_payment_methods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider_payment_methods is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	providerPaymentMethodsVal, ok := providerPaymentMethodsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider_payment_methods expected to be basetypes.ListValue, was: %T`, providerPaymentMethodsAttribute))
	}

	syncAttribute, ok := attributes["sync"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	syncVal, ok := syncAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync expected to be basetypes.BoolValue, was: %T`, syncAttribute))
	}

	syncWithProviderAttribute, ok := attributes["sync_with_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync_with_provider is missing from object`)

		return NewBillingConfigurationValueUnknown(), diags
	}

	syncWithProviderVal, ok := syncWithProviderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync_with_provider expected to be basetypes.BoolValue, was: %T`, syncWithProviderAttribute))
	}

	if diags.HasError() {
		return NewBillingConfigurationValueUnknown(), diags
	}

	return BillingConfigurationValue{
		DocumentLocale:         documentLocaleVal,
		InvoiceGracePeriod:     invoiceGracePeriodVal,
		PaymentProvider:        paymentProviderVal,
		PaymentProviderCode:    paymentProviderCodeVal,
		ProviderCustomerId:     providerCustomerIdVal,
		ProviderPaymentMethods: providerPaymentMethodsVal,
		Sync:                   syncVal,
		SyncWithProvider:       syncWithProviderVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBillingConfigurationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BillingConfigurationValue {
	object, diags := NewBillingConfigurationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBillingConfigurationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BillingConfigurationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBillingConfigurationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBillingConfigurationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBillingConfigurationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBillingConfigurationValueMust(BillingConfigurationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BillingConfigurationType) ValueType(ctx context.Context) attr.Value {
	return BillingConfigurationValue{}
}

var _ basetypes.ObjectValuable = BillingConfigurationValue{}

type BillingConfigurationValue struct {
	DocumentLocale         basetypes.StringValue `tfsdk:"document_locale"`
	InvoiceGracePeriod     basetypes.Int64Value  `tfsdk:"invoice_grace_period"`
	PaymentProvider        basetypes.StringValue `tfsdk:"payment_provider"`
	PaymentProviderCode    basetypes.StringValue `tfsdk:"payment_provider_code"`
	ProviderCustomerId     basetypes.StringValue `tfsdk:"provider_customer_id"`
	ProviderPaymentMethods basetypes.ListValue   `tfsdk:"provider_payment_methods"`
	Sync                   basetypes.BoolValue   `tfsdk:"sync"`
	SyncWithProvider       basetypes.BoolValue   `tfsdk:"sync_with_provider"`
	state                  attr.ValueState
}

func (v BillingConfigurationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["document_locale"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_grace_period"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["payment_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["payment_provider_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["provider_customer_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["provider_payment_methods"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["sync"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sync_with_provider"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.DocumentLocale.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["document_locale"] = val

		val, err = v.InvoiceGracePeriod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_grace_period"] = val

		val, err = v.PaymentProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_provider"] = val

		val, err = v.PaymentProviderCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["payment_provider_code"] = val

		val, err = v.ProviderCustomerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provider_customer_id"] = val

		val, err = v.ProviderPaymentMethods.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provider_payment_methods"] = val

		val, err = v.Sync.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sync"] = val

		val, err = v.SyncWithProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sync_with_provider"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BillingConfigurationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BillingConfigurationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BillingConfigurationValue) String() string {
	return "BillingConfigurationValue"
}

func (v BillingConfigurationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var providerPaymentMethodsVal basetypes.ListValue
	switch {
	case v.ProviderPaymentMethods.IsUnknown():
		providerPaymentMethodsVal = types.ListUnknown(types.StringType)
	case v.ProviderPaymentMethods.IsNull():
		providerPaymentMethodsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		providerPaymentMethodsVal, d = types.ListValue(types.StringType, v.ProviderPaymentMethods.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"document_locale":       basetypes.StringType{},
			"invoice_grace_period":  basetypes.Int64Type{},
			"payment_provider":      basetypes.StringType{},
			"payment_provider_code": basetypes.StringType{},
			"provider_customer_id":  basetypes.StringType{},
			"provider_payment_methods": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sync":               basetypes.BoolType{},
			"sync_with_provider": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"document_locale":       basetypes.StringType{},
		"invoice_grace_period":  basetypes.Int64Type{},
		"payment_provider":      basetypes.StringType{},
		"payment_provider_code": basetypes.StringType{},
		"provider_customer_id":  basetypes.StringType{},
		"provider_payment_methods": basetypes.ListType{
			ElemType: types.StringType,
		},
		"sync":               basetypes.BoolType{},
		"sync_with_provider": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"document_locale":          v.DocumentLocale,
			"invoice_grace_period":     v.InvoiceGracePeriod,
			"payment_provider":         v.PaymentProvider,
			"payment_provider_code":    v.PaymentProviderCode,
			"provider_customer_id":     v.ProviderCustomerId,
			"provider_payment_methods": providerPaymentMethodsVal,
			"sync":                     v.Sync,
			"sync_with_provider":       v.SyncWithProvider,
		})

	return objVal, diags
}

func (v BillingConfigurationValue) Equal(o attr.Value) bool {
	other, ok := o.(BillingConfigurationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DocumentLocale.Equal(other.DocumentLocale) {
		return false
	}

	if !v.InvoiceGracePeriod.Equal(other.InvoiceGracePeriod) {
		return false
	}

	if !v.PaymentProvider.Equal(other.PaymentProvider) {
		return false
	}

	if !v.PaymentProviderCode.Equal(other.PaymentProviderCode) {
		return false
	}

	if !v.ProviderCustomerId.Equal(other.ProviderCustomerId) {
		return false
	}

	if !v.ProviderPaymentMethods.Equal(other.ProviderPaymentMethods) {
		return false
	}

	if !v.Sync.Equal(other.Sync) {
		return false
	}

	if !v.SyncWithProvider.Equal(other.SyncWithProvider) {
		return false
	}

	return true
}

func (v BillingConfigurationValue) Type(ctx context.Context) attr.Type {
	return BillingConfigurationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BillingConfigurationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"document_locale":       basetypes.StringType{},
		"invoice_grace_period":  basetypes.Int64Type{},
		"payment_provider":      basetypes.StringType{},
		"payment_provider_code": basetypes.StringType{},
		"provider_customer_id":  basetypes.StringType{},
		"provider_payment_methods": basetypes.ListType{
			ElemType: types.StringType,
		},
		"sync":               basetypes.BoolType{},
		"sync_with_provider": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = IntegrationCustomersType{}

type IntegrationCustomersType struct {
	basetypes.ObjectType
}

func (t IntegrationCustomersType) Equal(o attr.Type) bool {
	other, ok := o.(IntegrationCustomersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IntegrationCustomersType) String() string {
	return "IntegrationCustomersType"
}

func (t IntegrationCustomersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	externalCustomerIdAttribute, ok := attributes["external_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_customer_id is missing from object`)

		return nil, diags
	}

	externalCustomerIdVal, ok := externalCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_customer_id expected to be basetypes.StringValue, was: %T`, externalCustomerIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	integrationCodeAttribute, ok := attributes["integration_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`integration_code is missing from object`)

		return nil, diags
	}

	integrationCodeVal, ok := integrationCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`integration_code expected to be basetypes.StringValue, was: %T`, integrationCodeAttribute))
	}

	integrationTypeAttribute, ok := attributes["integration_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`integration_type is missing from object`)

		return nil, diags
	}

	integrationTypeVal, ok := integrationTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`integration_type expected to be basetypes.StringValue, was: %T`, integrationTypeAttribute))
	}

	subsidiaryIdAttribute, ok := attributes["subsidiary_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subsidiary_id is missing from object`)

		return nil, diags
	}

	subsidiaryIdVal, ok := subsidiaryIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subsidiary_id expected to be basetypes.StringValue, was: %T`, subsidiaryIdAttribute))
	}

	syncWithProviderAttribute, ok := attributes["sync_with_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync_with_provider is missing from object`)

		return nil, diags
	}

	syncWithProviderVal, ok := syncWithProviderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync_with_provider expected to be basetypes.BoolValue, was: %T`, syncWithProviderAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IntegrationCustomersValue{
		ExternalCustomerId: externalCustomerIdVal,
		Id:                 idVal,
		IntegrationCode:    integrationCodeVal,
		IntegrationType:    integrationTypeVal,
		SubsidiaryId:       subsidiaryIdVal,
		SyncWithProvider:   syncWithProviderVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewIntegrationCustomersValueNull() IntegrationCustomersValue {
	return IntegrationCustomersValue{
		state: attr.ValueStateNull,
	}
}

func NewIntegrationCustomersValueUnknown() IntegrationCustomersValue {
	return IntegrationCustomersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIntegrationCustomersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IntegrationCustomersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IntegrationCustomersValue Attribute Value",
				"While creating a IntegrationCustomersValue value, a missing attribute value was detected. "+
					"A IntegrationCustomersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IntegrationCustomersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IntegrationCustomersValue Attribute Type",
				"While creating a IntegrationCustomersValue value, an invalid attribute value was detected. "+
					"A IntegrationCustomersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IntegrationCustomersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IntegrationCustomersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IntegrationCustomersValue Attribute Value",
				"While creating a IntegrationCustomersValue value, an extra attribute value was detected. "+
					"A IntegrationCustomersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IntegrationCustomersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIntegrationCustomersValueUnknown(), diags
	}

	externalCustomerIdAttribute, ok := attributes["external_customer_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_customer_id is missing from object`)

		return NewIntegrationCustomersValueUnknown(), diags
	}

	externalCustomerIdVal, ok := externalCustomerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_customer_id expected to be basetypes.StringValue, was: %T`, externalCustomerIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewIntegrationCustomersValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	integrationCodeAttribute, ok := attributes["integration_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`integration_code is missing from object`)

		return NewIntegrationCustomersValueUnknown(), diags
	}

	integrationCodeVal, ok := integrationCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`integration_code expected to be basetypes.StringValue, was: %T`, integrationCodeAttribute))
	}

	integrationTypeAttribute, ok := attributes["integration_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`integration_type is missing from object`)

		return NewIntegrationCustomersValueUnknown(), diags
	}

	integrationTypeVal, ok := integrationTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`integration_type expected to be basetypes.StringValue, was: %T`, integrationTypeAttribute))
	}

	subsidiaryIdAttribute, ok := attributes["subsidiary_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subsidiary_id is missing from object`)

		return NewIntegrationCustomersValueUnknown(), diags
	}

	subsidiaryIdVal, ok := subsidiaryIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subsidiary_id expected to be basetypes.StringValue, was: %T`, subsidiaryIdAttribute))
	}

	syncWithProviderAttribute, ok := attributes["sync_with_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sync_with_provider is missing from object`)

		return NewIntegrationCustomersValueUnknown(), diags
	}

	syncWithProviderVal, ok := syncWithProviderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sync_with_provider expected to be basetypes.BoolValue, was: %T`, syncWithProviderAttribute))
	}

	if diags.HasError() {
		return NewIntegrationCustomersValueUnknown(), diags
	}

	return IntegrationCustomersValue{
		ExternalCustomerId: externalCustomerIdVal,
		Id:                 idVal,
		IntegrationCode:    integrationCodeVal,
		IntegrationType:    integrationTypeVal,
		SubsidiaryId:       subsidiaryIdVal,
		SyncWithProvider:   syncWithProviderVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewIntegrationCustomersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IntegrationCustomersValue {
	object, diags := NewIntegrationCustomersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIntegrationCustomersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IntegrationCustomersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIntegrationCustomersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIntegrationCustomersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIntegrationCustomersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIntegrationCustomersValueMust(IntegrationCustomersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IntegrationCustomersType) ValueType(ctx context.Context) attr.Value {
	return IntegrationCustomersValue{}
}

var _ basetypes.ObjectValuable = IntegrationCustomersValue{}

type IntegrationCustomersValue struct {
	ExternalCustomerId basetypes.StringValue `tfsdk:"external_customer_id"`
	Id                 basetypes.StringValue `tfsdk:"id"`
	IntegrationCode    basetypes.StringValue `tfsdk:"integration_code"`
	IntegrationType    basetypes.StringValue `tfsdk:"integration_type"`
	SubsidiaryId       basetypes.StringValue `tfsdk:"subsidiary_id"`
	SyncWithProvider   basetypes.BoolValue   `tfsdk:"sync_with_provider"`
	state              attr.ValueState
}

func (v IntegrationCustomersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["external_customer_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["integration_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["integration_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subsidiary_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sync_with_provider"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.ExternalCustomerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_customer_id"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.IntegrationCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["integration_code"] = val

		val, err = v.IntegrationType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["integration_type"] = val

		val, err = v.SubsidiaryId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subsidiary_id"] = val

		val, err = v.SyncWithProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sync_with_provider"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IntegrationCustomersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IntegrationCustomersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IntegrationCustomersValue) String() string {
	return "IntegrationCustomersValue"
}

func (v IntegrationCustomersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"external_customer_id": basetypes.StringType{},
		"id":                   basetypes.StringType{},
		"integration_code":     basetypes.StringType{},
		"integration_type":     basetypes.StringType{},
		"subsidiary_id":        basetypes.StringType{},
		"sync_with_provider":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"external_customer_id": v.ExternalCustomerId,
			"id":                   v.Id,
			"integration_code":     v.IntegrationCode,
			"integration_type":     v.IntegrationType,
			"subsidiary_id":        v.SubsidiaryId,
			"sync_with_provider":   v.SyncWithProvider,
		})

	return objVal, diags
}

func (v IntegrationCustomersValue) Equal(o attr.Value) bool {
	other, ok := o.(IntegrationCustomersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExternalCustomerId.Equal(other.ExternalCustomerId) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.IntegrationCode.Equal(other.IntegrationCode) {
		return false
	}

	if !v.IntegrationType.Equal(other.IntegrationType) {
		return false
	}

	if !v.SubsidiaryId.Equal(other.SubsidiaryId) {
		return false
	}

	if !v.SyncWithProvider.Equal(other.SyncWithProvider) {
		return false
	}

	return true
}

func (v IntegrationCustomersValue) Type(ctx context.Context) attr.Type {
	return IntegrationCustomersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IntegrationCustomersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"external_customer_id": basetypes.StringType{},
		"id":                   basetypes.StringType{},
		"integration_code":     basetypes.StringType{},
		"integration_type":     basetypes.StringType{},
		"subsidiary_id":        basetypes.StringType{},
		"sync_with_provider":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	displayInInvoiceAttribute, ok := attributes["display_in_invoice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_in_invoice is missing from object`)

		return nil, diags
	}

	displayInInvoiceVal, ok := displayInInvoiceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_in_invoice expected to be basetypes.BoolValue, was: %T`, displayInInvoiceAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		DisplayInInvoice: displayInInvoiceVal,
		Id:               idVal,
		Key:              keyVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	displayInInvoiceAttribute, ok := attributes["display_in_invoice"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_in_invoice is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	displayInInvoiceVal, ok := displayInInvoiceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_in_invoice expected to be basetypes.BoolValue, was: %T`, displayInInvoiceAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		DisplayInInvoice: displayInInvoiceVal,
		Id:               idVal,
		Key:              keyVal,
		Value:            valueVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	DisplayInInvoice basetypes.BoolValue   `tfsdk:"display_in_invoice"`
	Id               basetypes.StringValue `tfsdk:"id"`
	Key              basetypes.StringValue `tfsdk:"key"`
	Value            basetypes.StringValue `tfsdk:"value"`
	state            attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["display_in_invoice"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DisplayInInvoice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_in_invoice"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"display_in_invoice": basetypes.BoolType{},
		"id":                 basetypes.StringType{},
		"key":                basetypes.StringType{},
		"value":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"display_in_invoice": v.DisplayInInvoice,
			"id":                 v.Id,
			"key":                v.Key,
			"value":              v.Value,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisplayInInvoice.Equal(other.DisplayInInvoice) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"display_in_invoice": basetypes.BoolType{},
		"id":                 basetypes.StringType{},
		"key":                basetypes.StringType{},
		"value":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ShippingAddressType{}

type ShippingAddressType struct {
	basetypes.ObjectType
}

func (t ShippingAddressType) Equal(o attr.Type) bool {
	other, ok := o.(ShippingAddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ShippingAddressType) String() string {
	return "ShippingAddressType"
}

func (t ShippingAddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressLine1Attribute, ok := attributes["address_line1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line1 is missing from object`)

		return nil, diags
	}

	addressLine1Val, ok := addressLine1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line1 expected to be basetypes.StringValue, was: %T`, addressLine1Attribute))
	}

	addressLine2Attribute, ok := attributes["address_line2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line2 is missing from object`)

		return nil, diags
	}

	addressLine2Val, ok := addressLine2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line2 expected to be basetypes.StringValue, was: %T`, addressLine2Attribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return nil, diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return nil, diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	zipcodeAttribute, ok := attributes["zipcode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zipcode is missing from object`)

		return nil, diags
	}

	zipcodeVal, ok := zipcodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zipcode expected to be basetypes.StringValue, was: %T`, zipcodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ShippingAddressValue{
		AddressLine1: addressLine1Val,
		AddressLine2: addressLine2Val,
		City:         cityVal,
		Country:      countryVal,
		State:        stateVal,
		Zipcode:      zipcodeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewShippingAddressValueNull() ShippingAddressValue {
	return ShippingAddressValue{
		state: attr.ValueStateNull,
	}
}

func NewShippingAddressValueUnknown() ShippingAddressValue {
	return ShippingAddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewShippingAddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ShippingAddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ShippingAddressValue Attribute Value",
				"While creating a ShippingAddressValue value, a missing attribute value was detected. "+
					"A ShippingAddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ShippingAddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ShippingAddressValue Attribute Type",
				"While creating a ShippingAddressValue value, an invalid attribute value was detected. "+
					"A ShippingAddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ShippingAddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ShippingAddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ShippingAddressValue Attribute Value",
				"While creating a ShippingAddressValue value, an extra attribute value was detected. "+
					"A ShippingAddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ShippingAddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewShippingAddressValueUnknown(), diags
	}

	addressLine1Attribute, ok := attributes["address_line1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line1 is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	addressLine1Val, ok := addressLine1Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line1 expected to be basetypes.StringValue, was: %T`, addressLine1Attribute))
	}

	addressLine2Attribute, ok := attributes["address_line2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_line2 is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	addressLine2Val, ok := addressLine2Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_line2 expected to be basetypes.StringValue, was: %T`, addressLine2Attribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryAttribute, ok := attributes["country"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	countryVal, ok := countryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country expected to be basetypes.StringValue, was: %T`, countryAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	zipcodeAttribute, ok := attributes["zipcode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zipcode is missing from object`)

		return NewShippingAddressValueUnknown(), diags
	}

	zipcodeVal, ok := zipcodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zipcode expected to be basetypes.StringValue, was: %T`, zipcodeAttribute))
	}

	if diags.HasError() {
		return NewShippingAddressValueUnknown(), diags
	}

	return ShippingAddressValue{
		AddressLine1: addressLine1Val,
		AddressLine2: addressLine2Val,
		City:         cityVal,
		Country:      countryVal,
		State:        stateVal,
		Zipcode:      zipcodeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewShippingAddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ShippingAddressValue {
	object, diags := NewShippingAddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewShippingAddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ShippingAddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewShippingAddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewShippingAddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewShippingAddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewShippingAddressValueMust(ShippingAddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ShippingAddressType) ValueType(ctx context.Context) attr.Value {
	return ShippingAddressValue{}
}

var _ basetypes.ObjectValuable = ShippingAddressValue{}

type ShippingAddressValue struct {
	AddressLine1 basetypes.StringValue `tfsdk:"address_line1"`
	AddressLine2 basetypes.StringValue `tfsdk:"address_line2"`
	City         basetypes.StringValue `tfsdk:"city"`
	Country      basetypes.StringValue `tfsdk:"country"`
	State        basetypes.StringValue `tfsdk:"state"`
	Zipcode      basetypes.StringValue `tfsdk:"zipcode"`
	state        attr.ValueState
}

func (v ShippingAddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["address_line1"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["address_line2"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["city"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["country"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["zipcode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.AddressLine1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_line1"] = val

		val, err = v.AddressLine2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_line2"] = val

		val, err = v.City.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["city"] = val

		val, err = v.Country.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Zipcode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["zipcode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ShippingAddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ShippingAddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ShippingAddressValue) String() string {
	return "ShippingAddressValue"
}

func (v ShippingAddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"address_line1": basetypes.StringType{},
		"address_line2": basetypes.StringType{},
		"city":          basetypes.StringType{},
		"country":       basetypes.StringType{},
		"state":         basetypes.StringType{},
		"zipcode":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_line1": v.AddressLine1,
			"address_line2": v.AddressLine2,
			"city":          v.City,
			"country":       v.Country,
			"state":         v.State,
			"zipcode":       v.Zipcode,
		})

	return objVal, diags
}

func (v ShippingAddressValue) Equal(o attr.Value) bool {
	other, ok := o.(ShippingAddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressLine1.Equal(other.AddressLine1) {
		return false
	}

	if !v.AddressLine2.Equal(other.AddressLine2) {
		return false
	}

	if !v.City.Equal(other.City) {
		return false
	}

	if !v.Country.Equal(other.Country) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Zipcode.Equal(other.Zipcode) {
		return false
	}

	return true
}

func (v ShippingAddressValue) Type(ctx context.Context) attr.Type {
	return ShippingAddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ShippingAddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_line1": basetypes.StringType{},
		"address_line2": basetypes.StringType{},
		"city":          basetypes.StringType{},
		"country":       basetypes.StringType{},
		"state":         basetypes.StringType{},
		"zipcode":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MetaType{}

type MetaType struct {
	basetypes.ObjectType
}

func (t MetaType) Equal(o attr.Type) bool {
	other, ok := o.(MetaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetaType) String() string {
	return "MetaType"
}

func (t MetaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	currentPageAttribute, ok := attributes["current_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_page is missing from object`)

		return nil, diags
	}

	currentPageVal, ok := currentPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_page expected to be basetypes.Int64Value, was: %T`, currentPageAttribute))
	}

	nextPageAttribute, ok := attributes["next_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_page is missing from object`)

		return nil, diags
	}

	nextPageVal, ok := nextPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_page expected to be basetypes.Int64Value, was: %T`, nextPageAttribute))
	}

	prevPageAttribute, ok := attributes["prev_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prev_page is missing from object`)

		return nil, diags
	}

	prevPageVal, ok := prevPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prev_page expected to be basetypes.Int64Value, was: %T`, prevPageAttribute))
	}

	totalCountAttribute, ok := attributes["total_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_count is missing from object`)

		return nil, diags
	}

	totalCountVal, ok := totalCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_count expected to be basetypes.Int64Value, was: %T`, totalCountAttribute))
	}

	totalPagesAttribute, ok := attributes["total_pages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_pages is missing from object`)

		return nil, diags
	}

	totalPagesVal, ok := totalPagesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_pages expected to be basetypes.Int64Value, was: %T`, totalPagesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetaValue{
		CurrentPage: currentPageVal,
		NextPage:    nextPageVal,
		PrevPage:    prevPageVal,
		TotalCount:  totalCountVal,
		TotalPages:  totalPagesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetaValueNull() MetaValue {
	return MetaValue{
		state: attr.ValueStateNull,
	}
}

func NewMetaValueUnknown() MetaValue {
	return MetaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetaValue Attribute Value",
				"While creating a MetaValue value, a missing attribute value was detected. "+
					"A MetaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetaValue Attribute Type",
				"While creating a MetaValue value, an invalid attribute value was detected. "+
					"A MetaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetaValue Attribute Value",
				"While creating a MetaValue value, an extra attribute value was detected. "+
					"A MetaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	currentPageAttribute, ok := attributes["current_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_page is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	currentPageVal, ok := currentPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_page expected to be basetypes.Int64Value, was: %T`, currentPageAttribute))
	}

	nextPageAttribute, ok := attributes["next_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_page is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	nextPageVal, ok := nextPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_page expected to be basetypes.Int64Value, was: %T`, nextPageAttribute))
	}

	prevPageAttribute, ok := attributes["prev_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prev_page is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	prevPageVal, ok := prevPageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prev_page expected to be basetypes.Int64Value, was: %T`, prevPageAttribute))
	}

	totalCountAttribute, ok := attributes["total_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_count is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	totalCountVal, ok := totalCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_count expected to be basetypes.Int64Value, was: %T`, totalCountAttribute))
	}

	totalPagesAttribute, ok := attributes["total_pages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_pages is missing from object`)

		return NewMetaValueUnknown(), diags
	}

	totalPagesVal, ok := totalPagesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_pages expected to be basetypes.Int64Value, was: %T`, totalPagesAttribute))
	}

	if diags.HasError() {
		return NewMetaValueUnknown(), diags
	}

	return MetaValue{
		CurrentPage: currentPageVal,
		NextPage:    nextPageVal,
		PrevPage:    prevPageVal,
		TotalCount:  totalCountVal,
		TotalPages:  totalPagesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetaValue {
	object, diags := NewMetaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetaValueMust(MetaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetaType) ValueType(ctx context.Context) attr.Value {
	return MetaValue{}
}

var _ basetypes.ObjectValuable = MetaValue{}

type MetaValue struct {
	CurrentPage basetypes.Int64Value `tfsdk:"current_page"`
	NextPage    basetypes.Int64Value `tfsdk:"next_page"`
	PrevPage    basetypes.Int64Value `tfsdk:"prev_page"`
	TotalCount  basetypes.Int64Value `tfsdk:"total_count"`
	TotalPages  basetypes.Int64Value `tfsdk:"total_pages"`
	state       attr.ValueState
}

func (v MetaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["current_page"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["next_page"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prev_page"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_pages"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CurrentPage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_page"] = val

		val, err = v.NextPage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_page"] = val

		val, err = v.PrevPage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prev_page"] = val

		val, err = v.TotalCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_count"] = val

		val, err = v.TotalPages.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_pages"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetaValue) String() string {
	return "MetaValue"
}

func (v MetaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"current_page": basetypes.Int64Type{},
		"next_page":    basetypes.Int64Type{},
		"prev_page":    basetypes.Int64Type{},
		"total_count":  basetypes.Int64Type{},
		"total_pages":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"current_page": v.CurrentPage,
			"next_page":    v.NextPage,
			"prev_page":    v.PrevPage,
			"total_count":  v.TotalCount,
			"total_pages":  v.TotalPages,
		})

	return objVal, diags
}

func (v MetaValue) Equal(o attr.Value) bool {
	other, ok := o.(MetaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CurrentPage.Equal(other.CurrentPage) {
		return false
	}

	if !v.NextPage.Equal(other.NextPage) {
		return false
	}

	if !v.PrevPage.Equal(other.PrevPage) {
		return false
	}

	if !v.TotalCount.Equal(other.TotalCount) {
		return false
	}

	if !v.TotalPages.Equal(other.TotalPages) {
		return false
	}

	return true
}

func (v MetaValue) Type(ctx context.Context) attr.Type {
	return MetaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"current_page": basetypes.Int64Type{},
		"next_page":    basetypes.Int64Type{},
		"prev_page":    basetypes.Int64Type{},
		"total_count":  basetypes.Int64Type{},
		"total_pages":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = UsagePeriodsType{}

type UsagePeriodsType struct {
	basetypes.ObjectType
}

func (t UsagePeriodsType) Equal(o attr.Type) bool {
	other, ok := o.(UsagePeriodsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsagePeriodsType) String() string {
	return "UsagePeriodsType"
}

func (t UsagePeriodsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customerUsageAttribute, ok := attributes["customer_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_usage is missing from object`)

		return nil, diags
	}

	customerUsageVal, ok := customerUsageAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_usage expected to be basetypes.ObjectValue, was: %T`, customerUsageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsagePeriodsValue{
		CustomerUsage: customerUsageVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewUsagePeriodsValueNull() UsagePeriodsValue {
	return UsagePeriodsValue{
		state: attr.ValueStateNull,
	}
}

func NewUsagePeriodsValueUnknown() UsagePeriodsValue {
	return UsagePeriodsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsagePeriodsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsagePeriodsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsagePeriodsValue Attribute Value",
				"While creating a UsagePeriodsValue value, a missing attribute value was detected. "+
					"A UsagePeriodsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsagePeriodsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsagePeriodsValue Attribute Type",
				"While creating a UsagePeriodsValue value, an invalid attribute value was detected. "+
					"A UsagePeriodsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsagePeriodsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsagePeriodsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsagePeriodsValue Attribute Value",
				"While creating a UsagePeriodsValue value, an extra attribute value was detected. "+
					"A UsagePeriodsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsagePeriodsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsagePeriodsValueUnknown(), diags
	}

	customerUsageAttribute, ok := attributes["customer_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_usage is missing from object`)

		return NewUsagePeriodsValueUnknown(), diags
	}

	customerUsageVal, ok := customerUsageAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_usage expected to be basetypes.ObjectValue, was: %T`, customerUsageAttribute))
	}

	if diags.HasError() {
		return NewUsagePeriodsValueUnknown(), diags
	}

	return UsagePeriodsValue{
		CustomerUsage: customerUsageVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewUsagePeriodsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsagePeriodsValue {
	object, diags := NewUsagePeriodsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsagePeriodsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsagePeriodsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsagePeriodsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsagePeriodsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsagePeriodsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsagePeriodsValueMust(UsagePeriodsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsagePeriodsType) ValueType(ctx context.Context) attr.Value {
	return UsagePeriodsValue{}
}

var _ basetypes.ObjectValuable = UsagePeriodsValue{}

type UsagePeriodsValue struct {
	CustomerUsage basetypes.ObjectValue `tfsdk:"customer_usage"`
	state         attr.ValueState
}

func (v UsagePeriodsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["customer_usage"] = basetypes.ObjectType{
		AttrTypes: CustomerUsageValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.CustomerUsage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsagePeriodsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsagePeriodsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsagePeriodsValue) String() string {
	return "UsagePeriodsValue"
}

func (v UsagePeriodsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var customerUsage basetypes.ObjectValue

	if v.CustomerUsage.IsNull() {
		customerUsage = types.ObjectNull(
			CustomerUsageValue{}.AttributeTypes(ctx),
		)
	}

	if v.CustomerUsage.IsUnknown() {
		customerUsage = types.ObjectUnknown(
			CustomerUsageValue{}.AttributeTypes(ctx),
		)
	}

	if !v.CustomerUsage.IsNull() && !v.CustomerUsage.IsUnknown() {
		customerUsage = types.ObjectValueMust(
			CustomerUsageValue{}.AttributeTypes(ctx),
			v.CustomerUsage.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"customer_usage": basetypes.ObjectType{
			AttrTypes: CustomerUsageValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"customer_usage": customerUsage,
		})

	return objVal, diags
}

func (v UsagePeriodsValue) Equal(o attr.Value) bool {
	other, ok := o.(UsagePeriodsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomerUsage.Equal(other.CustomerUsage) {
		return false
	}

	return true
}

func (v UsagePeriodsValue) Type(ctx context.Context) attr.Type {
	return UsagePeriodsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsagePeriodsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"customer_usage": basetypes.ObjectType{
			AttrTypes: CustomerUsageValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = CustomerUsageType{}

type CustomerUsageType struct {
	basetypes.ObjectType
}

func (t CustomerUsageType) Equal(o attr.Type) bool {
	other, ok := o.(CustomerUsageType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomerUsageType) String() string {
	return "CustomerUsageType"
}

func (t CustomerUsageType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	chargesUsageAttribute, ok := attributes["charges_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`charges_usage is missing from object`)

		return nil, diags
	}

	chargesUsageVal, ok := chargesUsageAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`charges_usage expected to be basetypes.ListValue, was: %T`, chargesUsageAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return nil, diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	fromDatetimeAttribute, ok := attributes["from_datetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_datetime is missing from object`)

		return nil, diags
	}

	fromDatetimeVal, ok := fromDatetimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_datetime expected to be basetypes.StringValue, was: %T`, fromDatetimeAttribute))
	}

	issuingDateAttribute, ok := attributes["issuing_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`issuing_date is missing from object`)

		return nil, diags
	}

	issuingDateVal, ok := issuingDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`issuing_date expected to be basetypes.StringValue, was: %T`, issuingDateAttribute))
	}

	lagoInvoiceIdAttribute, ok := attributes["lago_invoice_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_invoice_id is missing from object`)

		return nil, diags
	}

	lagoInvoiceIdVal, ok := lagoInvoiceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_invoice_id expected to be basetypes.StringValue, was: %T`, lagoInvoiceIdAttribute))
	}

	taxesAmountCentsAttribute, ok := attributes["taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes_amount_cents is missing from object`)

		return nil, diags
	}

	taxesAmountCentsVal, ok := taxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, taxesAmountCentsAttribute))
	}

	toDatetimeAttribute, ok := attributes["to_datetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_datetime is missing from object`)

		return nil, diags
	}

	toDatetimeVal, ok := toDatetimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_datetime expected to be basetypes.StringValue, was: %T`, toDatetimeAttribute))
	}

	totalAmountCentsAttribute, ok := attributes["total_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_amount_cents is missing from object`)

		return nil, diags
	}

	totalAmountCentsVal, ok := totalAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_amount_cents expected to be basetypes.Int64Value, was: %T`, totalAmountCentsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomerUsageValue{
		AmountCents:      amountCentsVal,
		ChargesUsage:     chargesUsageVal,
		Currency:         currencyVal,
		FromDatetime:     fromDatetimeVal,
		IssuingDate:      issuingDateVal,
		LagoInvoiceId:    lagoInvoiceIdVal,
		TaxesAmountCents: taxesAmountCentsVal,
		ToDatetime:       toDatetimeVal,
		TotalAmountCents: totalAmountCentsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCustomerUsageValueNull() CustomerUsageValue {
	return CustomerUsageValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomerUsageValueUnknown() CustomerUsageValue {
	return CustomerUsageValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomerUsageValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomerUsageValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomerUsageValue Attribute Value",
				"While creating a CustomerUsageValue value, a missing attribute value was detected. "+
					"A CustomerUsageValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomerUsageValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomerUsageValue Attribute Type",
				"While creating a CustomerUsageValue value, an invalid attribute value was detected. "+
					"A CustomerUsageValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomerUsageValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomerUsageValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomerUsageValue Attribute Value",
				"While creating a CustomerUsageValue value, an extra attribute value was detected. "+
					"A CustomerUsageValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomerUsageValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomerUsageValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewCustomerUsageValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	chargesUsageAttribute, ok := attributes["charges_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`charges_usage is missing from object`)

		return NewCustomerUsageValueUnknown(), diags
	}

	chargesUsageVal, ok := chargesUsageAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`charges_usage expected to be basetypes.ListValue, was: %T`, chargesUsageAttribute))
	}

	currencyAttribute, ok := attributes["currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`currency is missing from object`)

		return NewCustomerUsageValueUnknown(), diags
	}

	currencyVal, ok := currencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`currency expected to be basetypes.StringValue, was: %T`, currencyAttribute))
	}

	fromDatetimeAttribute, ok := attributes["from_datetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_datetime is missing from object`)

		return NewCustomerUsageValueUnknown(), diags
	}

	fromDatetimeVal, ok := fromDatetimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_datetime expected to be basetypes.StringValue, was: %T`, fromDatetimeAttribute))
	}

	issuingDateAttribute, ok := attributes["issuing_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`issuing_date is missing from object`)

		return NewCustomerUsageValueUnknown(), diags
	}

	issuingDateVal, ok := issuingDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`issuing_date expected to be basetypes.StringValue, was: %T`, issuingDateAttribute))
	}

	lagoInvoiceIdAttribute, ok := attributes["lago_invoice_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_invoice_id is missing from object`)

		return NewCustomerUsageValueUnknown(), diags
	}

	lagoInvoiceIdVal, ok := lagoInvoiceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_invoice_id expected to be basetypes.StringValue, was: %T`, lagoInvoiceIdAttribute))
	}

	taxesAmountCentsAttribute, ok := attributes["taxes_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`taxes_amount_cents is missing from object`)

		return NewCustomerUsageValueUnknown(), diags
	}

	taxesAmountCentsVal, ok := taxesAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`taxes_amount_cents expected to be basetypes.Int64Value, was: %T`, taxesAmountCentsAttribute))
	}

	toDatetimeAttribute, ok := attributes["to_datetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_datetime is missing from object`)

		return NewCustomerUsageValueUnknown(), diags
	}

	toDatetimeVal, ok := toDatetimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_datetime expected to be basetypes.StringValue, was: %T`, toDatetimeAttribute))
	}

	totalAmountCentsAttribute, ok := attributes["total_amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_amount_cents is missing from object`)

		return NewCustomerUsageValueUnknown(), diags
	}

	totalAmountCentsVal, ok := totalAmountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_amount_cents expected to be basetypes.Int64Value, was: %T`, totalAmountCentsAttribute))
	}

	if diags.HasError() {
		return NewCustomerUsageValueUnknown(), diags
	}

	return CustomerUsageValue{
		AmountCents:      amountCentsVal,
		ChargesUsage:     chargesUsageVal,
		Currency:         currencyVal,
		FromDatetime:     fromDatetimeVal,
		IssuingDate:      issuingDateVal,
		LagoInvoiceId:    lagoInvoiceIdVal,
		TaxesAmountCents: taxesAmountCentsVal,
		ToDatetime:       toDatetimeVal,
		TotalAmountCents: totalAmountCentsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCustomerUsageValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomerUsageValue {
	object, diags := NewCustomerUsageValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomerUsageValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomerUsageType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomerUsageValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomerUsageValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomerUsageValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomerUsageValueMust(CustomerUsageValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomerUsageType) ValueType(ctx context.Context) attr.Value {
	return CustomerUsageValue{}
}

var _ basetypes.ObjectValuable = CustomerUsageValue{}

type CustomerUsageValue struct {
	AmountCents      basetypes.Int64Value  `tfsdk:"amount_cents"`
	ChargesUsage     basetypes.ListValue   `tfsdk:"charges_usage"`
	Currency         basetypes.StringValue `tfsdk:"currency"`
	FromDatetime     basetypes.StringValue `tfsdk:"from_datetime"`
	IssuingDate      basetypes.StringValue `tfsdk:"issuing_date"`
	LagoInvoiceId    basetypes.StringValue `tfsdk:"lago_invoice_id"`
	TaxesAmountCents basetypes.Int64Value  `tfsdk:"taxes_amount_cents"`
	ToDatetime       basetypes.StringValue `tfsdk:"to_datetime"`
	TotalAmountCents basetypes.Int64Value  `tfsdk:"total_amount_cents"`
	state            attr.ValueState
}

func (v CustomerUsageValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["charges_usage"] = basetypes.ListType{
		ElemType: ChargesUsageValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_datetime"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["issuing_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_invoice_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["taxes_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["to_datetime"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["total_amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.ChargesUsage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["charges_usage"] = val

		val, err = v.Currency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["currency"] = val

		val, err = v.FromDatetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_datetime"] = val

		val, err = v.IssuingDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["issuing_date"] = val

		val, err = v.LagoInvoiceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_invoice_id"] = val

		val, err = v.TaxesAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["taxes_amount_cents"] = val

		val, err = v.ToDatetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_datetime"] = val

		val, err = v.TotalAmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_amount_cents"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomerUsageValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomerUsageValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomerUsageValue) String() string {
	return "CustomerUsageValue"
}

func (v CustomerUsageValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	chargesUsage := types.ListValueMust(
		ChargesUsageType{
			basetypes.ObjectType{
				AttrTypes: ChargesUsageValue{}.AttributeTypes(ctx),
			},
		},
		v.ChargesUsage.Elements(),
	)

	if v.ChargesUsage.IsNull() {
		chargesUsage = types.ListNull(
			ChargesUsageType{
				basetypes.ObjectType{
					AttrTypes: ChargesUsageValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ChargesUsage.IsUnknown() {
		chargesUsage = types.ListUnknown(
			ChargesUsageType{
				basetypes.ObjectType{
					AttrTypes: ChargesUsageValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents": basetypes.Int64Type{},
		"charges_usage": basetypes.ListType{
			ElemType: ChargesUsageValue{}.Type(ctx),
		},
		"currency":           basetypes.StringType{},
		"from_datetime":      basetypes.StringType{},
		"issuing_date":       basetypes.StringType{},
		"lago_invoice_id":    basetypes.StringType{},
		"taxes_amount_cents": basetypes.Int64Type{},
		"to_datetime":        basetypes.StringType{},
		"total_amount_cents": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":       v.AmountCents,
			"charges_usage":      chargesUsage,
			"currency":           v.Currency,
			"from_datetime":      v.FromDatetime,
			"issuing_date":       v.IssuingDate,
			"lago_invoice_id":    v.LagoInvoiceId,
			"taxes_amount_cents": v.TaxesAmountCents,
			"to_datetime":        v.ToDatetime,
			"total_amount_cents": v.TotalAmountCents,
		})

	return objVal, diags
}

func (v CustomerUsageValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomerUsageValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.ChargesUsage.Equal(other.ChargesUsage) {
		return false
	}

	if !v.Currency.Equal(other.Currency) {
		return false
	}

	if !v.FromDatetime.Equal(other.FromDatetime) {
		return false
	}

	if !v.IssuingDate.Equal(other.IssuingDate) {
		return false
	}

	if !v.LagoInvoiceId.Equal(other.LagoInvoiceId) {
		return false
	}

	if !v.TaxesAmountCents.Equal(other.TaxesAmountCents) {
		return false
	}

	if !v.ToDatetime.Equal(other.ToDatetime) {
		return false
	}

	if !v.TotalAmountCents.Equal(other.TotalAmountCents) {
		return false
	}

	return true
}

func (v CustomerUsageValue) Type(ctx context.Context) attr.Type {
	return CustomerUsageType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomerUsageValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents": basetypes.Int64Type{},
		"charges_usage": basetypes.ListType{
			ElemType: ChargesUsageValue{}.Type(ctx),
		},
		"currency":           basetypes.StringType{},
		"from_datetime":      basetypes.StringType{},
		"issuing_date":       basetypes.StringType{},
		"lago_invoice_id":    basetypes.StringType{},
		"taxes_amount_cents": basetypes.Int64Type{},
		"to_datetime":        basetypes.StringType{},
		"total_amount_cents": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ChargesUsageType{}

type ChargesUsageType struct {
	basetypes.ObjectType
}

func (t ChargesUsageType) Equal(o attr.Type) bool {
	other, ok := o.(ChargesUsageType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ChargesUsageType) String() string {
	return "ChargesUsageType"
}

func (t ChargesUsageType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return nil, diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	billableMetricAttribute, ok := attributes["billable_metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable_metric is missing from object`)

		return nil, diags
	}

	billableMetricVal, ok := billableMetricAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable_metric expected to be basetypes.ObjectValue, was: %T`, billableMetricAttribute))
	}

	chargeAttribute, ok := attributes["charge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`charge is missing from object`)

		return nil, diags
	}

	chargeVal, ok := chargeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`charge expected to be basetypes.ObjectValue, was: %T`, chargeAttribute))
	}

	eventsCountAttribute, ok := attributes["events_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`events_count is missing from object`)

		return nil, diags
	}

	eventsCountVal, ok := eventsCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`events_count expected to be basetypes.Int64Value, was: %T`, eventsCountAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	groupedUsageAttribute, ok := attributes["grouped_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_usage is missing from object`)

		return nil, diags
	}

	groupedUsageVal, ok := groupedUsageAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_usage expected to be basetypes.ListValue, was: %T`, groupedUsageAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return nil, diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ChargesUsageValue{
		AmountCents:    amountCentsVal,
		AmountCurrency: amountCurrencyVal,
		BillableMetric: billableMetricVal,
		Charge:         chargeVal,
		EventsCount:    eventsCountVal,
		Filters:        filtersVal,
		GroupedUsage:   groupedUsageVal,
		Units:          unitsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewChargesUsageValueNull() ChargesUsageValue {
	return ChargesUsageValue{
		state: attr.ValueStateNull,
	}
}

func NewChargesUsageValueUnknown() ChargesUsageValue {
	return ChargesUsageValue{
		state: attr.ValueStateUnknown,
	}
}

func NewChargesUsageValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ChargesUsageValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ChargesUsageValue Attribute Value",
				"While creating a ChargesUsageValue value, a missing attribute value was detected. "+
					"A ChargesUsageValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChargesUsageValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ChargesUsageValue Attribute Type",
				"While creating a ChargesUsageValue value, an invalid attribute value was detected. "+
					"A ChargesUsageValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChargesUsageValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ChargesUsageValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ChargesUsageValue Attribute Value",
				"While creating a ChargesUsageValue value, an extra attribute value was detected. "+
					"A ChargesUsageValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ChargesUsageValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewChargesUsageValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewChargesUsageValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	amountCurrencyAttribute, ok := attributes["amount_currency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_currency is missing from object`)

		return NewChargesUsageValueUnknown(), diags
	}

	amountCurrencyVal, ok := amountCurrencyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_currency expected to be basetypes.StringValue, was: %T`, amountCurrencyAttribute))
	}

	billableMetricAttribute, ok := attributes["billable_metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable_metric is missing from object`)

		return NewChargesUsageValueUnknown(), diags
	}

	billableMetricVal, ok := billableMetricAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable_metric expected to be basetypes.ObjectValue, was: %T`, billableMetricAttribute))
	}

	chargeAttribute, ok := attributes["charge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`charge is missing from object`)

		return NewChargesUsageValueUnknown(), diags
	}

	chargeVal, ok := chargeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`charge expected to be basetypes.ObjectValue, was: %T`, chargeAttribute))
	}

	eventsCountAttribute, ok := attributes["events_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`events_count is missing from object`)

		return NewChargesUsageValueUnknown(), diags
	}

	eventsCountVal, ok := eventsCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`events_count expected to be basetypes.Int64Value, was: %T`, eventsCountAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewChargesUsageValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	groupedUsageAttribute, ok := attributes["grouped_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_usage is missing from object`)

		return NewChargesUsageValueUnknown(), diags
	}

	groupedUsageVal, ok := groupedUsageAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_usage expected to be basetypes.ListValue, was: %T`, groupedUsageAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return NewChargesUsageValueUnknown(), diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	if diags.HasError() {
		return NewChargesUsageValueUnknown(), diags
	}

	return ChargesUsageValue{
		AmountCents:    amountCentsVal,
		AmountCurrency: amountCurrencyVal,
		BillableMetric: billableMetricVal,
		Charge:         chargeVal,
		EventsCount:    eventsCountVal,
		Filters:        filtersVal,
		GroupedUsage:   groupedUsageVal,
		Units:          unitsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewChargesUsageValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ChargesUsageValue {
	object, diags := NewChargesUsageValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewChargesUsageValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ChargesUsageType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewChargesUsageValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewChargesUsageValueUnknown(), nil
	}

	if in.IsNull() {
		return NewChargesUsageValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewChargesUsageValueMust(ChargesUsageValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ChargesUsageType) ValueType(ctx context.Context) attr.Value {
	return ChargesUsageValue{}
}

var _ basetypes.ObjectValuable = ChargesUsageValue{}

type ChargesUsageValue struct {
	AmountCents    basetypes.Int64Value  `tfsdk:"amount_cents"`
	AmountCurrency basetypes.StringValue `tfsdk:"amount_currency"`
	BillableMetric basetypes.ObjectValue `tfsdk:"billable_metric"`
	Charge         basetypes.ObjectValue `tfsdk:"charge"`
	EventsCount    basetypes.Int64Value  `tfsdk:"events_count"`
	Filters        basetypes.ListValue   `tfsdk:"filters"`
	GroupedUsage   basetypes.ListValue   `tfsdk:"grouped_usage"`
	Units          basetypes.StringValue `tfsdk:"units"`
	state          attr.ValueState
}

func (v ChargesUsageValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["amount_currency"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["billable_metric"] = basetypes.ObjectType{
		AttrTypes: BillableMetricValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["charge"] = basetypes.ObjectType{
		AttrTypes: ChargeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["events_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["filters"] = basetypes.ListType{
		ElemType: FiltersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["grouped_usage"] = basetypes.ListType{
		ElemType: GroupedUsageValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["units"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.AmountCurrency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_currency"] = val

		val, err = v.BillableMetric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billable_metric"] = val

		val, err = v.Charge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["charge"] = val

		val, err = v.EventsCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["events_count"] = val

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.GroupedUsage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["grouped_usage"] = val

		val, err = v.Units.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["units"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ChargesUsageValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ChargesUsageValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ChargesUsageValue) String() string {
	return "ChargesUsageValue"
}

func (v ChargesUsageValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var billableMetric basetypes.ObjectValue

	if v.BillableMetric.IsNull() {
		billableMetric = types.ObjectNull(
			BillableMetricValue{}.AttributeTypes(ctx),
		)
	}

	if v.BillableMetric.IsUnknown() {
		billableMetric = types.ObjectUnknown(
			BillableMetricValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BillableMetric.IsNull() && !v.BillableMetric.IsUnknown() {
		billableMetric = types.ObjectValueMust(
			BillableMetricValue{}.AttributeTypes(ctx),
			v.BillableMetric.Attributes(),
		)
	}

	var charge basetypes.ObjectValue

	if v.Charge.IsNull() {
		charge = types.ObjectNull(
			ChargeValue{}.AttributeTypes(ctx),
		)
	}

	if v.Charge.IsUnknown() {
		charge = types.ObjectUnknown(
			ChargeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Charge.IsNull() && !v.Charge.IsUnknown() {
		charge = types.ObjectValueMust(
			ChargeValue{}.AttributeTypes(ctx),
			v.Charge.Attributes(),
		)
	}

	filters := types.ListValueMust(
		FiltersType{
			basetypes.ObjectType{
				AttrTypes: FiltersValue{}.AttributeTypes(ctx),
			},
		},
		v.Filters.Elements(),
	)

	if v.Filters.IsNull() {
		filters = types.ListNull(
			FiltersType{
				basetypes.ObjectType{
					AttrTypes: FiltersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Filters.IsUnknown() {
		filters = types.ListUnknown(
			FiltersType{
				basetypes.ObjectType{
					AttrTypes: FiltersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	groupedUsage := types.ListValueMust(
		GroupedUsageType{
			basetypes.ObjectType{
				AttrTypes: GroupedUsageValue{}.AttributeTypes(ctx),
			},
		},
		v.GroupedUsage.Elements(),
	)

	if v.GroupedUsage.IsNull() {
		groupedUsage = types.ListNull(
			GroupedUsageType{
				basetypes.ObjectType{
					AttrTypes: GroupedUsageValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.GroupedUsage.IsUnknown() {
		groupedUsage = types.ListUnknown(
			GroupedUsageType{
				basetypes.ObjectType{
					AttrTypes: GroupedUsageValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"billable_metric": basetypes.ObjectType{
			AttrTypes: BillableMetricValue{}.AttributeTypes(ctx),
		},
		"charge": basetypes.ObjectType{
			AttrTypes: ChargeValue{}.AttributeTypes(ctx),
		},
		"events_count": basetypes.Int64Type{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"grouped_usage": basetypes.ListType{
			ElemType: GroupedUsageValue{}.Type(ctx),
		},
		"units": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":    v.AmountCents,
			"amount_currency": v.AmountCurrency,
			"billable_metric": billableMetric,
			"charge":          charge,
			"events_count":    v.EventsCount,
			"filters":         filters,
			"grouped_usage":   groupedUsage,
			"units":           v.Units,
		})

	return objVal, diags
}

func (v ChargesUsageValue) Equal(o attr.Value) bool {
	other, ok := o.(ChargesUsageValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.AmountCurrency.Equal(other.AmountCurrency) {
		return false
	}

	if !v.BillableMetric.Equal(other.BillableMetric) {
		return false
	}

	if !v.Charge.Equal(other.Charge) {
		return false
	}

	if !v.EventsCount.Equal(other.EventsCount) {
		return false
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.GroupedUsage.Equal(other.GroupedUsage) {
		return false
	}

	if !v.Units.Equal(other.Units) {
		return false
	}

	return true
}

func (v ChargesUsageValue) Type(ctx context.Context) attr.Type {
	return ChargesUsageType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ChargesUsageValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":    basetypes.Int64Type{},
		"amount_currency": basetypes.StringType{},
		"billable_metric": basetypes.ObjectType{
			AttrTypes: BillableMetricValue{}.AttributeTypes(ctx),
		},
		"charge": basetypes.ObjectType{
			AttrTypes: ChargeValue{}.AttributeTypes(ctx),
		},
		"events_count": basetypes.Int64Type{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"grouped_usage": basetypes.ListType{
			ElemType: GroupedUsageValue{}.Type(ctx),
		},
		"units": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BillableMetricType{}

type BillableMetricType struct {
	basetypes.ObjectType
}

func (t BillableMetricType) Equal(o attr.Type) bool {
	other, ok := o.(BillableMetricType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BillableMetricType) String() string {
	return "BillableMetricType"
}

func (t BillableMetricType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aggregationTypeAttribute, ok := attributes["aggregation_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregation_type is missing from object`)

		return nil, diags
	}

	aggregationTypeVal, ok := aggregationTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregation_type expected to be basetypes.StringValue, was: %T`, aggregationTypeAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BillableMetricValue{
		AggregationType: aggregationTypeVal,
		Code:            codeVal,
		LagoId:          lagoIdVal,
		Name:            nameVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBillableMetricValueNull() BillableMetricValue {
	return BillableMetricValue{
		state: attr.ValueStateNull,
	}
}

func NewBillableMetricValueUnknown() BillableMetricValue {
	return BillableMetricValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBillableMetricValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BillableMetricValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BillableMetricValue Attribute Value",
				"While creating a BillableMetricValue value, a missing attribute value was detected. "+
					"A BillableMetricValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BillableMetricValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BillableMetricValue Attribute Type",
				"While creating a BillableMetricValue value, an invalid attribute value was detected. "+
					"A BillableMetricValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BillableMetricValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BillableMetricValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BillableMetricValue Attribute Value",
				"While creating a BillableMetricValue value, an extra attribute value was detected. "+
					"A BillableMetricValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BillableMetricValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBillableMetricValueUnknown(), diags
	}

	aggregationTypeAttribute, ok := attributes["aggregation_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregation_type is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	aggregationTypeVal, ok := aggregationTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregation_type expected to be basetypes.StringValue, was: %T`, aggregationTypeAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewBillableMetricValueUnknown(), diags
	}

	return BillableMetricValue{
		AggregationType: aggregationTypeVal,
		Code:            codeVal,
		LagoId:          lagoIdVal,
		Name:            nameVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBillableMetricValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BillableMetricValue {
	object, diags := NewBillableMetricValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBillableMetricValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BillableMetricType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBillableMetricValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBillableMetricValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBillableMetricValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBillableMetricValueMust(BillableMetricValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BillableMetricType) ValueType(ctx context.Context) attr.Value {
	return BillableMetricValue{}
}

var _ basetypes.ObjectValuable = BillableMetricValue{}

type BillableMetricValue struct {
	AggregationType basetypes.StringValue `tfsdk:"aggregation_type"`
	Code            basetypes.StringValue `tfsdk:"code"`
	LagoId          basetypes.StringValue `tfsdk:"lago_id"`
	Name            basetypes.StringValue `tfsdk:"name"`
	state           attr.ValueState
}

func (v BillableMetricValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["aggregation_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AggregationType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggregation_type"] = val

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BillableMetricValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BillableMetricValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BillableMetricValue) String() string {
	return "BillableMetricValue"
}

func (v BillableMetricValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"aggregation_type": basetypes.StringType{},
		"code":             basetypes.StringType{},
		"lago_id":          basetypes.StringType{},
		"name":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aggregation_type": v.AggregationType,
			"code":             v.Code,
			"lago_id":          v.LagoId,
			"name":             v.Name,
		})

	return objVal, diags
}

func (v BillableMetricValue) Equal(o attr.Value) bool {
	other, ok := o.(BillableMetricValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AggregationType.Equal(other.AggregationType) {
		return false
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v BillableMetricValue) Type(ctx context.Context) attr.Type {
	return BillableMetricType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BillableMetricValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aggregation_type": basetypes.StringType{},
		"code":             basetypes.StringType{},
		"lago_id":          basetypes.StringType{},
		"name":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ChargeType{}

type ChargeType struct {
	basetypes.ObjectType
}

func (t ChargeType) Equal(o attr.Type) bool {
	other, ok := o.(ChargeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ChargeType) String() string {
	return "ChargeType"
}

func (t ChargeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	chargeModelAttribute, ok := attributes["charge_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`charge_model is missing from object`)

		return nil, diags
	}

	chargeModelVal, ok := chargeModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`charge_model expected to be basetypes.StringValue, was: %T`, chargeModelAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ChargeValue{
		ChargeModel:        chargeModelVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		LagoId:             lagoIdVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewChargeValueNull() ChargeValue {
	return ChargeValue{
		state: attr.ValueStateNull,
	}
}

func NewChargeValueUnknown() ChargeValue {
	return ChargeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewChargeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ChargeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ChargeValue Attribute Value",
				"While creating a ChargeValue value, a missing attribute value was detected. "+
					"A ChargeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChargeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ChargeValue Attribute Type",
				"While creating a ChargeValue value, an invalid attribute value was detected. "+
					"A ChargeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ChargeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ChargeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ChargeValue Attribute Value",
				"While creating a ChargeValue value, an extra attribute value was detected. "+
					"A ChargeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ChargeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewChargeValueUnknown(), diags
	}

	chargeModelAttribute, ok := attributes["charge_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`charge_model is missing from object`)

		return NewChargeValueUnknown(), diags
	}

	chargeModelVal, ok := chargeModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`charge_model expected to be basetypes.StringValue, was: %T`, chargeModelAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewChargeValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewChargeValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	if diags.HasError() {
		return NewChargeValueUnknown(), diags
	}

	return ChargeValue{
		ChargeModel:        chargeModelVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		LagoId:             lagoIdVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewChargeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ChargeValue {
	object, diags := NewChargeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewChargeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ChargeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewChargeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewChargeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewChargeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewChargeValueMust(ChargeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ChargeType) ValueType(ctx context.Context) attr.Value {
	return ChargeValue{}
}

var _ basetypes.ObjectValuable = ChargeValue{}

type ChargeValue struct {
	ChargeModel        basetypes.StringValue `tfsdk:"charge_model"`
	InvoiceDisplayName basetypes.StringValue `tfsdk:"invoice_display_name"`
	LagoId             basetypes.StringValue `tfsdk:"lago_id"`
	state              attr.ValueState
}

func (v ChargeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["charge_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ChargeModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["charge_model"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ChargeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ChargeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ChargeValue) String() string {
	return "ChargeValue"
}

func (v ChargeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"charge_model":         basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"lago_id":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"charge_model":         v.ChargeModel,
			"invoice_display_name": v.InvoiceDisplayName,
			"lago_id":              v.LagoId,
		})

	return objVal, diags
}

func (v ChargeValue) Equal(o attr.Value) bool {
	other, ok := o.(ChargeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ChargeModel.Equal(other.ChargeModel) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	return true
}

func (v ChargeValue) Type(ctx context.Context) attr.Type {
	return ChargeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ChargeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"charge_model":         basetypes.StringType{},
		"invoice_display_name": basetypes.StringType{},
		"lago_id":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FiltersType{}

type FiltersType struct {
	basetypes.ObjectType
}

func (t FiltersType) Equal(o attr.Type) bool {
	other, ok := o.(FiltersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FiltersType) String() string {
	return "FiltersType"
}

func (t FiltersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	eventsCountAttribute, ok := attributes["events_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`events_count is missing from object`)

		return nil, diags
	}

	eventsCountVal, ok := eventsCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`events_count expected to be basetypes.Int64Value, was: %T`, eventsCountAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return nil, diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.MapValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FiltersValue{
		AmountCents:        amountCentsVal,
		EventsCount:        eventsCountVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		Units:              unitsVal,
		Values:             valuesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueNull() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateNull,
	}
}

func NewFiltersValueUnknown() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFiltersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FiltersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FiltersValue Attribute Value",
				"While creating a FiltersValue value, a missing attribute value was detected. "+
					"A FiltersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FiltersValue Attribute Type",
				"While creating a FiltersValue value, an invalid attribute value was detected. "+
					"A FiltersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FiltersValue Attribute Value",
				"While creating a FiltersValue value, an extra attribute value was detected. "+
					"A FiltersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FiltersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	eventsCountAttribute, ok := attributes["events_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`events_count is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	eventsCountVal, ok := eventsCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`events_count expected to be basetypes.Int64Value, was: %T`, eventsCountAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.MapValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	return FiltersValue{
		AmountCents:        amountCentsVal,
		EventsCount:        eventsCountVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		Units:              unitsVal,
		Values:             valuesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FiltersValue {
	object, diags := NewFiltersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFiltersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FiltersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFiltersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFiltersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFiltersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFiltersValueMust(FiltersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FiltersType) ValueType(ctx context.Context) attr.Value {
	return FiltersValue{}
}

var _ basetypes.ObjectValuable = FiltersValue{}

type FiltersValue struct {
	AmountCents        basetypes.Int64Value  `tfsdk:"amount_cents"`
	EventsCount        basetypes.Int64Value  `tfsdk:"events_count"`
	InvoiceDisplayName basetypes.StringValue `tfsdk:"invoice_display_name"`
	Units              basetypes.StringValue `tfsdk:"units"`
	Values             basetypes.MapValue    `tfsdk:"values"`
	state              attr.ValueState
}

func (v FiltersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["events_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["units"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["values"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.EventsCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["events_count"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.Units.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["units"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FiltersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FiltersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FiltersValue) String() string {
	return "FiltersValue"
}

func (v FiltersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valuesVal basetypes.MapValue
	switch {
	case v.Values.IsUnknown():
		valuesVal = types.MapUnknown(types.StringType)
	case v.Values.IsNull():
		valuesVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		valuesVal, d = types.MapValue(types.StringType, v.Values.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount_cents":         basetypes.Int64Type{},
			"events_count":         basetypes.Int64Type{},
			"invoice_display_name": basetypes.StringType{},
			"units":                basetypes.StringType{},
			"values": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":         basetypes.Int64Type{},
		"events_count":         basetypes.Int64Type{},
		"invoice_display_name": basetypes.StringType{},
		"units":                basetypes.StringType{},
		"values": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":         v.AmountCents,
			"events_count":         v.EventsCount,
			"invoice_display_name": v.InvoiceDisplayName,
			"units":                v.Units,
			"values":               valuesVal,
		})

	return objVal, diags
}

func (v FiltersValue) Equal(o attr.Value) bool {
	other, ok := o.(FiltersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.EventsCount.Equal(other.EventsCount) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.Units.Equal(other.Units) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v FiltersValue) Type(ctx context.Context) attr.Type {
	return FiltersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FiltersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":         basetypes.Int64Type{},
		"events_count":         basetypes.Int64Type{},
		"invoice_display_name": basetypes.StringType{},
		"units":                basetypes.StringType{},
		"values": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = GroupedUsageType{}

type GroupedUsageType struct {
	basetypes.ObjectType
}

func (t GroupedUsageType) Equal(o attr.Type) bool {
	other, ok := o.(GroupedUsageType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GroupedUsageType) String() string {
	return "GroupedUsageType"
}

func (t GroupedUsageType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	eventsCountAttribute, ok := attributes["events_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`events_count is missing from object`)

		return nil, diags
	}

	eventsCountVal, ok := eventsCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`events_count expected to be basetypes.Int64Value, was: %T`, eventsCountAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	groupedByAttribute, ok := attributes["grouped_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_by is missing from object`)

		return nil, diags
	}

	groupedByVal, ok := groupedByAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_by expected to be basetypes.MapValue, was: %T`, groupedByAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return nil, diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GroupedUsageValue{
		AmountCents: amountCentsVal,
		EventsCount: eventsCountVal,
		Filters:     filtersVal,
		GroupedBy:   groupedByVal,
		Units:       unitsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewGroupedUsageValueNull() GroupedUsageValue {
	return GroupedUsageValue{
		state: attr.ValueStateNull,
	}
}

func NewGroupedUsageValueUnknown() GroupedUsageValue {
	return GroupedUsageValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGroupedUsageValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GroupedUsageValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GroupedUsageValue Attribute Value",
				"While creating a GroupedUsageValue value, a missing attribute value was detected. "+
					"A GroupedUsageValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GroupedUsageValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GroupedUsageValue Attribute Type",
				"While creating a GroupedUsageValue value, an invalid attribute value was detected. "+
					"A GroupedUsageValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GroupedUsageValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GroupedUsageValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GroupedUsageValue Attribute Value",
				"While creating a GroupedUsageValue value, an extra attribute value was detected. "+
					"A GroupedUsageValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GroupedUsageValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGroupedUsageValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewGroupedUsageValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	eventsCountAttribute, ok := attributes["events_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`events_count is missing from object`)

		return NewGroupedUsageValueUnknown(), diags
	}

	eventsCountVal, ok := eventsCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`events_count expected to be basetypes.Int64Value, was: %T`, eventsCountAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewGroupedUsageValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	groupedByAttribute, ok := attributes["grouped_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grouped_by is missing from object`)

		return NewGroupedUsageValueUnknown(), diags
	}

	groupedByVal, ok := groupedByAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grouped_by expected to be basetypes.MapValue, was: %T`, groupedByAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return NewGroupedUsageValueUnknown(), diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	if diags.HasError() {
		return NewGroupedUsageValueUnknown(), diags
	}

	return GroupedUsageValue{
		AmountCents: amountCentsVal,
		EventsCount: eventsCountVal,
		Filters:     filtersVal,
		GroupedBy:   groupedByVal,
		Units:       unitsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewGroupedUsageValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GroupedUsageValue {
	object, diags := NewGroupedUsageValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGroupedUsageValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GroupedUsageType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGroupedUsageValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGroupedUsageValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGroupedUsageValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGroupedUsageValueMust(GroupedUsageValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GroupedUsageType) ValueType(ctx context.Context) attr.Value {
	return GroupedUsageValue{}
}

var _ basetypes.ObjectValuable = GroupedUsageValue{}

type GroupedUsageValue struct {
	AmountCents basetypes.Int64Value  `tfsdk:"amount_cents"`
	EventsCount basetypes.Int64Value  `tfsdk:"events_count"`
	Filters     basetypes.ListValue   `tfsdk:"filters"`
	GroupedBy   basetypes.MapValue    `tfsdk:"grouped_by"`
	Units       basetypes.StringValue `tfsdk:"units"`
	state       attr.ValueState
}

func (v GroupedUsageValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["events_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["filters"] = basetypes.ListType{
		ElemType: FiltersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["grouped_by"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["units"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.EventsCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["events_count"] = val

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.GroupedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["grouped_by"] = val

		val, err = v.Units.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["units"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GroupedUsageValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GroupedUsageValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GroupedUsageValue) String() string {
	return "GroupedUsageValue"
}

func (v GroupedUsageValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	filters := types.ListValueMust(
		FiltersType{
			basetypes.ObjectType{
				AttrTypes: FiltersValue{}.AttributeTypes(ctx),
			},
		},
		v.Filters.Elements(),
	)

	if v.Filters.IsNull() {
		filters = types.ListNull(
			FiltersType{
				basetypes.ObjectType{
					AttrTypes: FiltersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Filters.IsUnknown() {
		filters = types.ListUnknown(
			FiltersType{
				basetypes.ObjectType{
					AttrTypes: FiltersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var groupedByVal basetypes.MapValue
	switch {
	case v.GroupedBy.IsUnknown():
		groupedByVal = types.MapUnknown(types.StringType)
	case v.GroupedBy.IsNull():
		groupedByVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		groupedByVal, d = types.MapValue(types.StringType, v.GroupedBy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount_cents": basetypes.Int64Type{},
			"events_count": basetypes.Int64Type{},
			"filters": basetypes.ListType{
				ElemType: FiltersValue{}.Type(ctx),
			},
			"grouped_by": basetypes.MapType{
				ElemType: types.StringType,
			},
			"units": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents": basetypes.Int64Type{},
		"events_count": basetypes.Int64Type{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"grouped_by": basetypes.MapType{
			ElemType: types.StringType,
		},
		"units": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents": v.AmountCents,
			"events_count": v.EventsCount,
			"filters":      filters,
			"grouped_by":   groupedByVal,
			"units":        v.Units,
		})

	return objVal, diags
}

func (v GroupedUsageValue) Equal(o attr.Value) bool {
	other, ok := o.(GroupedUsageValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.EventsCount.Equal(other.EventsCount) {
		return false
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.GroupedBy.Equal(other.GroupedBy) {
		return false
	}

	if !v.Units.Equal(other.Units) {
		return false
	}

	return true
}

func (v GroupedUsageValue) Type(ctx context.Context) attr.Type {
	return GroupedUsageType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GroupedUsageValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents": basetypes.Int64Type{},
		"events_count": basetypes.Int64Type{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"grouped_by": basetypes.MapType{
			ElemType: types.StringType,
		},
		"units": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FiltersType{}

type FiltersType struct {
	basetypes.ObjectType
}

func (t FiltersType) Equal(o attr.Type) bool {
	other, ok := o.(FiltersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FiltersType) String() string {
	return "FiltersType"
}

func (t FiltersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return nil, diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	eventsCountAttribute, ok := attributes["events_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`events_count is missing from object`)

		return nil, diags
	}

	eventsCountVal, ok := eventsCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`events_count expected to be basetypes.Int64Value, was: %T`, eventsCountAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return nil, diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return nil, diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.MapValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FiltersValue{
		AmountCents:        amountCentsVal,
		EventsCount:        eventsCountVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		Units:              unitsVal,
		Values:             valuesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueNull() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateNull,
	}
}

func NewFiltersValueUnknown() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFiltersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FiltersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FiltersValue Attribute Value",
				"While creating a FiltersValue value, a missing attribute value was detected. "+
					"A FiltersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FiltersValue Attribute Type",
				"While creating a FiltersValue value, an invalid attribute value was detected. "+
					"A FiltersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FiltersValue Attribute Value",
				"While creating a FiltersValue value, an extra attribute value was detected. "+
					"A FiltersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FiltersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	amountCentsAttribute, ok := attributes["amount_cents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amount_cents is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	amountCentsVal, ok := amountCentsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amount_cents expected to be basetypes.Int64Value, was: %T`, amountCentsAttribute))
	}

	eventsCountAttribute, ok := attributes["events_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`events_count is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	eventsCountVal, ok := eventsCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`events_count expected to be basetypes.Int64Value, was: %T`, eventsCountAttribute))
	}

	invoiceDisplayNameAttribute, ok := attributes["invoice_display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`invoice_display_name is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	invoiceDisplayNameVal, ok := invoiceDisplayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`invoice_display_name expected to be basetypes.StringValue, was: %T`, invoiceDisplayNameAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.StringValue, was: %T`, unitsAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.MapValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	return FiltersValue{
		AmountCents:        amountCentsVal,
		EventsCount:        eventsCountVal,
		InvoiceDisplayName: invoiceDisplayNameVal,
		Units:              unitsVal,
		Values:             valuesVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FiltersValue {
	object, diags := NewFiltersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFiltersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FiltersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFiltersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFiltersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFiltersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFiltersValueMust(FiltersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FiltersType) ValueType(ctx context.Context) attr.Value {
	return FiltersValue{}
}

var _ basetypes.ObjectValuable = FiltersValue{}

type FiltersValue struct {
	AmountCents        basetypes.Int64Value  `tfsdk:"amount_cents"`
	EventsCount        basetypes.Int64Value  `tfsdk:"events_count"`
	InvoiceDisplayName basetypes.StringValue `tfsdk:"invoice_display_name"`
	Units              basetypes.StringValue `tfsdk:"units"`
	Values             basetypes.MapValue    `tfsdk:"values"`
	state              attr.ValueState
}

func (v FiltersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["amount_cents"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["events_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["invoice_display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["units"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["values"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AmountCents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amount_cents"] = val

		val, err = v.EventsCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["events_count"] = val

		val, err = v.InvoiceDisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["invoice_display_name"] = val

		val, err = v.Units.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["units"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FiltersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FiltersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FiltersValue) String() string {
	return "FiltersValue"
}

func (v FiltersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valuesVal basetypes.MapValue
	switch {
	case v.Values.IsUnknown():
		valuesVal = types.MapUnknown(types.StringType)
	case v.Values.IsNull():
		valuesVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		valuesVal, d = types.MapValue(types.StringType, v.Values.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"amount_cents":         basetypes.Int64Type{},
			"events_count":         basetypes.Int64Type{},
			"invoice_display_name": basetypes.StringType{},
			"units":                basetypes.StringType{},
			"values": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"amount_cents":         basetypes.Int64Type{},
		"events_count":         basetypes.Int64Type{},
		"invoice_display_name": basetypes.StringType{},
		"units":                basetypes.StringType{},
		"values": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"amount_cents":         v.AmountCents,
			"events_count":         v.EventsCount,
			"invoice_display_name": v.InvoiceDisplayName,
			"units":                v.Units,
			"values":               valuesVal,
		})

	return objVal, diags
}

func (v FiltersValue) Equal(o attr.Value) bool {
	other, ok := o.(FiltersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AmountCents.Equal(other.AmountCents) {
		return false
	}

	if !v.EventsCount.Equal(other.EventsCount) {
		return false
	}

	if !v.InvoiceDisplayName.Equal(other.InvoiceDisplayName) {
		return false
	}

	if !v.Units.Equal(other.Units) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v FiltersValue) Type(ctx context.Context) attr.Type {
	return FiltersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FiltersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"amount_cents":         basetypes.Int64Type{},
		"events_count":         basetypes.Int64Type{},
		"invoice_display_name": basetypes.StringType{},
		"units":                basetypes.StringType{},
		"values": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}
