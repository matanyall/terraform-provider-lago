// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_billable_metrics

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func BillableMetricsResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"billable_metric": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"aggregation_type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Aggregation method used to compute usage for this billable metric.",
						MarkdownDescription: "Aggregation method used to compute usage for this billable metric.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"count_agg",
								"sum_agg",
								"max_agg",
								"unique_count_agg",
								"weighted_sum_agg",
								"latest_agg",
							),
						},
					},
					"code": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Unique code used to identify the billable metric associated with the API request. This code associates each event with the correct metric.",
						MarkdownDescription: "Unique code used to identify the billable metric associated with the API request. This code associates each event with the correct metric.",
					},
					"created_at": schema.StringAttribute{
						Computed:            true,
						Description:         "Creation date of the billable metric.",
						MarkdownDescription: "Creation date of the billable metric.",
					},
					"description": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Internal description of the billable metric.",
						MarkdownDescription: "Internal description of the billable metric.",
					},
					"expression": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Expression used to calculate the event units. The expression is evalutated for each event and the result is then used to calculate the total aggregated units.\nAccepted function are `ceil`, `concat` and `round` as well as `+`, `-`, `\\` and `*` operations.\nRound is accepting an optional second parameter to specify the number of decimal.\n",
						MarkdownDescription: "Expression used to calculate the event units. The expression is evalutated for each event and the result is then used to calculate the total aggregated units.\nAccepted function are `ceil`, `concat` and `round` as well as `+`, `-`, `\\` and `*` operations.\nRound is accepting an optional second parameter to specify the number of decimal.\n",
					},
					"field_name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Property of the billable metric used for aggregating usage data. This field is not required for `count_agg`.",
						MarkdownDescription: "Property of the billable metric used for aggregating usage data. This field is not required for `count_agg`.",
					},
					"filters": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"key": schema.StringAttribute{
									Required:            true,
									Description:         "Filter key to add to the event properties payload",
									MarkdownDescription: "Filter key to add to the event properties payload",
								},
								"values": schema.ListAttribute{
									ElementType:         types.StringType,
									Required:            true,
									Description:         "List of possible filter values",
									MarkdownDescription: "List of possible filter values",
								},
							},
							CustomType: FiltersType{
								ObjectType: types.ObjectType{
									AttrTypes: FiltersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
					},
					"lago_id": schema.StringAttribute{
						Computed:            true,
						Description:         "Unique identifier of the billable metric created by Lago.",
						MarkdownDescription: "Unique identifier of the billable metric created by Lago.",
					},
					"name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Name of the billable metric.",
						MarkdownDescription: "Name of the billable metric.",
					},
					"recurring": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Defines if the billable metric is persisted billing period over billing period.\n\n- If set to `true`: the accumulated number of units calculated from the previous billing period is persisted to the next billing period.\n- If set to `false`: the accumulated number of units is reset to 0 at the end of the billing period.\n- If not defined in the request, default value is `false`.",
						MarkdownDescription: "Defines if the billable metric is persisted billing period over billing period.\n\n- If set to `true`: the accumulated number of units calculated from the previous billing period is persisted to the next billing period.\n- If set to `false`: the accumulated number of units is reset to 0 at the end of the billing period.\n- If not defined in the request, default value is `false`.",
					},
					"rounding_function": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Refers to the numeric value or mathematical expression that will be rounded based on the calculated number of billing units. Possible values are `round`, `ceil` and `floor`.",
						MarkdownDescription: "Refers to the numeric value or mathematical expression that will be rounded based on the calculated number of billing units. Possible values are `round`, `ceil` and `floor`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"ceil",
								"floor",
								"round",
							),
						},
					},
					"rounding_precision": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Specifies the number of decimal places to which the `rounding_function` will be rounded. It can be a positive or negative value.",
						MarkdownDescription: "Specifies the number of decimal places to which the `rounding_function` will be rounded. It can be a positive or negative value.",
					},
					"weighted_interval": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Parameter exclusively utilized in conjunction with the `weighted_sum` aggregation type. It serves to adjust the aggregation result by assigning weights and proration to the result based on time intervals. When this field is not provided, the default time interval is assumed to be in `seconds`.",
						MarkdownDescription: "Parameter exclusively utilized in conjunction with the `weighted_sum` aggregation type. It serves to adjust the aggregation result by assigning weights and proration to the result based on time intervals. When this field is not provided, the default time interval is assumed to be in `seconds`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"seconds",
							),
						},
					},
				},
				CustomType: BillableMetricType{
					ObjectType: types.ObjectType{
						AttrTypes: BillableMetricValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"code": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Code of the existing billable metric.",
				MarkdownDescription: "Code of the existing billable metric.",
			},
		},
	}
}

type BillableMetricsModel struct {
	BillableMetric BillableMetricValue `tfsdk:"billable_metric"`
	Code           types.String        `tfsdk:"code"`
}

var _ basetypes.ObjectTypable = BillableMetricType{}

type BillableMetricType struct {
	basetypes.ObjectType
}

func (t BillableMetricType) Equal(o attr.Type) bool {
	other, ok := o.(BillableMetricType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BillableMetricType) String() string {
	return "BillableMetricType"
}

func (t BillableMetricType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aggregationTypeAttribute, ok := attributes["aggregation_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregation_type is missing from object`)

		return nil, diags
	}

	aggregationTypeVal, ok := aggregationTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregation_type expected to be basetypes.StringValue, was: %T`, aggregationTypeAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	expressionAttribute, ok := attributes["expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expression is missing from object`)

		return nil, diags
	}

	expressionVal, ok := expressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expression expected to be basetypes.StringValue, was: %T`, expressionAttribute))
	}

	fieldNameAttribute, ok := attributes["field_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`field_name is missing from object`)

		return nil, diags
	}

	fieldNameVal, ok := fieldNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`field_name expected to be basetypes.StringValue, was: %T`, fieldNameAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return nil, diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	recurringAttribute, ok := attributes["recurring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recurring is missing from object`)

		return nil, diags
	}

	recurringVal, ok := recurringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recurring expected to be basetypes.BoolValue, was: %T`, recurringAttribute))
	}

	roundingFunctionAttribute, ok := attributes["rounding_function"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rounding_function is missing from object`)

		return nil, diags
	}

	roundingFunctionVal, ok := roundingFunctionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rounding_function expected to be basetypes.StringValue, was: %T`, roundingFunctionAttribute))
	}

	roundingPrecisionAttribute, ok := attributes["rounding_precision"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rounding_precision is missing from object`)

		return nil, diags
	}

	roundingPrecisionVal, ok := roundingPrecisionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rounding_precision expected to be basetypes.Int64Value, was: %T`, roundingPrecisionAttribute))
	}

	weightedIntervalAttribute, ok := attributes["weighted_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weighted_interval is missing from object`)

		return nil, diags
	}

	weightedIntervalVal, ok := weightedIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weighted_interval expected to be basetypes.StringValue, was: %T`, weightedIntervalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BillableMetricValue{
		AggregationType:   aggregationTypeVal,
		Code:              codeVal,
		CreatedAt:         createdAtVal,
		Description:       descriptionVal,
		Expression:        expressionVal,
		FieldName:         fieldNameVal,
		Filters:           filtersVal,
		LagoId:            lagoIdVal,
		Name:              nameVal,
		Recurring:         recurringVal,
		RoundingFunction:  roundingFunctionVal,
		RoundingPrecision: roundingPrecisionVal,
		WeightedInterval:  weightedIntervalVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBillableMetricValueNull() BillableMetricValue {
	return BillableMetricValue{
		state: attr.ValueStateNull,
	}
}

func NewBillableMetricValueUnknown() BillableMetricValue {
	return BillableMetricValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBillableMetricValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BillableMetricValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BillableMetricValue Attribute Value",
				"While creating a BillableMetricValue value, a missing attribute value was detected. "+
					"A BillableMetricValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BillableMetricValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BillableMetricValue Attribute Type",
				"While creating a BillableMetricValue value, an invalid attribute value was detected. "+
					"A BillableMetricValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BillableMetricValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BillableMetricValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BillableMetricValue Attribute Value",
				"While creating a BillableMetricValue value, an extra attribute value was detected. "+
					"A BillableMetricValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BillableMetricValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBillableMetricValueUnknown(), diags
	}

	aggregationTypeAttribute, ok := attributes["aggregation_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregation_type is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	aggregationTypeVal, ok := aggregationTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregation_type expected to be basetypes.StringValue, was: %T`, aggregationTypeAttribute))
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	expressionAttribute, ok := attributes["expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expression is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	expressionVal, ok := expressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expression expected to be basetypes.StringValue, was: %T`, expressionAttribute))
	}

	fieldNameAttribute, ok := attributes["field_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`field_name is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	fieldNameVal, ok := fieldNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`field_name expected to be basetypes.StringValue, was: %T`, fieldNameAttribute))
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	lagoIdAttribute, ok := attributes["lago_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lago_id is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	lagoIdVal, ok := lagoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lago_id expected to be basetypes.StringValue, was: %T`, lagoIdAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	recurringAttribute, ok := attributes["recurring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recurring is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	recurringVal, ok := recurringAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recurring expected to be basetypes.BoolValue, was: %T`, recurringAttribute))
	}

	roundingFunctionAttribute, ok := attributes["rounding_function"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rounding_function is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	roundingFunctionVal, ok := roundingFunctionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rounding_function expected to be basetypes.StringValue, was: %T`, roundingFunctionAttribute))
	}

	roundingPrecisionAttribute, ok := attributes["rounding_precision"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rounding_precision is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	roundingPrecisionVal, ok := roundingPrecisionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rounding_precision expected to be basetypes.Int64Value, was: %T`, roundingPrecisionAttribute))
	}

	weightedIntervalAttribute, ok := attributes["weighted_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weighted_interval is missing from object`)

		return NewBillableMetricValueUnknown(), diags
	}

	weightedIntervalVal, ok := weightedIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weighted_interval expected to be basetypes.StringValue, was: %T`, weightedIntervalAttribute))
	}

	if diags.HasError() {
		return NewBillableMetricValueUnknown(), diags
	}

	return BillableMetricValue{
		AggregationType:   aggregationTypeVal,
		Code:              codeVal,
		CreatedAt:         createdAtVal,
		Description:       descriptionVal,
		Expression:        expressionVal,
		FieldName:         fieldNameVal,
		Filters:           filtersVal,
		LagoId:            lagoIdVal,
		Name:              nameVal,
		Recurring:         recurringVal,
		RoundingFunction:  roundingFunctionVal,
		RoundingPrecision: roundingPrecisionVal,
		WeightedInterval:  weightedIntervalVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBillableMetricValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BillableMetricValue {
	object, diags := NewBillableMetricValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBillableMetricValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BillableMetricType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBillableMetricValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBillableMetricValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBillableMetricValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBillableMetricValueMust(BillableMetricValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BillableMetricType) ValueType(ctx context.Context) attr.Value {
	return BillableMetricValue{}
}

var _ basetypes.ObjectValuable = BillableMetricValue{}

type BillableMetricValue struct {
	AggregationType   basetypes.StringValue `tfsdk:"aggregation_type"`
	Code              basetypes.StringValue `tfsdk:"code"`
	CreatedAt         basetypes.StringValue `tfsdk:"created_at"`
	Description       basetypes.StringValue `tfsdk:"description"`
	Expression        basetypes.StringValue `tfsdk:"expression"`
	FieldName         basetypes.StringValue `tfsdk:"field_name"`
	Filters           basetypes.ListValue   `tfsdk:"filters"`
	LagoId            basetypes.StringValue `tfsdk:"lago_id"`
	Name              basetypes.StringValue `tfsdk:"name"`
	Recurring         basetypes.BoolValue   `tfsdk:"recurring"`
	RoundingFunction  basetypes.StringValue `tfsdk:"rounding_function"`
	RoundingPrecision basetypes.Int64Value  `tfsdk:"rounding_precision"`
	WeightedInterval  basetypes.StringValue `tfsdk:"weighted_interval"`
	state             attr.ValueState
}

func (v BillableMetricValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["aggregation_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["expression"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["field_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["filters"] = basetypes.ListType{
		ElemType: FiltersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["lago_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recurring"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["rounding_function"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rounding_precision"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["weighted_interval"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.AggregationType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggregation_type"] = val

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Expression.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expression"] = val

		val, err = v.FieldName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["field_name"] = val

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.LagoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lago_id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Recurring.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recurring"] = val

		val, err = v.RoundingFunction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rounding_function"] = val

		val, err = v.RoundingPrecision.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rounding_precision"] = val

		val, err = v.WeightedInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["weighted_interval"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BillableMetricValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BillableMetricValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BillableMetricValue) String() string {
	return "BillableMetricValue"
}

func (v BillableMetricValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	filters := types.ListValueMust(
		FiltersType{
			basetypes.ObjectType{
				AttrTypes: FiltersValue{}.AttributeTypes(ctx),
			},
		},
		v.Filters.Elements(),
	)

	if v.Filters.IsNull() {
		filters = types.ListNull(
			FiltersType{
				basetypes.ObjectType{
					AttrTypes: FiltersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Filters.IsUnknown() {
		filters = types.ListUnknown(
			FiltersType{
				basetypes.ObjectType{
					AttrTypes: FiltersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"aggregation_type": basetypes.StringType{},
		"code":             basetypes.StringType{},
		"created_at":       basetypes.StringType{},
		"description":      basetypes.StringType{},
		"expression":       basetypes.StringType{},
		"field_name":       basetypes.StringType{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"lago_id":            basetypes.StringType{},
		"name":               basetypes.StringType{},
		"recurring":          basetypes.BoolType{},
		"rounding_function":  basetypes.StringType{},
		"rounding_precision": basetypes.Int64Type{},
		"weighted_interval":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aggregation_type":   v.AggregationType,
			"code":               v.Code,
			"created_at":         v.CreatedAt,
			"description":        v.Description,
			"expression":         v.Expression,
			"field_name":         v.FieldName,
			"filters":            filters,
			"lago_id":            v.LagoId,
			"name":               v.Name,
			"recurring":          v.Recurring,
			"rounding_function":  v.RoundingFunction,
			"rounding_precision": v.RoundingPrecision,
			"weighted_interval":  v.WeightedInterval,
		})

	return objVal, diags
}

func (v BillableMetricValue) Equal(o attr.Value) bool {
	other, ok := o.(BillableMetricValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AggregationType.Equal(other.AggregationType) {
		return false
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Expression.Equal(other.Expression) {
		return false
	}

	if !v.FieldName.Equal(other.FieldName) {
		return false
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.LagoId.Equal(other.LagoId) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Recurring.Equal(other.Recurring) {
		return false
	}

	if !v.RoundingFunction.Equal(other.RoundingFunction) {
		return false
	}

	if !v.RoundingPrecision.Equal(other.RoundingPrecision) {
		return false
	}

	if !v.WeightedInterval.Equal(other.WeightedInterval) {
		return false
	}

	return true
}

func (v BillableMetricValue) Type(ctx context.Context) attr.Type {
	return BillableMetricType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BillableMetricValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aggregation_type": basetypes.StringType{},
		"code":             basetypes.StringType{},
		"created_at":       basetypes.StringType{},
		"description":      basetypes.StringType{},
		"expression":       basetypes.StringType{},
		"field_name":       basetypes.StringType{},
		"filters": basetypes.ListType{
			ElemType: FiltersValue{}.Type(ctx),
		},
		"lago_id":            basetypes.StringType{},
		"name":               basetypes.StringType{},
		"recurring":          basetypes.BoolType{},
		"rounding_function":  basetypes.StringType{},
		"rounding_precision": basetypes.Int64Type{},
		"weighted_interval":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FiltersType{}

type FiltersType struct {
	basetypes.ObjectType
}

func (t FiltersType) Equal(o attr.Type) bool {
	other, ok := o.(FiltersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FiltersType) String() string {
	return "FiltersType"
}

func (t FiltersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FiltersValue{
		Key:    keyVal,
		Values: valuesVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueNull() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateNull,
	}
}

func NewFiltersValueUnknown() FiltersValue {
	return FiltersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFiltersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FiltersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FiltersValue Attribute Value",
				"While creating a FiltersValue value, a missing attribute value was detected. "+
					"A FiltersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FiltersValue Attribute Type",
				"While creating a FiltersValue value, an invalid attribute value was detected. "+
					"A FiltersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FiltersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FiltersValue Attribute Value",
				"While creating a FiltersValue value, an extra attribute value was detected. "+
					"A FiltersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FiltersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewFiltersValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewFiltersValueUnknown(), diags
	}

	return FiltersValue{
		Key:    keyVal,
		Values: valuesVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewFiltersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FiltersValue {
	object, diags := NewFiltersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFiltersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FiltersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFiltersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFiltersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFiltersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFiltersValueMust(FiltersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FiltersType) ValueType(ctx context.Context) attr.Value {
	return FiltersValue{}
}

var _ basetypes.ObjectValuable = FiltersValue{}

type FiltersValue struct {
	Key    basetypes.StringValue `tfsdk:"key"`
	Values basetypes.ListValue   `tfsdk:"values"`
	state  attr.ValueState
}

func (v FiltersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["values"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FiltersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FiltersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FiltersValue) String() string {
	return "FiltersValue"
}

func (v FiltersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var valuesVal basetypes.ListValue
	switch {
	case v.Values.IsUnknown():
		valuesVal = types.ListUnknown(types.StringType)
	case v.Values.IsNull():
		valuesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		valuesVal, d = types.ListValue(types.StringType, v.Values.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"key": basetypes.StringType{},
			"values": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"key": basetypes.StringType{},
		"values": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"key":    v.Key,
			"values": valuesVal,
		})

	return objVal, diags
}

func (v FiltersValue) Equal(o attr.Value) bool {
	other, ok := o.(FiltersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v FiltersValue) Type(ctx context.Context) attr.Type {
	return FiltersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FiltersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"key": basetypes.StringType{},
		"values": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}
